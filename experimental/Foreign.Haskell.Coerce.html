<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Foreign.Haskell.Coerce</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Zero-cost coercion to cross the FFI boundary</a>
<a id="154" class="Comment">------------------------------------------------------------------------</a>

<a id="228" class="Symbol">{-#</a> <a id="232" class="Keyword">OPTIONS</a> <a id="240" class="Pragma">--cubical-compatible</a> <a id="261" class="Symbol">#-}</a>

<a id="266" class="Keyword">module</a> <a id="273" href="Foreign.Haskell.Coerce.html" class="Module">Foreign.Haskell.Coerce</a> <a id="296" class="Keyword">where</a>

<a id="303" class="Comment">------------------------------------------------------------------------</a>
<a id="376" class="Comment">-- Motivation</a>

<a id="391" class="Comment">-- Problem: No COMPILE directives for common inductive types</a>

<a id="453" class="Comment">-- In order to guarantee that the vast majority of the libary is</a>
<a id="518" class="Comment">-- considered safe by Agda, we had to remove the COMPILE pragmas</a>
<a id="583" class="Comment">-- associated to common inductive types.</a>
<a id="624" class="Comment">-- These directives cannot possibly be checked by the compiler and</a>
<a id="691" class="Comment">-- the user could define unsound mappings (e.g. swapping Bool&#39;s</a>
<a id="755" class="Comment">-- true and false).</a>

<a id="776" class="Comment">-- Solution: Essentially identical definitions + zero-cost coercions</a>

<a id="846" class="Comment">-- To solve this problem, we have introduced a number of essentially</a>
<a id="915" class="Comment">-- identical definitions in the Foreign.Haskell.* modules. However</a>
<a id="982" class="Comment">-- converting back and forth between the FFI-friendly type and its</a>
<a id="1049" class="Comment">-- safe counterpart would take linear time.</a>
<a id="1093" class="Comment">-- This module defines zero cost coercions between these types.</a>

<a id="1158" class="Comment">------------------------------------------------------------------------</a>
<a id="1231" class="Comment">-- Definition</a>

<a id="1246" class="Keyword">open</a> <a id="1251" class="Keyword">import</a> <a id="1258" href="Level.html" class="Module">Level</a> <a id="1264" class="Keyword">using</a> <a id="1270" class="Symbol">(</a><a id="1271" href="Agda.Primitive.html#591" class="Postulate">Level</a><a id="1276" class="Symbol">;</a> <a id="1278" href="Agda.Primitive.html#804" class="Primitive Operator">_⊔_</a><a id="1281" class="Symbol">)</a>
<a id="1283" class="Keyword">open</a> <a id="1288" class="Keyword">import</a> <a id="1295" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a>
<a id="1312" class="Keyword">open</a> <a id="1317" class="Keyword">import</a> <a id="1324" href="Agda.Builtin.Int.html" class="Module">Agda.Builtin.Int</a>

<a id="1342" class="Keyword">import</a> <a id="1349" href="IO.Primitive.html" class="Module">IO.Primitive</a>            <a id="1373" class="Symbol">as</a> <a id="1376" class="Module">STD</a>
<a id="1380" class="Keyword">import</a> <a id="1387" href="Data.List.Base.html" class="Module">Data.List.Base</a>          <a id="1411" class="Symbol">as</a> <a id="1414" class="Module">STD</a>
<a id="1418" class="Keyword">import</a> <a id="1425" href="Data.List.NonEmpty.Base.html" class="Module">Data.List.NonEmpty.Base</a> <a id="1449" class="Symbol">as</a> <a id="1452" class="Module">STD</a>
<a id="1456" class="Keyword">import</a> <a id="1463" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a>         <a id="1487" class="Symbol">as</a> <a id="1490" class="Module">STD</a>
<a id="1494" class="Keyword">import</a> <a id="1501" href="Data.Product.html" class="Module">Data.Product</a>            <a id="1525" class="Symbol">as</a> <a id="1528" class="Module">STD</a>
<a id="1532" class="Keyword">import</a> <a id="1539" href="Data.Sum.Base.html" class="Module">Data.Sum.Base</a>           <a id="1563" class="Symbol">as</a> <a id="1566" class="Module">STD</a>

<a id="1571" class="Keyword">import</a> <a id="1578" href="Foreign.Haskell.Pair.html" class="Module">Foreign.Haskell.Pair</a>          <a id="1608" class="Symbol">as</a> <a id="1611" class="Module">FFI</a>
<a id="1615" class="Keyword">import</a> <a id="1622" href="Foreign.Haskell.Either.html" class="Module">Foreign.Haskell.Either</a>        <a id="1652" class="Symbol">as</a> <a id="1655" class="Module">FFI</a>
<a id="1659" class="Keyword">import</a> <a id="1666" href="Foreign.Haskell.List.NonEmpty.html" class="Module">Foreign.Haskell.List.NonEmpty</a> <a id="1696" class="Symbol">as</a> <a id="1699" class="Module">FFI</a>

<a id="1704" class="Keyword">private</a>
  <a id="1714" class="Keyword">variable</a>
    <a id="1727" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="1729" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="1731" href="Foreign.Haskell.Coerce.html#1731" class="Generalizable">c</a> <a id="1733" href="Foreign.Haskell.Coerce.html#1733" class="Generalizable">d</a> <a id="1735" href="Foreign.Haskell.Coerce.html#1735" class="Generalizable">e</a> <a id="1737" href="Foreign.Haskell.Coerce.html#1737" class="Generalizable">f</a> <a id="1739" class="Symbol">:</a> <a id="1741" href="Agda.Primitive.html#591" class="Postulate">Level</a>
    <a id="1751" href="Foreign.Haskell.Coerce.html#1751" class="Generalizable">A</a> <a id="1753" class="Symbol">:</a> <a id="1755" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1759" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a>
    <a id="1765" href="Foreign.Haskell.Coerce.html#1765" class="Generalizable">B</a> <a id="1767" class="Symbol">:</a> <a id="1769" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1773" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a>
    <a id="1779" href="Foreign.Haskell.Coerce.html#1779" class="Generalizable">C</a> <a id="1781" class="Symbol">:</a> <a id="1783" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1787" href="Foreign.Haskell.Coerce.html#1731" class="Generalizable">c</a>
    <a id="1793" href="Foreign.Haskell.Coerce.html#1793" class="Generalizable">D</a> <a id="1795" class="Symbol">:</a> <a id="1797" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1801" href="Foreign.Haskell.Coerce.html#1733" class="Generalizable">d</a>

<a id="1804" class="Comment">-- We define a simple indexed datatype `Coercible`. A value of `Coercible A B`</a>
<a id="1883" class="Comment">-- is a proof that ̀A` and `B` have the same underlying runtime representation.</a>
<a id="1963" class="Comment">-- The only possible proof is an incantation from the implementer begging to</a>
<a id="2040" class="Comment">-- be trusted.</a>

<a id="2056" class="Comment">-- We need this type to be concrete so that overlapping instances can be checked</a>
<a id="2137" class="Comment">-- for equality: we do not care what proof we get as long as we get one.</a>

<a id="2211" class="Comment">-- We need for it to be a data type rather than a record type so that Agda does</a>
<a id="2291" class="Comment">-- not mistakenly build arbitrary instances by η-expansion.</a>

<a id="2352" class="Keyword">data</a> <a id="Coercible"></a><a id="2357" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="2367" class="Symbol">(</a><a id="2368" href="Foreign.Haskell.Coerce.html#2368" class="Bound">A</a> <a id="2370" class="Symbol">:</a> <a id="2372" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2376" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a><a id="2377" class="Symbol">)</a> <a id="2379" class="Symbol">(</a><a id="2380" href="Foreign.Haskell.Coerce.html#2380" class="Bound">B</a> <a id="2382" class="Symbol">:</a> <a id="2384" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2388" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a><a id="2389" class="Symbol">)</a> <a id="2391" class="Symbol">:</a> <a id="2393" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2397" class="Keyword">where</a>
  <a id="Coercible.TrustMe"></a><a id="2405" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a> <a id="2413" class="Symbol">:</a> <a id="2415" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="2425" href="Foreign.Haskell.Coerce.html#2368" class="Bound">A</a> <a id="2427" href="Foreign.Haskell.Coerce.html#2380" class="Bound">B</a>

<a id="2430" class="Symbol">{-#</a> <a id="2434" class="Keyword">FOREIGN</a> <a id="2442" class="Pragma">GHC</a> <a id="2446" class="Pragma">data</a> <a id="2451" class="Pragma">AgdaCoercible</a> <a id="2465" class="Pragma">l1</a> <a id="2468" class="Pragma">l2</a> <a id="2471" class="Pragma">a</a> <a id="2473" class="Pragma">b</a> <a id="2475" class="Pragma">=</a> <a id="2477" class="Pragma">TrustMe</a> <a id="2485" class="Symbol">#-}</a>
<a id="2489" class="Symbol">{-#</a> <a id="2493" class="Keyword">COMPILE</a> <a id="2501" class="Keyword">GHC</a> <a id="2505" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="2515" class="Pragma">=</a> <a id="2517" class="Pragma">data</a> <a id="2522" class="Pragma">AgdaCoercible</a> <a id="2536" class="Pragma">(TrustMe)</a> <a id="2546" class="Symbol">#-}</a>

<a id="2551" class="Comment">-- Once we get our hands on a proof that `Coercible A B` we postulate that it</a>
<a id="2629" class="Comment">-- is safe to convert an `A` into a `B`. This is done under the hood by using</a>
<a id="2707" class="Comment">-- `unsafeCoerce`.</a>

<a id="2727" class="Keyword">postulate</a> <a id="coerce"></a><a id="2737" href="Foreign.Haskell.Coerce.html#2737" class="Postulate">coerce</a> <a id="2744" class="Symbol">:</a> <a id="2746" class="Symbol">{{</a><a id="2748" href="Foreign.Haskell.Coerce.html#2748" class="Bound">_</a> <a id="2750" class="Symbol">:</a> <a id="2752" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="2762" href="Foreign.Haskell.Coerce.html#1751" class="Generalizable">A</a> <a id="2764" href="Foreign.Haskell.Coerce.html#1765" class="Generalizable">B</a><a id="2765" class="Symbol">}}</a> <a id="2768" class="Symbol">→</a> <a id="2770" href="Foreign.Haskell.Coerce.html#1751" class="Generalizable">A</a> <a id="2772" class="Symbol">→</a> <a id="2774" href="Foreign.Haskell.Coerce.html#1765" class="Generalizable">B</a>

<a id="2777" class="Symbol">{-#</a> <a id="2781" class="Keyword">FOREIGN</a> <a id="2789" class="Pragma">GHC</a> <a id="2793" class="Pragma">import</a> <a id="2800" class="Pragma">Unsafe.Coerce</a> <a id="2814" class="Symbol">#-}</a>
<a id="2818" class="Symbol">{-#</a> <a id="2822" class="Keyword">COMPILE</a> <a id="2830" class="Keyword">GHC</a> <a id="2834" href="Foreign.Haskell.Coerce.html#2737" class="Postulate">coerce</a> <a id="2841" class="Pragma">=</a> <a id="2843" class="Pragma">\</a> <a id="2845" class="Pragma">_</a> <a id="2847" class="Pragma">_</a> <a id="2849" class="Pragma">_</a> <a id="2851" class="Pragma">_</a> <a id="2853" class="Pragma">_</a> <a id="2855" class="Pragma">-&gt;</a> <a id="2858" class="Pragma">unsafeCoerce</a> <a id="2871" class="Symbol">#-}</a>

<a id="2876" class="Comment">------------------------------------------------------------------------</a>
<a id="2949" class="Comment">-- Unary and binary variants for covariant type constructors</a>

<a id="Coercible₁"></a><a id="3011" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="3022" class="Symbol">:</a> <a id="3024" class="Symbol">∀</a> <a id="3026" href="Foreign.Haskell.Coerce.html#3026" class="Bound">a</a> <a id="3028" href="Foreign.Haskell.Coerce.html#3028" class="Bound">c</a> <a id="3030" class="Symbol">→</a> <a id="3032" class="Symbol">(</a><a id="3033" href="Foreign.Haskell.Coerce.html#3033" class="Bound">T</a> <a id="3035" class="Symbol">:</a> <a id="3037" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3041" href="Foreign.Haskell.Coerce.html#3026" class="Bound">a</a> <a id="3043" class="Symbol">→</a> <a id="3045" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3049" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a><a id="3050" class="Symbol">)</a> <a id="3052" class="Symbol">(</a><a id="3053" href="Foreign.Haskell.Coerce.html#3053" class="Bound">U</a> <a id="3055" class="Symbol">:</a> <a id="3057" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3061" href="Foreign.Haskell.Coerce.html#3028" class="Bound">c</a> <a id="3063" class="Symbol">→</a> <a id="3065" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3069" href="Foreign.Haskell.Coerce.html#1733" class="Generalizable">d</a><a id="3070" class="Symbol">)</a> <a id="3072" class="Symbol">→</a> <a id="3074" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3078" class="Symbol">_</a>
<a id="3080" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="3091" class="Symbol">_</a> <a id="3093" class="Symbol">_</a> <a id="3095" href="Foreign.Haskell.Coerce.html#3095" class="Bound">T</a> <a id="3097" href="Foreign.Haskell.Coerce.html#3097" class="Bound">U</a> <a id="3099" class="Symbol">=</a> <a id="3101" class="Symbol">∀</a> <a id="3103" class="Symbol">{</a><a id="3104" href="Foreign.Haskell.Coerce.html#3104" class="Bound">A</a> <a id="3106" href="Foreign.Haskell.Coerce.html#3106" class="Bound">B</a><a id="3107" class="Symbol">}</a> <a id="3109" class="Symbol">→</a> <a id="3111" class="Symbol">{{</a><a id="3113" href="Foreign.Haskell.Coerce.html#3113" class="Bound">_</a> <a id="3115" class="Symbol">:</a> <a id="3117" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="3127" href="Foreign.Haskell.Coerce.html#3104" class="Bound">A</a> <a id="3129" href="Foreign.Haskell.Coerce.html#3106" class="Bound">B</a><a id="3130" class="Symbol">}}</a> <a id="3133" class="Symbol">→</a> <a id="3135" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="3145" class="Symbol">(</a><a id="3146" href="Foreign.Haskell.Coerce.html#3095" class="Bound">T</a> <a id="3148" href="Foreign.Haskell.Coerce.html#3104" class="Bound">A</a><a id="3149" class="Symbol">)</a> <a id="3151" class="Symbol">(</a><a id="3152" href="Foreign.Haskell.Coerce.html#3097" class="Bound">U</a> <a id="3154" href="Foreign.Haskell.Coerce.html#3106" class="Bound">B</a><a id="3155" class="Symbol">)</a>

<a id="Coercible₂"></a><a id="3158" href="Foreign.Haskell.Coerce.html#3158" class="Function">Coercible₂</a> <a id="3169" class="Symbol">:</a> <a id="3171" class="Symbol">∀</a> <a id="3173" href="Foreign.Haskell.Coerce.html#3173" class="Bound">a</a> <a id="3175" href="Foreign.Haskell.Coerce.html#3175" class="Bound">b</a> <a id="3177" href="Foreign.Haskell.Coerce.html#3177" class="Bound">d</a> <a id="3179" href="Foreign.Haskell.Coerce.html#3179" class="Bound">e</a> <a id="3181" class="Symbol">→</a> <a id="3183" class="Symbol">(</a><a id="3184" href="Foreign.Haskell.Coerce.html#3184" class="Bound">T</a> <a id="3186" class="Symbol">:</a> <a id="3188" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3192" href="Foreign.Haskell.Coerce.html#3173" class="Bound">a</a> <a id="3194" class="Symbol">→</a> <a id="3196" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3200" href="Foreign.Haskell.Coerce.html#3175" class="Bound">b</a> <a id="3202" class="Symbol">→</a> <a id="3204" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3208" href="Foreign.Haskell.Coerce.html#1731" class="Generalizable">c</a><a id="3209" class="Symbol">)</a> <a id="3211" class="Symbol">(</a><a id="3212" href="Foreign.Haskell.Coerce.html#3212" class="Bound">U</a> <a id="3214" class="Symbol">:</a> <a id="3216" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3220" href="Foreign.Haskell.Coerce.html#3177" class="Bound">d</a> <a id="3222" class="Symbol">→</a> <a id="3224" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3228" href="Foreign.Haskell.Coerce.html#3179" class="Bound">e</a> <a id="3230" class="Symbol">→</a> <a id="3232" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3236" href="Foreign.Haskell.Coerce.html#1737" class="Generalizable">f</a><a id="3237" class="Symbol">)</a> <a id="3239" class="Symbol">→</a> <a id="3241" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="3245" class="Symbol">_</a>
<a id="3247" href="Foreign.Haskell.Coerce.html#3158" class="Function">Coercible₂</a> <a id="3258" class="Symbol">_</a> <a id="3260" class="Symbol">_</a> <a id="3262" class="Symbol">_</a> <a id="3264" class="Symbol">_</a> <a id="3266" href="Foreign.Haskell.Coerce.html#3266" class="Bound">T</a> <a id="3268" href="Foreign.Haskell.Coerce.html#3268" class="Bound">U</a> <a id="3270" class="Symbol">=</a> <a id="3272" class="Symbol">∀</a> <a id="3274" class="Symbol">{</a><a id="3275" href="Foreign.Haskell.Coerce.html#3275" class="Bound">A</a> <a id="3277" href="Foreign.Haskell.Coerce.html#3277" class="Bound">B</a><a id="3278" class="Symbol">}</a> <a id="3280" class="Symbol">→</a> <a id="3282" class="Symbol">{{</a><a id="3284" href="Foreign.Haskell.Coerce.html#3284" class="Bound">_</a> <a id="3286" class="Symbol">:</a> <a id="3288" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="3298" href="Foreign.Haskell.Coerce.html#3275" class="Bound">A</a> <a id="3300" href="Foreign.Haskell.Coerce.html#3277" class="Bound">B</a><a id="3301" class="Symbol">}}</a> <a id="3304" class="Symbol">→</a> <a id="3306" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="3317" class="Symbol">_</a> <a id="3319" class="Symbol">_</a> <a id="3321" class="Symbol">(</a><a id="3322" href="Foreign.Haskell.Coerce.html#3266" class="Bound">T</a> <a id="3324" href="Foreign.Haskell.Coerce.html#3275" class="Bound">A</a><a id="3325" class="Symbol">)</a> <a id="3327" class="Symbol">(</a><a id="3328" href="Foreign.Haskell.Coerce.html#3268" class="Bound">U</a> <a id="3330" href="Foreign.Haskell.Coerce.html#3277" class="Bound">B</a><a id="3331" class="Symbol">)</a>

<a id="3334" class="Comment">------------------------------------------------------------------------</a>
<a id="3407" class="Comment">-- Instances</a>

<a id="3421" class="Comment">-- Nat</a>

<a id="3429" class="Comment">-- Our first instance reveals one of Agda&#39;s secrets: natural numbers are</a>
<a id="3502" class="Comment">-- represented by (arbitrary precision) integers at runtime! Note that we</a>
<a id="3576" class="Comment">-- may only coerce in one direction: arbitrary integers may actually be</a>
<a id="3648" class="Comment">-- negative and will not do as mere natural numbers.</a>

<a id="3702" class="Keyword">instance</a>

  <a id="nat-toInt"></a><a id="3714" href="Foreign.Haskell.Coerce.html#3714" class="Function">nat-toInt</a> <a id="3724" class="Symbol">:</a> <a id="3726" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="3736" href="Agda.Builtin.Nat.html#186" class="Datatype">Nat</a> <a id="3740" href="Agda.Builtin.Int.html#228" class="Datatype">Int</a>
  <a id="3746" href="Foreign.Haskell.Coerce.html#3714" class="Function">nat-toInt</a> <a id="3756" class="Symbol">=</a> <a id="3758" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

<a id="3767" class="Comment">-- We then proceed to state that data types from the standard library</a>
<a id="3837" class="Comment">-- can be converted to their FFI equivalents which are bound to actual</a>
<a id="3908" class="Comment">-- Haskell types.</a>

<a id="3927" class="Comment">-- Product</a>

  <a id="pair-toFFI"></a><a id="3941" href="Foreign.Haskell.Coerce.html#3941" class="Function">pair-toFFI</a> <a id="3952" class="Symbol">:</a> <a id="3954" href="Foreign.Haskell.Coerce.html#3158" class="Function">Coercible₂</a> <a id="3965" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="3967" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="3969" href="Foreign.Haskell.Coerce.html#1731" class="Generalizable">c</a> <a id="3971" href="Foreign.Haskell.Coerce.html#1733" class="Generalizable">d</a> <a id="3973" href="Data.Product.html#1176" class="Function Operator">STD._×_</a> <a id="3981" href="Foreign.Haskell.Pair.html#529" class="Record">FFI.Pair</a>
  <a id="3992" href="Foreign.Haskell.Coerce.html#3941" class="Function">pair-toFFI</a> <a id="4003" class="Symbol">=</a> <a id="4005" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

  <a id="pair-fromFFI"></a><a id="4016" href="Foreign.Haskell.Coerce.html#4016" class="Function">pair-fromFFI</a> <a id="4029" class="Symbol">:</a> <a id="4031" href="Foreign.Haskell.Coerce.html#3158" class="Function">Coercible₂</a> <a id="4042" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="4044" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="4046" href="Foreign.Haskell.Coerce.html#1731" class="Generalizable">c</a> <a id="4048" href="Foreign.Haskell.Coerce.html#1733" class="Generalizable">d</a> <a id="4050" href="Foreign.Haskell.Pair.html#529" class="Record">FFI.Pair</a> <a id="4059" href="Data.Product.html#1176" class="Function Operator">STD._×_</a>
  <a id="4069" href="Foreign.Haskell.Coerce.html#4016" class="Function">pair-fromFFI</a> <a id="4082" class="Symbol">=</a> <a id="4084" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

<a id="4093" class="Comment">-- Sum</a>

  <a id="either-toFFI"></a><a id="4103" href="Foreign.Haskell.Coerce.html#4103" class="Function">either-toFFI</a> <a id="4116" class="Symbol">:</a> <a id="4118" href="Foreign.Haskell.Coerce.html#3158" class="Function">Coercible₂</a> <a id="4129" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="4131" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="4133" href="Foreign.Haskell.Coerce.html#1731" class="Generalizable">c</a> <a id="4135" href="Foreign.Haskell.Coerce.html#1733" class="Generalizable">d</a> <a id="4137" href="Data.Sum.Base.html#743" class="Datatype Operator">STD._⊎_</a> <a id="4145" href="Foreign.Haskell.Either.html#539" class="Datatype">FFI.Either</a>
  <a id="4158" href="Foreign.Haskell.Coerce.html#4103" class="Function">either-toFFI</a> <a id="4171" class="Symbol">=</a> <a id="4173" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

  <a id="either-fromFFI"></a><a id="4184" href="Foreign.Haskell.Coerce.html#4184" class="Function">either-fromFFI</a> <a id="4199" class="Symbol">:</a> <a id="4201" href="Foreign.Haskell.Coerce.html#3158" class="Function">Coercible₂</a> <a id="4212" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="4214" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="4216" href="Foreign.Haskell.Coerce.html#1731" class="Generalizable">c</a> <a id="4218" href="Foreign.Haskell.Coerce.html#1733" class="Generalizable">d</a> <a id="4220" href="Foreign.Haskell.Either.html#539" class="Datatype">FFI.Either</a> <a id="4231" href="Data.Sum.Base.html#743" class="Datatype Operator">STD._⊎_</a>
  <a id="4241" href="Foreign.Haskell.Coerce.html#4184" class="Function">either-fromFFI</a> <a id="4256" class="Symbol">=</a> <a id="4258" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

<a id="4267" class="Comment">-- NonEmpty</a>

  <a id="nonEmpty-toFFI"></a><a id="4282" href="Foreign.Haskell.Coerce.html#4282" class="Function">nonEmpty-toFFI</a> <a id="4297" class="Symbol">:</a> <a id="4299" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="4310" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="4312" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="4314" href="Data.List.NonEmpty.Base.html#1266" class="Record">STD.List⁺</a> <a id="4324" href="Foreign.Haskell.List.NonEmpty.html#636" class="Datatype">FFI.NonEmpty</a>
  <a id="4339" href="Foreign.Haskell.Coerce.html#4282" class="Function">nonEmpty-toFFI</a> <a id="4354" class="Symbol">=</a> <a id="4356" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

  <a id="nonEmpty-fromFFI"></a><a id="4367" href="Foreign.Haskell.Coerce.html#4367" class="Function">nonEmpty-fromFFI</a> <a id="4384" class="Symbol">:</a> <a id="4386" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="4397" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="4399" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="4401" href="Foreign.Haskell.List.NonEmpty.html#636" class="Datatype">FFI.NonEmpty</a> <a id="4414" href="Data.List.NonEmpty.Base.html#1266" class="Record">STD.List⁺</a>
  <a id="4426" href="Foreign.Haskell.Coerce.html#4367" class="Function">nonEmpty-fromFFI</a> <a id="4443" class="Symbol">=</a> <a id="4445" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

<a id="4454" class="Comment">-- We follow up with purely structural rules for builtin data types which</a>
<a id="4528" class="Comment">-- already have known low-level representations.</a>

<a id="4578" class="Comment">-- Maybe</a>

  <a id="coerce-maybe"></a><a id="4590" href="Foreign.Haskell.Coerce.html#4590" class="Function">coerce-maybe</a> <a id="4603" class="Symbol">:</a> <a id="4605" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="4616" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="4618" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="4620" href="Agda.Builtin.Maybe.html#118" class="Datatype">STD.Maybe</a> <a id="4630" href="Agda.Builtin.Maybe.html#118" class="Datatype">STD.Maybe</a>
  <a id="4642" href="Foreign.Haskell.Coerce.html#4590" class="Function">coerce-maybe</a> <a id="4655" class="Symbol">=</a> <a id="4657" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

<a id="4666" class="Comment">-- List</a>

  <a id="coerce-list"></a><a id="4677" href="Foreign.Haskell.Coerce.html#4677" class="Function">coerce-list</a> <a id="4689" class="Symbol">:</a> <a id="4691" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="4702" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="4704" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="4706" href="Agda.Builtin.List.html#130" class="Datatype">STD.List</a> <a id="4715" href="Agda.Builtin.List.html#130" class="Datatype">STD.List</a>
  <a id="4726" href="Foreign.Haskell.Coerce.html#4677" class="Function">coerce-list</a> <a id="4738" class="Symbol">=</a> <a id="4740" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

<a id="4749" class="Comment">-- IO</a>

  <a id="coerce-IO"></a><a id="4758" href="Foreign.Haskell.Coerce.html#4758" class="Function">coerce-IO</a> <a id="4768" class="Symbol">:</a> <a id="4770" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="4781" href="Foreign.Haskell.Coerce.html#1727" class="Generalizable">a</a> <a id="4783" href="Foreign.Haskell.Coerce.html#1729" class="Generalizable">b</a> <a id="4785" href="Agda.Builtin.IO.html#120" class="Postulate">STD.IO</a> <a id="4792" href="Agda.Builtin.IO.html#120" class="Postulate">STD.IO</a>
  <a id="4801" href="Foreign.Haskell.Coerce.html#4758" class="Function">coerce-IO</a> <a id="4811" class="Symbol">=</a> <a id="4813" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

<a id="4822" class="Comment">-- Function</a>
<a id="4834" class="Comment">-- Note that functions are contravariant in their domain.</a>

  <a id="coerce-fun"></a><a id="4895" href="Foreign.Haskell.Coerce.html#4895" class="Function">coerce-fun</a> <a id="4906" class="Symbol">:</a> <a id="4908" class="Symbol">{{</a><a id="4910" href="Foreign.Haskell.Coerce.html#4910" class="Bound">_</a> <a id="4912" class="Symbol">:</a> <a id="4914" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="4924" href="Foreign.Haskell.Coerce.html#1751" class="Generalizable">A</a> <a id="4926" href="Foreign.Haskell.Coerce.html#1765" class="Generalizable">B</a><a id="4927" class="Symbol">}}</a> <a id="4930" class="Symbol">→</a> <a id="4932" href="Foreign.Haskell.Coerce.html#3011" class="Function">Coercible₁</a> <a id="4943" href="Foreign.Haskell.Coerce.html#1731" class="Generalizable">c</a> <a id="4945" href="Foreign.Haskell.Coerce.html#1733" class="Generalizable">d</a> <a id="4947" class="Symbol">(λ</a> <a id="4950" href="Foreign.Haskell.Coerce.html#4950" class="Bound">C</a> <a id="4952" class="Symbol">→</a> <a id="4954" href="Foreign.Haskell.Coerce.html#1765" class="Generalizable">B</a> <a id="4956" class="Symbol">→</a> <a id="4958" href="Foreign.Haskell.Coerce.html#4950" class="Bound">C</a><a id="4959" class="Symbol">)</a> <a id="4961" class="Symbol">(λ</a> <a id="4964" href="Foreign.Haskell.Coerce.html#4964" class="Bound">D</a> <a id="4966" class="Symbol">→</a> <a id="4968" href="Foreign.Haskell.Coerce.html#1751" class="Generalizable">A</a> <a id="4970" class="Symbol">→</a> <a id="4972" href="Foreign.Haskell.Coerce.html#4964" class="Bound">D</a><a id="4973" class="Symbol">)</a>
  <a id="4977" href="Foreign.Haskell.Coerce.html#4895" class="Function">coerce-fun</a> <a id="4988" class="Symbol">=</a> <a id="4990" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>

<a id="4999" class="Comment">-- Finally we add a reflexivity proof to discharge all the dangling constraints</a>
<a id="5079" class="Comment">-- involving type variables and concrete builtin types such as `Bool`.</a>

<a id="5151" class="Comment">-- This rule overlaps with the purely structural ones: when attempting to prove</a>
<a id="5231" class="Comment">-- `Coercible (List A) (List A)`, should Agda use the proof obtained by `coerce-refl`</a>
<a id="5317" class="Comment">-- or the one obtained by `coerce-list coerce-refl`? Because we are using a</a>
<a id="5393" class="Comment">-- datatype with a single constructor these distinctions do not matter: both proofs</a>
<a id="5477" class="Comment">-- are definitionally equal.</a>

  <a id="coerce-refl"></a><a id="5509" href="Foreign.Haskell.Coerce.html#5509" class="Function">coerce-refl</a> <a id="5521" class="Symbol">:</a> <a id="5523" href="Foreign.Haskell.Coerce.html#2357" class="Datatype">Coercible</a> <a id="5533" href="Foreign.Haskell.Coerce.html#1751" class="Generalizable">A</a> <a id="5535" href="Foreign.Haskell.Coerce.html#1751" class="Generalizable">A</a>
  <a id="5539" href="Foreign.Haskell.Coerce.html#5509" class="Function">coerce-refl</a> <a id="5551" class="Symbol">=</a> <a id="5553" href="Foreign.Haskell.Coerce.html#2405" class="InductiveConstructor">TrustMe</a>
</pre></body></html>