<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Nary</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the generic n-ary operations the stdlib provides</a>
<a id="179" class="Comment">-- can be used</a>
<a id="194" class="Comment">------------------------------------------------------------------------</a>

<a id="268" class="Symbol">{-#</a> <a id="272" class="Keyword">OPTIONS</a> <a id="280" class="Pragma">--cubical-compatible</a> <a id="301" class="Pragma">--safe</a> <a id="308" class="Symbol">#-}</a>

<a id="313" class="Keyword">module</a> <a id="320" href="README.Nary.html" class="Module">README.Nary</a> <a id="332" class="Keyword">where</a>

<a id="339" class="Keyword">open</a> <a id="344" class="Keyword">import</a> <a id="351" href="Level.html" class="Module">Level</a> <a id="357" class="Keyword">using</a> <a id="363" class="Symbol">(</a><a id="364" href="Agda.Primitive.html#591" class="Postulate">Level</a><a id="369" class="Symbol">)</a>
<a id="371" class="Keyword">open</a> <a id="376" class="Keyword">import</a> <a id="383" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="397" class="Keyword">open</a> <a id="402" class="Keyword">import</a> <a id="409" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="429" class="Keyword">open</a> <a id="434" class="Keyword">import</a> <a id="441" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="450" class="Keyword">using</a> <a id="456" class="Symbol">(</a><a id="457" href="Data.Fin.Base.html#1212" class="Datatype">Fin</a><a id="460" class="Symbol">;</a> <a id="462" href="Data.Fin.Base.html#1905" class="Function">fromℕ</a><a id="467" class="Symbol">;</a> <a id="469" href="Data.Fin.html#739" class="Function Operator">#_</a><a id="471" class="Symbol">;</a> <a id="473" href="Data.Fin.Base.html#3176" class="Function">inject₁</a><a id="480" class="Symbol">)</a>
<a id="482" class="Keyword">open</a> <a id="487" class="Keyword">import</a> <a id="494" href="Data.List.html" class="Module">Data.List</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>
<a id="537" class="Keyword">open</a> <a id="542" class="Keyword">import</a> <a id="549" href="Data.Product.html" class="Module">Data.Product</a> <a id="562" class="Keyword">using</a> <a id="568" class="Symbol">(</a><a id="569" href="Data.Product.html#1176" class="Function Operator">_×_</a><a id="572" class="Symbol">;</a> <a id="574" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="577" class="Symbol">)</a>
<a id="579" class="Keyword">open</a> <a id="584" class="Keyword">import</a> <a id="591" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="600" class="Keyword">using</a> <a id="606" class="Symbol">(</a><a id="607" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a><a id="611" class="Symbol">;</a> <a id="613" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a><a id="617" class="Symbol">)</a>
<a id="619" class="Keyword">open</a> <a id="624" class="Keyword">import</a> <a id="631" href="Function.html" class="Module">Function</a>
<a id="640" class="Keyword">open</a> <a id="645" class="Keyword">import</a> <a id="652" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="669" class="Keyword">open</a> <a id="674" class="Keyword">import</a> <a id="681" href="Relation.Binary.html" class="Module">Relation.Binary</a> <a id="697" class="Keyword">using</a> <a id="703" class="Symbol">(</a><a id="704" class="Keyword">module</a> <a id="711" href="Relation.Binary.Definitions.html#2721" class="Module">Tri</a><a id="714" class="Symbol">);</a> <a id="717" class="Keyword">open</a> <a id="722" href="Relation.Binary.Definitions.html#2721" class="Module">Tri</a>
<a id="726" class="Keyword">open</a> <a id="731" class="Keyword">import</a> <a id="738" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="777" class="Keyword">private</a>
  <a id="787" class="Keyword">variable</a>
    <a id="800" href="README.Nary.html#800" class="Generalizable">a</a> <a id="802" href="README.Nary.html#802" class="Generalizable">b</a> <a id="804" href="README.Nary.html#804" class="Generalizable">c</a> <a id="806" href="README.Nary.html#806" class="Generalizable">d</a> <a id="808" href="README.Nary.html#808" class="Generalizable">e</a> <a id="810" class="Symbol">:</a> <a id="812" href="Agda.Primitive.html#591" class="Postulate">Level</a>
    <a id="822" href="README.Nary.html#822" class="Generalizable">A</a> <a id="824" class="Symbol">:</a> <a id="826" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="830" href="README.Nary.html#800" class="Generalizable">a</a>
    <a id="836" href="README.Nary.html#836" class="Generalizable">B</a> <a id="838" class="Symbol">:</a> <a id="840" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="844" href="README.Nary.html#802" class="Generalizable">b</a>
    <a id="850" href="README.Nary.html#850" class="Generalizable">C</a> <a id="852" class="Symbol">:</a> <a id="854" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="858" href="README.Nary.html#804" class="Generalizable">c</a>
    <a id="864" href="README.Nary.html#864" class="Generalizable">D</a> <a id="866" class="Symbol">:</a> <a id="868" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="872" href="README.Nary.html#806" class="Generalizable">d</a>
    <a id="878" href="README.Nary.html#878" class="Generalizable">E</a> <a id="880" class="Symbol">:</a> <a id="882" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="886" href="README.Nary.html#808" class="Generalizable">e</a>

<a id="889" class="Comment">------------------------------------------------------------------------</a>
<a id="962" class="Comment">-- Introduction</a>
<a id="978" class="Comment">------------------------------------------------------------------------</a>

<a id="1052" class="Comment">-- Function.Nary.NonDependent and Data.Product.N-ary.Heterogeneous provide</a>
<a id="1127" class="Comment">-- a generic representation of n-ary heterogeneous (non dependent) products</a>
<a id="1203" class="Comment">-- and the corresponding types of (non-dependent) n-ary functions. The</a>
<a id="1274" class="Comment">-- representation works well with inference thus allowing us to use generic</a>
<a id="1350" class="Comment">-- combinators to manipulate such functions.</a>

<a id="1396" class="Keyword">open</a> <a id="1401" class="Keyword">import</a> <a id="1408" href="Data.Product.Nary.NonDependent.html" class="Module">Data.Product.Nary.NonDependent</a>
<a id="1439" class="Keyword">open</a> <a id="1444" class="Keyword">import</a> <a id="1451" href="Function.Nary.NonDependent.html" class="Module">Function.Nary.NonDependent</a>
<a id="1478" class="Keyword">open</a> <a id="1483" class="Keyword">import</a> <a id="1490" href="Relation.Nary.html" class="Module">Relation.Nary</a>


<a id="1506" class="Comment">------------------------------------------------------------------------</a>
<a id="1579" class="Comment">-- Generalised equality-manipulating combinators</a>
<a id="1628" class="Comment">------------------------------------------------------------------------</a>

<a id="1702" class="Comment">-- By default the standard library provides users with (we are leaving out</a>
<a id="1777" class="Comment">-- the implicit arguments here):</a>
<a id="1810" class="Comment">--</a>
<a id="1813" class="Comment">-- cong   : (f : A₁      → B) → a₁ ≡ b₁           → f a₁   ≡ f b₁</a>
<a id="1879" class="Comment">-- cong₂  : (f : A₁ → A₂ → B) → a₁ ≡ b₁ → a₂ ≡ b₂ → f a₁ a₂ ≡ f b₁ b₂</a>
<a id="1949" class="Comment">--</a>
<a id="1952" class="Comment">-- and</a>
<a id="1959" class="Comment">--</a>
<a id="1962" class="Comment">-- subst  : (P : A₁      → Set p) → a₁ ≡ b₁           → P a₁    → P b₁</a>
<a id="2033" class="Comment">-- subst₂ : (P : A₁ → A₂ → Set p) → a₁ ≡ b₁ → a₂ ≡ b₂ → P a₁ a₂ → P b₁ b₂</a>
<a id="2107" class="Comment">--</a>
<a id="2110" class="Comment">-- This pattern can be generalised to any natural number `n`. Thanks to our</a>
<a id="2186" class="Comment">-- library for n-ary functions, we can write the types and implementations</a>
<a id="2261" class="Comment">-- of `congₙ` and `substₙ`.</a>

<a id="2290" class="Comment">------------------------------------------------------------------------</a>
<a id="2363" class="Comment">-- congₙ : ∀ n (f : A₁ → ⋯ → Aₙ → B) →</a>
<a id="2402" class="Comment">--         a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → f a₁ ⋯ aₙ ≡ f b₁ ⋯ bₙ</a>

<a id="2458" class="Comment">-- It may be used directly to prove something:</a>

<a id="2506" href="README.Nary.html#2506" class="Function">_</a> <a id="2508" class="Symbol">:</a> <a id="2510" class="Symbol">∀</a> <a id="2512" class="Symbol">(</a><a id="2513" href="README.Nary.html#2513" class="Bound">as</a> <a id="2516" href="README.Nary.html#2516" class="Bound">bs</a> <a id="2519" href="README.Nary.html#2519" class="Bound">cs</a> <a id="2522" class="Symbol">:</a> <a id="2524" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="2529" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2530" class="Symbol">)</a> <a id="2532" class="Symbol">→</a>
       <a id="2541" href="Data.List.Base.html#3594" class="Function">zip</a> <a id="2545" class="Symbol">(</a><a id="2546" href="Data.List.Base.html#3594" class="Function">zip</a> <a id="2550" class="Symbol">(</a><a id="2551" href="README.Nary.html#2513" class="Bound">as</a> <a id="2554" href="Data.List.Base.html#1834" class="Function Operator">++</a> <a id="2557" class="InductiveConstructor">[]</a><a id="2559" class="Symbol">)</a> <a id="2561" class="Symbol">(</a><a id="2562" href="Data.List.Base.html#1572" class="Function">map</a> <a id="2566" href="Function.Base.html#704" class="Function">id</a> <a id="2569" href="README.Nary.html#2519" class="Bound">cs</a><a id="2571" class="Symbol">))</a> <a id="2574" class="Symbol">(</a><a id="2575" href="Data.List.Base.html#6817" class="Function">reverse</a> <a id="2583" class="Symbol">(</a><a id="2584" href="Data.List.Base.html#6817" class="Function">reverse</a> <a id="2592" href="README.Nary.html#2516" class="Bound">bs</a><a id="2594" class="Symbol">))</a>
     <a id="2602" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2604" href="Data.List.Base.html#3594" class="Function">zip</a> <a id="2608" class="Symbol">(</a><a id="2609" href="Data.List.Base.html#3594" class="Function">zip</a> <a id="2613" href="README.Nary.html#2513" class="Bound">as</a> <a id="2616" href="README.Nary.html#2519" class="Bound">cs</a><a id="2618" class="Symbol">)</a> <a id="2620" href="README.Nary.html#2516" class="Bound">bs</a>
<a id="2623" class="Symbol">_</a> <a id="2625" class="Symbol">=</a> <a id="2627" class="Symbol">λ</a> <a id="2629" href="README.Nary.html#2629" class="Bound">as</a> <a id="2632" href="README.Nary.html#2632" class="Bound">bs</a> <a id="2635" href="README.Nary.html#2635" class="Bound">cs</a> <a id="2638" class="Symbol">→</a> <a id="2640" href="Function.Nary.NonDependent.html#2024" class="Function">congₙ</a> <a id="2646" class="Number">3</a> <a id="2648" class="Symbol">(λ</a> <a id="2651" href="README.Nary.html#2651" class="Bound">as</a> <a id="2654" href="README.Nary.html#2654" class="Bound">bs</a> <a id="2657" class="Symbol">→</a> <a id="2659" href="Data.List.Base.html#3594" class="Function">zip</a> <a id="2663" class="Symbol">(</a><a id="2664" href="Data.List.Base.html#3594" class="Function">zip</a> <a id="2668" href="README.Nary.html#2651" class="Bound">as</a> <a id="2671" href="README.Nary.html#2654" class="Bound">bs</a><a id="2673" class="Symbol">))</a>
                         <a id="2701" class="Symbol">(</a><a id="2702" href="Data.List.Properties.html#5699" class="Function">++-identityʳ</a> <a id="2715" href="README.Nary.html#2629" class="Bound">as</a><a id="2717" class="Symbol">)</a>
                         <a id="2744" class="Symbol">(</a><a id="2745" href="Data.List.Properties.html#2936" class="Function">map-id</a> <a id="2752" href="README.Nary.html#2635" class="Bound">cs</a><a id="2754" class="Symbol">)</a>
                         <a id="2781" class="Symbol">(</a><a id="2782" href="Data.List.Properties.html#35111" class="Function">reverse-involutive</a> <a id="2801" href="README.Nary.html#2632" class="Bound">bs</a><a id="2803" class="Symbol">)</a>

<a id="2806" class="Comment">-- Or as part of a longer derivation:</a>

<a id="2845" href="README.Nary.html#2845" class="Function">_</a> <a id="2847" class="Symbol">:</a> <a id="2849" class="Symbol">∀</a> <a id="2851" href="README.Nary.html#2851" class="Bound">m</a> <a id="2853" href="README.Nary.html#2853" class="Bound">n</a> <a id="2855" href="README.Nary.html#2855" class="Bound">p</a> <a id="2857" href="README.Nary.html#2857" class="Bound">q</a> <a id="2859" class="Symbol">→</a> <a id="2861" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2865" class="Symbol">(</a><a id="2866" href="README.Nary.html#2851" class="Bound">m</a> <a id="2868" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2870" class="Symbol">(</a><a id="2871" href="README.Nary.html#2855" class="Bound">p</a> <a id="2873" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2875" href="README.Nary.html#2853" class="Bound">n</a><a id="2876" class="Symbol">)</a> <a id="2878" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2880" class="Symbol">(</a><a id="2881" href="README.Nary.html#2857" class="Bound">q</a> <a id="2883" href="Data.Nat.Base.html#3820" class="Function Operator">^</a> <a id="2885" class="Symbol">(</a><a id="2886" href="README.Nary.html#2851" class="Bound">m</a> <a id="2888" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2890" href="README.Nary.html#2853" class="Bound">n</a><a id="2891" class="Symbol">)))</a>
              <a id="2909" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2911" class="Symbol">(</a><a id="2912" href="README.Nary.html#2851" class="Bound">m</a> <a id="2914" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2916" class="Number">0</a><a id="2917" class="Symbol">)</a> <a id="2919" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2921" class="Symbol">(</a><a id="2922" href="README.Nary.html#2853" class="Bound">n</a> <a id="2924" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2926" href="README.Nary.html#2855" class="Bound">p</a><a id="2927" class="Symbol">)</a> <a id="2929" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2931" class="Symbol">(</a><a id="2932" href="README.Nary.html#2857" class="Bound">q</a> <a id="2934" href="Data.Nat.Base.html#3820" class="Function Operator">^</a> <a id="2936" href="README.Nary.html#2851" class="Bound">m</a> <a id="2938" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2940" href="README.Nary.html#2857" class="Bound">q</a> <a id="2942" href="Data.Nat.Base.html#3820" class="Function Operator">^</a> <a id="2944" href="README.Nary.html#2853" class="Bound">n</a><a id="2945" class="Symbol">)</a> <a id="2947" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2949" class="Number">1</a>
<a id="2951" class="Symbol">_</a> <a id="2953" class="Symbol">=</a> <a id="2955" class="Symbol">λ</a> <a id="2957" href="README.Nary.html#2957" class="Bound">m</a> <a id="2959" href="README.Nary.html#2959" class="Bound">n</a> <a id="2961" href="README.Nary.html#2961" class="Bound">p</a> <a id="2963" href="README.Nary.html#2963" class="Bound">q</a> <a id="2965" class="Symbol">→</a> <a id="2967" href="Relation.Binary.PropositionalEquality.Core.html#2815" class="Function Operator">begin</a>
    <a id="2977" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2981" class="Symbol">(</a><a id="2982" href="README.Nary.html#2957" class="Bound">m</a> <a id="2984" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2986" class="Symbol">(</a><a id="2987" href="README.Nary.html#2961" class="Bound">p</a> <a id="2989" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="2991" href="README.Nary.html#2959" class="Bound">n</a><a id="2992" class="Symbol">)</a> <a id="2994" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2996" class="Symbol">(</a><a id="2997" href="README.Nary.html#2963" class="Bound">q</a> <a id="2999" href="Data.Nat.Base.html#3820" class="Function Operator">^</a> <a id="3001" class="Symbol">(</a><a id="3002" href="README.Nary.html#2957" class="Bound">m</a> <a id="3004" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3006" href="README.Nary.html#2959" class="Bound">n</a><a id="3007" class="Symbol">)))</a> <a id="3011" href="Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="3014" href="Data.Nat.Properties.html#14756" class="Function">+-comm</a> <a id="3021" class="Number">1</a> <a id="3023" class="Symbol">_</a> <a id="3025" href="Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="3031" href="README.Nary.html#2957" class="Bound">m</a> <a id="3033" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3035" class="Symbol">(</a><a id="3036" href="README.Nary.html#2961" class="Bound">p</a> <a id="3038" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3040" href="README.Nary.html#2959" class="Bound">n</a><a id="3041" class="Symbol">)</a> <a id="3043" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3045" class="Symbol">(</a><a id="3046" href="README.Nary.html#2963" class="Bound">q</a> <a id="3048" href="Data.Nat.Base.html#3820" class="Function Operator">^</a> <a id="3050" class="Symbol">(</a><a id="3051" href="README.Nary.html#2957" class="Bound">m</a> <a id="3053" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3055" href="README.Nary.html#2959" class="Bound">n</a><a id="3056" class="Symbol">))</a> <a id="3059" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3061" class="Number">1</a>   <a id="3065" href="Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">≡⟨</a> <a id="3068" href="Function.Nary.NonDependent.html#2024" class="Function">congₙ</a> <a id="3074" class="Number">3</a> <a id="3076" class="Symbol">(λ</a> <a id="3079" href="README.Nary.html#3079" class="Bound">m</a> <a id="3081" href="README.Nary.html#3081" class="Bound">n</a> <a id="3083" href="README.Nary.html#3083" class="Bound">p</a> <a id="3085" class="Symbol">→</a> <a id="3087" href="README.Nary.html#3079" class="Bound">m</a> <a id="3089" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3091" href="README.Nary.html#3081" class="Bound">n</a> <a id="3093" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3095" href="README.Nary.html#3083" class="Bound">p</a> <a id="3097" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3099" class="Number">1</a><a id="3100" class="Symbol">)</a>
                                                 <a id="3151" class="Symbol">(</a><a id="3152" href="Data.Nat.Properties.html#14756" class="Function">+-comm</a> <a id="3159" class="Number">0</a> <a id="3161" href="README.Nary.html#2957" class="Bound">m</a><a id="3162" class="Symbol">)</a>
                                                 <a id="3213" class="Symbol">(</a><a id="3214" href="Data.Nat.Properties.html#21563" class="Function">*-comm</a> <a id="3221" href="README.Nary.html#2961" class="Bound">p</a> <a id="3223" href="README.Nary.html#2959" class="Bound">n</a><a id="3224" class="Symbol">)</a>
                                                 <a id="3275" class="Symbol">(</a><a id="3276" href="Data.Nat.Properties.html#29256" class="Function">^-distribˡ-+-*</a> <a id="3291" href="README.Nary.html#2963" class="Bound">q</a> <a id="3293" href="README.Nary.html#2957" class="Bound">m</a> <a id="3295" href="README.Nary.html#2959" class="Bound">n</a><a id="3296" class="Symbol">)</a>
                                       <a id="3337" href="Relation.Binary.PropositionalEquality.Core.html#2932" class="Function">⟩</a>
    <a id="3343" href="README.Nary.html#2957" class="Bound">m</a> <a id="3345" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3347" class="Number">0</a> <a id="3349" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3351" href="README.Nary.html#2959" class="Bound">n</a> <a id="3353" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3355" href="README.Nary.html#2961" class="Bound">p</a> <a id="3357" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3359" class="Symbol">(</a><a id="3360" href="README.Nary.html#2963" class="Bound">q</a> <a id="3362" href="Data.Nat.Base.html#3820" class="Function Operator">^</a> <a id="3364" href="README.Nary.html#2957" class="Bound">m</a><a id="3365" class="Symbol">)</a> <a id="3367" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="3369" class="Symbol">(</a><a id="3370" href="README.Nary.html#2963" class="Bound">q</a> <a id="3372" href="Data.Nat.Base.html#3820" class="Function Operator">^</a> <a id="3374" href="README.Nary.html#2959" class="Bound">n</a><a id="3375" class="Symbol">)</a> <a id="3377" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3379" class="Number">1</a> <a id="3381" href="Relation.Binary.PropositionalEquality.Core.html#3114" class="Function Operator">∎</a> <a id="3383" class="Keyword">where</a> <a id="3389" class="Keyword">open</a> <a id="3394" href="Relation.Binary.PropositionalEquality.Core.html#2717" class="Module">≡-Reasoning</a>

<a id="3407" class="Comment">-- Partial application of the functional argument is fine: the number of arguments</a>
<a id="3490" class="Comment">-- `congₙ` is going to take is determined by its first argument (a natural number)</a>
<a id="3573" class="Comment">-- and not by the type of the function it works on.</a>

<a id="3626" href="README.Nary.html#3626" class="Function">_</a> <a id="3628" class="Symbol">:</a> <a id="3630" class="Symbol">∀</a> <a id="3632" href="README.Nary.html#3632" class="Bound">m</a> <a id="3634" class="Symbol">→</a> <a id="3636" class="Symbol">(</a><a id="3637" href="README.Nary.html#3632" class="Bound">m</a> <a id="3639" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+_</a><a id="3641" class="Symbol">)</a> <a id="3643" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="3645" class="Symbol">((</a><a id="3647" href="README.Nary.html#3632" class="Bound">m</a> <a id="3649" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="3651" class="Number">0</a><a id="3652" class="Symbol">)</a> <a id="3654" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+_</a><a id="3656" class="Symbol">)</a>
<a id="3658" class="Symbol">_</a> <a id="3660" class="Symbol">=</a> <a id="3662" class="Symbol">λ</a> <a id="3664" href="README.Nary.html#3664" class="Bound">m</a> <a id="3666" class="Symbol">→</a> <a id="3668" href="Function.Nary.NonDependent.html#2024" class="Function">congₙ</a> <a id="3674" class="Number">1</a> <a id="3676" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a> <a id="3680" class="Symbol">(</a><a id="3681" href="Data.Nat.Properties.html#14756" class="Function">+-comm</a> <a id="3688" class="Number">0</a> <a id="3690" href="README.Nary.html#3664" class="Bound">m</a><a id="3691" class="Symbol">)</a>

<a id="3694" class="Comment">-- We don&#39;t have to work on the function&#39;s first argument either: we can just as</a>
<a id="3775" class="Comment">-- easily use `congₙ` to act on the second one by `flip`ping it. See `holeₙ` for</a>
<a id="3856" class="Comment">-- a generalisation of this idea allowing to target *any* of the function&#39;s</a>
<a id="3932" class="Comment">-- arguments and not just the first or second one.</a>

<a id="3984" href="README.Nary.html#3984" class="Function">_</a> <a id="3986" class="Symbol">:</a> <a id="3988" class="Symbol">∀</a> <a id="3990" href="README.Nary.html#3990" class="Bound">m</a> <a id="3992" class="Symbol">→</a> <a id="3994" class="Symbol">(</a><a id="3995" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="3998" href="README.Nary.html#3990" class="Bound">m</a><a id="3999" class="Symbol">)</a> <a id="4001" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4003" class="Symbol">(</a><a id="4004" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+</a> <a id="4007" class="Symbol">(</a><a id="4008" href="README.Nary.html#3990" class="Bound">m</a> <a id="4010" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4012" class="Number">0</a><a id="4013" class="Symbol">))</a>
<a id="4016" class="Symbol">_</a> <a id="4018" class="Symbol">=</a> <a id="4020" class="Symbol">λ</a> <a id="4022" href="README.Nary.html#4022" class="Bound">m</a> <a id="4024" class="Symbol">→</a> <a id="4026" href="Function.Nary.NonDependent.html#2024" class="Function">congₙ</a> <a id="4032" class="Number">1</a> <a id="4034" class="Symbol">(</a><a id="4035" href="Function.Base.html#1638" class="Function">flip</a> <a id="4040" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">_+_</a><a id="4043" class="Symbol">)</a> <a id="4045" class="Symbol">(</a><a id="4046" href="Data.Nat.Properties.html#14756" class="Function">+-comm</a> <a id="4053" class="Number">0</a> <a id="4055" href="README.Nary.html#4022" class="Bound">m</a><a id="4056" class="Symbol">)</a>

<a id="4059" class="Comment">------------------------------------------------------------------------</a>
<a id="4132" class="Comment">-- substₙ : (P : A₁ → ⋯ → Aₙ → Set p) →</a>
<a id="4172" class="Comment">--          a₁ ≡ b₁ → ⋯ aₙ ≡ bₙ → P a₁ ⋯ aₙ → P b₁ ⋯ bₙ</a>

<a id="4229" class="Comment">-- We can play the same type of game with subst</a>

<a id="4278" class="Keyword">open</a> <a id="4283" class="Keyword">import</a> <a id="4290" href="Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a> <a id="4307" class="Keyword">using</a> <a id="4313" class="Symbol">(</a><a id="4314" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a><a id="4324" class="Symbol">)</a>

<a id="4327" class="Comment">-- Because we know from the definition `mod-helper` that this equation holds:</a>
<a id="4405" class="Comment">-- mod-helper k m (suc n) (suc j) = mod-helper (suc k) m n j</a>
<a id="4466" class="Comment">-- we should be able to prove the slightly modified statement by transforming</a>
<a id="4544" class="Comment">-- all the `x + 1` into `suc x`. We can do so using `substₙ`.</a>

<a id="4607" href="README.Nary.html#4607" class="Function">_</a> <a id="4609" class="Symbol">:</a> <a id="4611" class="Symbol">∀</a> <a id="4613" href="README.Nary.html#4613" class="Bound">k</a> <a id="4615" href="README.Nary.html#4615" class="Bound">m</a> <a id="4617" href="README.Nary.html#4617" class="Bound">n</a> <a id="4619" href="README.Nary.html#4619" class="Bound">j</a> <a id="4621" class="Symbol">→</a> <a id="4623" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4634" href="README.Nary.html#4613" class="Bound">k</a> <a id="4636" href="README.Nary.html#4615" class="Bound">m</a> <a id="4638" class="Symbol">(</a><a id="4639" href="README.Nary.html#4617" class="Bound">n</a> <a id="4641" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4643" class="Number">1</a><a id="4644" class="Symbol">)</a> <a id="4646" class="Symbol">(</a><a id="4647" href="README.Nary.html#4619" class="Bound">j</a> <a id="4649" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4651" class="Number">1</a><a id="4652" class="Symbol">)</a> <a id="4654" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4656" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4667" class="Symbol">(</a><a id="4668" href="README.Nary.html#4613" class="Bound">k</a> <a id="4670" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4672" class="Number">1</a><a id="4673" class="Symbol">)</a> <a id="4675" href="README.Nary.html#4615" class="Bound">m</a> <a id="4677" href="README.Nary.html#4617" class="Bound">n</a> <a id="4679" href="README.Nary.html#4619" class="Bound">j</a>
<a id="4681" class="Symbol">_</a> <a id="4683" class="Symbol">=</a> <a id="4685" class="Symbol">λ</a> <a id="4687" href="README.Nary.html#4687" class="Bound">k</a> <a id="4689" href="README.Nary.html#4689" class="Bound">m</a> <a id="4691" href="README.Nary.html#4691" class="Bound">n</a> <a id="4693" href="README.Nary.html#4693" class="Bound">j</a> <a id="4695" class="Symbol">→</a>
    <a id="4701" class="Keyword">let</a> <a id="4705" href="README.Nary.html#4705" class="Bound">P</a> <a id="4707" href="README.Nary.html#4707" class="Bound">sk</a> <a id="4710" href="README.Nary.html#4710" class="Bound">sn</a> <a id="4713" href="README.Nary.html#4713" class="Bound">sj</a> <a id="4716" class="Symbol">=</a> <a id="4718" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4729" href="README.Nary.html#4687" class="Bound">k</a> <a id="4731" href="README.Nary.html#4689" class="Bound">m</a> <a id="4733" href="README.Nary.html#4710" class="Bound">sn</a> <a id="4736" href="README.Nary.html#4713" class="Bound">sj</a> <a id="4739" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="4741" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="4752" href="README.Nary.html#4707" class="Bound">sk</a> <a id="4755" href="README.Nary.html#4689" class="Bound">m</a> <a id="4757" href="README.Nary.html#4691" class="Bound">n</a> <a id="4759" href="README.Nary.html#4693" class="Bound">j</a>
    <a id="4765" class="Keyword">in</a> <a id="4768" href="Relation.Nary.html#3726" class="Function">substₙ</a> <a id="4775" href="README.Nary.html#4705" class="Bound">P</a> <a id="4777" class="Symbol">(</a><a id="4778" href="Data.Nat.Properties.html#14756" class="Function">+-comm</a> <a id="4785" class="Number">1</a> <a id="4787" href="README.Nary.html#4687" class="Bound">k</a><a id="4788" class="Symbol">)</a> <a id="4790" class="Symbol">(</a><a id="4791" href="Data.Nat.Properties.html#14756" class="Function">+-comm</a> <a id="4798" class="Number">1</a> <a id="4800" href="README.Nary.html#4691" class="Bound">n</a><a id="4801" class="Symbol">)</a> <a id="4803" class="Symbol">(</a><a id="4804" href="Data.Nat.Properties.html#14756" class="Function">+-comm</a> <a id="4811" class="Number">1</a> <a id="4813" href="README.Nary.html#4693" class="Bound">j</a><a id="4814" class="Symbol">)</a> <a id="4816" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="4822" class="Comment">-----------------------------------------------------------------------</a>
<a id="4894" class="Comment">-- Generic programs working on n-ary products &amp; functions</a>
<a id="4952" class="Comment">-----------------------------------------------------------------------</a>

<a id="5025" class="Comment">-----------------------------------------------------------------------</a>
<a id="5097" class="Comment">-- curryₙ   : ∀ n → (A₁ × ⋯ × Aₙ → B) → A₁ → ⋯ → Aₙ → B</a>
<a id="5153" class="Comment">-- uncurryₙ : ∀ n → (A₁ → ⋯ → Aₙ → B) → A₁ × ⋯ × Aₙ → B</a>

<a id="5210" class="Comment">-- The first thing we may want to do generically is convert between</a>
<a id="5278" class="Comment">-- curried function types and uncurried ones. We can do this by using:</a>

<a id="5350" class="Comment">-- They both work the same way so we will focus on curryₙ only here.</a>
<a id="5419" class="Comment">-- If we pass to `curryₙ` the arity of its argument then we obtain a</a>
<a id="5488" class="Comment">-- fully curried function.</a>

<a id="curry₁"></a><a id="5516" href="README.Nary.html#5516" class="Function">curry₁</a> <a id="5523" class="Symbol">:</a> <a id="5525" class="Symbol">(</a><a id="5526" href="README.Nary.html#822" class="Generalizable">A</a> <a id="5528" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="5530" href="README.Nary.html#836" class="Generalizable">B</a> <a id="5532" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="5534" href="README.Nary.html#850" class="Generalizable">C</a> <a id="5536" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="5538" href="README.Nary.html#864" class="Generalizable">D</a> <a id="5540" class="Symbol">→</a> <a id="5542" href="README.Nary.html#878" class="Generalizable">E</a><a id="5543" class="Symbol">)</a> <a id="5545" class="Symbol">→</a> <a id="5547" href="README.Nary.html#822" class="Generalizable">A</a> <a id="5549" class="Symbol">→</a> <a id="5551" href="README.Nary.html#836" class="Generalizable">B</a> <a id="5553" class="Symbol">→</a> <a id="5555" href="README.Nary.html#850" class="Generalizable">C</a> <a id="5557" class="Symbol">→</a> <a id="5559" href="README.Nary.html#864" class="Generalizable">D</a> <a id="5561" class="Symbol">→</a> <a id="5563" href="README.Nary.html#878" class="Generalizable">E</a>
<a id="5565" href="README.Nary.html#5516" class="Function">curry₁</a> <a id="5572" class="Symbol">=</a> <a id="5574" href="Data.Product.Nary.NonDependent.html#3639" class="Function">curryₙ</a> <a id="5581" class="Number">4</a>

<a id="5584" class="Comment">-- Note that here we are not flattening arbitrary nestings: products have</a>
<a id="5658" class="Comment">-- to be right nested. Which means that if you have a deeply-nested product</a>
<a id="5734" class="Comment">-- then it won&#39;t be affected by the procedure.</a>

<a id="curry₁′"></a><a id="5782" href="README.Nary.html#5782" class="Function">curry₁′</a> <a id="5790" class="Symbol">:</a> <a id="5792" class="Symbol">(</a><a id="5793" href="README.Nary.html#822" class="Generalizable">A</a> <a id="5795" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="5797" class="Symbol">(</a><a id="5798" href="README.Nary.html#836" class="Generalizable">B</a> <a id="5800" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="5802" href="README.Nary.html#850" class="Generalizable">C</a><a id="5803" class="Symbol">)</a> <a id="5805" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="5807" href="README.Nary.html#864" class="Generalizable">D</a> <a id="5809" class="Symbol">→</a> <a id="5811" href="README.Nary.html#878" class="Generalizable">E</a><a id="5812" class="Symbol">)</a> <a id="5814" class="Symbol">→</a> <a id="5816" href="README.Nary.html#822" class="Generalizable">A</a> <a id="5818" class="Symbol">→</a> <a id="5820" class="Symbol">(</a><a id="5821" href="README.Nary.html#836" class="Generalizable">B</a> <a id="5823" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="5825" href="README.Nary.html#850" class="Generalizable">C</a><a id="5826" class="Symbol">)</a> <a id="5828" class="Symbol">→</a> <a id="5830" href="README.Nary.html#864" class="Generalizable">D</a> <a id="5832" class="Symbol">→</a> <a id="5834" href="README.Nary.html#878" class="Generalizable">E</a>
<a id="5836" href="README.Nary.html#5782" class="Function">curry₁′</a> <a id="5844" class="Symbol">=</a> <a id="5846" href="Data.Product.Nary.NonDependent.html#3639" class="Function">curryₙ</a> <a id="5853" class="Number">3</a>

<a id="5856" class="Comment">-- When we are currying a function, we have no obligation to pass its exact</a>
<a id="5932" class="Comment">-- arity as the parameter: we can decide to only curry part of it like so:</a>
<a id="6007" class="Comment">-- Indeed (A₁ × ⋯ × Aₙ → B) can also be seen as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ) → B)</a>

<a id="curry₂"></a><a id="6085" href="README.Nary.html#6085" class="Function">curry₂</a> <a id="6092" class="Symbol">:</a> <a id="6094" class="Symbol">(</a><a id="6095" href="README.Nary.html#822" class="Generalizable">A</a> <a id="6097" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6099" href="README.Nary.html#836" class="Generalizable">B</a> <a id="6101" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6103" href="README.Nary.html#850" class="Generalizable">C</a> <a id="6105" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6107" href="README.Nary.html#864" class="Generalizable">D</a> <a id="6109" class="Symbol">→</a> <a id="6111" href="README.Nary.html#878" class="Generalizable">E</a><a id="6112" class="Symbol">)</a> <a id="6114" class="Symbol">→</a> <a id="6116" href="README.Nary.html#822" class="Generalizable">A</a> <a id="6118" class="Symbol">→</a> <a id="6120" href="README.Nary.html#836" class="Generalizable">B</a> <a id="6122" class="Symbol">→</a> <a id="6124" class="Symbol">(</a><a id="6125" href="README.Nary.html#850" class="Generalizable">C</a> <a id="6127" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6129" href="README.Nary.html#864" class="Generalizable">D</a><a id="6130" class="Symbol">)</a> <a id="6132" class="Symbol">→</a> <a id="6134" href="README.Nary.html#878" class="Generalizable">E</a>
<a id="6136" href="README.Nary.html#6085" class="Function">curry₂</a> <a id="6143" class="Symbol">=</a> <a id="6145" href="Data.Product.Nary.NonDependent.html#3639" class="Function">curryₙ</a> <a id="6152" class="Number">3</a>

<a id="6155" class="Comment">-----------------------------------------------------------------------</a>
<a id="6227" class="Comment">-- projₙ : ∀ n (k : Fin n) → (A₁ × ⋯ × Aₙ) → Aₖ₊₁</a>

<a id="6278" class="Comment">-- Another useful class of functions to manipulate n-ary product is a</a>
<a id="6348" class="Comment">-- generic projection function. Note the (k + 1) in the return index:</a>
<a id="6418" class="Comment">-- Fin counts from 0 up.</a>

<a id="6444" class="Comment">-- It behaves as one expects (Data.Fin&#39;s #_ comes in handy to write down</a>
<a id="6517" class="Comment">-- Fin literals):</a>

<a id="proj₃"></a><a id="6536" href="README.Nary.html#6536" class="Function">proj₃</a> <a id="6542" class="Symbol">:</a> <a id="6544" class="Symbol">(</a><a id="6545" href="README.Nary.html#822" class="Generalizable">A</a> <a id="6547" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6549" href="README.Nary.html#836" class="Generalizable">B</a> <a id="6551" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6553" href="README.Nary.html#850" class="Generalizable">C</a> <a id="6555" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6557" href="README.Nary.html#864" class="Generalizable">D</a> <a id="6559" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6561" href="README.Nary.html#878" class="Generalizable">E</a><a id="6562" class="Symbol">)</a> <a id="6564" class="Symbol">→</a> <a id="6566" href="README.Nary.html#850" class="Generalizable">C</a>
<a id="6568" href="README.Nary.html#6536" class="Function">proj₃</a> <a id="6574" class="Symbol">=</a> <a id="6576" href="Data.Product.Nary.NonDependent.html#6433" class="Function">projₙ</a> <a id="6582" class="Number">5</a> <a id="6584" class="Symbol">(</a><a id="6585" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6587" class="Number">2</a><a id="6588" class="Symbol">)</a>

<a id="6591" class="Comment">-- Of course we can once more project the &quot;tail&quot; of the n-ary product by</a>
<a id="6664" class="Comment">-- passing `projₙ` a natural number which is smaller than the size of the</a>
<a id="6738" class="Comment">-- n-ary product, seeing (A₁ × ⋯ × Aₙ) as (A₁ × ⋯ × (Aₖ × ⋯ × Aₙ)).</a>

<a id="proj₃′"></a><a id="6807" href="README.Nary.html#6807" class="Function">proj₃′</a> <a id="6814" class="Symbol">:</a> <a id="6816" class="Symbol">(</a><a id="6817" href="README.Nary.html#822" class="Generalizable">A</a> <a id="6819" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6821" href="README.Nary.html#836" class="Generalizable">B</a> <a id="6823" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6825" href="README.Nary.html#850" class="Generalizable">C</a> <a id="6827" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6829" href="README.Nary.html#864" class="Generalizable">D</a> <a id="6831" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6833" href="README.Nary.html#878" class="Generalizable">E</a><a id="6834" class="Symbol">)</a> <a id="6836" class="Symbol">→</a> <a id="6838" href="README.Nary.html#850" class="Generalizable">C</a> <a id="6840" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6842" href="README.Nary.html#864" class="Generalizable">D</a> <a id="6844" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6846" href="README.Nary.html#878" class="Generalizable">E</a>
<a id="6848" href="README.Nary.html#6807" class="Function">proj₃′</a> <a id="6855" class="Symbol">=</a> <a id="6857" href="Data.Product.Nary.NonDependent.html#6433" class="Function">projₙ</a> <a id="6863" class="Number">3</a> <a id="6865" class="Symbol">(</a><a id="6866" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="6868" class="Number">2</a><a id="6869" class="Symbol">)</a>

<a id="6872" class="Comment">-----------------------------------------------------------------------</a>
<a id="6944" class="Comment">-- insertₙ : ∀ n (k : Fin (suc n)) →</a>
<a id="6981" class="Comment">--           B → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B × Aₖ₊₁ × ⋯ Aₙ)</a>

<a id="insert₁"></a><a id="7045" href="README.Nary.html#7045" class="Function">insert₁</a> <a id="7053" class="Symbol">:</a> <a id="7055" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7057" class="Symbol">→</a> <a id="7059" class="Symbol">(</a><a id="7060" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7062" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7064" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7066" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7068" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7070" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7072" href="README.Nary.html#878" class="Generalizable">E</a><a id="7073" class="Symbol">)</a> <a id="7075" class="Symbol">→</a> <a id="7077" class="Symbol">(</a><a id="7078" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7080" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7082" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7084" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7086" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7088" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7090" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7092" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7094" href="README.Nary.html#878" class="Generalizable">E</a><a id="7095" class="Symbol">)</a>
<a id="7097" href="README.Nary.html#7045" class="Function">insert₁</a> <a id="7105" class="Symbol">=</a> <a id="7107" href="Data.Product.Nary.NonDependent.html#8000" class="Function">insertₙ</a> <a id="7115" class="Number">4</a> <a id="7117" class="Symbol">(</a><a id="7118" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7120" class="Number">2</a><a id="7121" class="Symbol">)</a>

<a id="insert₁′"></a><a id="7124" href="README.Nary.html#7124" class="Function">insert₁′</a> <a id="7133" class="Symbol">:</a> <a id="7135" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7137" class="Symbol">→</a> <a id="7139" class="Symbol">(</a><a id="7140" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7142" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7144" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7146" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7148" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7150" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7152" href="README.Nary.html#878" class="Generalizable">E</a><a id="7153" class="Symbol">)</a> <a id="7155" class="Symbol">→</a> <a id="7157" class="Symbol">(</a><a id="7158" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7160" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7162" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7164" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7166" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7168" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7170" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7172" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7174" href="README.Nary.html#878" class="Generalizable">E</a><a id="7175" class="Symbol">)</a>
<a id="7177" href="README.Nary.html#7124" class="Function">insert₁′</a> <a id="7186" class="Symbol">=</a> <a id="7188" href="Data.Product.Nary.NonDependent.html#8000" class="Function">insertₙ</a> <a id="7196" class="Number">3</a> <a id="7198" class="Symbol">(</a><a id="7199" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7201" class="Number">2</a><a id="7202" class="Symbol">)</a>

<a id="7205" class="Comment">-- Note that `insertₙ` takes a `Fin (suc n)`. Indeed in an n-ary product</a>
<a id="7278" class="Comment">-- there are (suc n) positions at which one may insert a value. We may</a>
<a id="7349" class="Comment">-- insert at the front or the back of the product:</a>

<a id="insert-front"></a><a id="7401" href="README.Nary.html#7401" class="Function">insert-front</a> <a id="7414" class="Symbol">:</a> <a id="7416" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7418" class="Symbol">→</a> <a id="7420" class="Symbol">(</a><a id="7421" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7423" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7425" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7427" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7429" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7431" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7433" href="README.Nary.html#878" class="Generalizable">E</a><a id="7434" class="Symbol">)</a> <a id="7436" class="Symbol">→</a> <a id="7438" class="Symbol">(</a><a id="7439" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7441" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7443" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7445" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7447" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7449" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7451" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7453" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7455" href="README.Nary.html#878" class="Generalizable">E</a><a id="7456" class="Symbol">)</a>
<a id="7458" href="README.Nary.html#7401" class="Function">insert-front</a> <a id="7471" class="Symbol">=</a> <a id="7473" href="Data.Product.Nary.NonDependent.html#8000" class="Function">insertₙ</a> <a id="7481" class="Number">4</a> <a id="7483" class="Symbol">(</a><a id="7484" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7486" class="Number">0</a><a id="7487" class="Symbol">)</a>

<a id="insert-back"></a><a id="7490" href="README.Nary.html#7490" class="Function">insert-back</a> <a id="7502" class="Symbol">:</a> <a id="7504" href="README.Nary.html#878" class="Generalizable">E</a> <a id="7506" class="Symbol">→</a> <a id="7508" class="Symbol">(</a><a id="7509" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7511" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7513" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7515" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7517" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7519" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7521" href="README.Nary.html#864" class="Generalizable">D</a><a id="7522" class="Symbol">)</a> <a id="7524" class="Symbol">→</a> <a id="7526" class="Symbol">(</a><a id="7527" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7529" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7531" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7533" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7535" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7537" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7539" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7541" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7543" href="README.Nary.html#878" class="Generalizable">E</a><a id="7544" class="Symbol">)</a>
<a id="7546" href="README.Nary.html#7490" class="Function">insert-back</a> <a id="7558" class="Symbol">=</a> <a id="7560" href="Data.Product.Nary.NonDependent.html#8000" class="Function">insertₙ</a> <a id="7568" class="Number">4</a> <a id="7570" class="Symbol">(</a><a id="7571" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7573" class="Number">4</a><a id="7574" class="Symbol">)</a>

<a id="7577" class="Comment">-----------------------------------------------------------------------</a>
<a id="7649" class="Comment">-- removeₙ : ∀ n (k : Fin n) → (A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="7723" class="Comment">-- Dual to `insertₙ`, we may remove a value.</a>

<a id="remove₁"></a><a id="7769" href="README.Nary.html#7769" class="Function">remove₁</a> <a id="7777" class="Symbol">:</a> <a id="7779" class="Symbol">(</a><a id="7780" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7782" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7784" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7786" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7788" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7790" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7792" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7794" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7796" href="README.Nary.html#878" class="Generalizable">E</a><a id="7797" class="Symbol">)</a> <a id="7799" class="Symbol">→</a> <a id="7801" class="Symbol">(</a><a id="7802" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7804" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7806" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7808" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7810" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7812" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7814" href="README.Nary.html#878" class="Generalizable">E</a><a id="7815" class="Symbol">)</a>
<a id="7817" href="README.Nary.html#7769" class="Function">remove₁</a> <a id="7825" class="Symbol">=</a> <a id="7827" href="Data.Product.Nary.NonDependent.html#7137" class="Function">removeₙ</a> <a id="7835" class="Number">5</a> <a id="7837" class="Symbol">(</a><a id="7838" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="7840" class="Number">2</a><a id="7841" class="Symbol">)</a>

<a id="7844" class="Comment">-- Inserting at `k` and then removing at `inject₁ k` should yield the identity</a>

<a id="remove-insert"></a><a id="7924" href="README.Nary.html#7924" class="Function">remove-insert</a> <a id="7938" class="Symbol">:</a> <a id="7940" href="README.Nary.html#850" class="Generalizable">C</a> <a id="7942" class="Symbol">→</a> <a id="7944" class="Symbol">(</a><a id="7945" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7947" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7949" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7951" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7953" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7955" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7957" href="README.Nary.html#878" class="Generalizable">E</a><a id="7958" class="Symbol">)</a> <a id="7960" class="Symbol">→</a> <a id="7962" class="Symbol">(</a><a id="7963" href="README.Nary.html#822" class="Generalizable">A</a> <a id="7965" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7967" href="README.Nary.html#836" class="Generalizable">B</a> <a id="7969" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7971" href="README.Nary.html#864" class="Generalizable">D</a> <a id="7973" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="7975" href="README.Nary.html#878" class="Generalizable">E</a><a id="7976" class="Symbol">)</a>
<a id="7978" href="README.Nary.html#7924" class="Function">remove-insert</a> <a id="7992" href="README.Nary.html#7992" class="Bound">c</a> <a id="7994" class="Symbol">=</a> <a id="7996" href="Data.Product.Nary.NonDependent.html#7137" class="Function">removeₙ</a> <a id="8004" class="Number">5</a> <a id="8006" class="Symbol">(</a><a id="8007" href="Data.Fin.Base.html#3176" class="Function">inject₁</a> <a id="8015" href="README.Nary.html#8045" class="Function">k</a><a id="8016" class="Symbol">)</a> <a id="8018" href="Function.Base.html#3646" class="Function Operator">∘′</a> <a id="8021" href="Data.Product.Nary.NonDependent.html#8000" class="Function">insertₙ</a> <a id="8029" class="Number">4</a> <a id="8031" href="README.Nary.html#8045" class="Function">k</a> <a id="8033" href="README.Nary.html#7992" class="Bound">c</a>
    <a id="8039" class="Keyword">where</a> <a id="8045" href="README.Nary.html#8045" class="Function">k</a> <a id="8047" class="Symbol">=</a> <a id="8049" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8051" class="Number">2</a>

<a id="8054" class="Comment">-----------------------------------------------------------------------</a>
<a id="8126" class="Comment">-- updateₙ : ∀ n (k : Fin n) (f : (a : Aₖ₊₁) → B a) →</a>
<a id="8180" class="Comment">--           (p : A₁ × ⋯ Aₙ) → (A₁ × ⋯ × Aₖ × B (projₙ n k p) × Aₖ₊₂ × ⋯ Aₙ)</a>

<a id="8258" class="Comment">-- We can not only project out, insert or remove values: we can update them</a>
<a id="8334" class="Comment">-- in place. The type (and value) of the replacement at position k may depend</a>
<a id="8412" class="Comment">-- upon the current value at position k.</a>

<a id="update₁"></a><a id="8454" href="README.Nary.html#8454" class="Function">update₁</a> <a id="8462" class="Symbol">:</a> <a id="8464" class="Symbol">(</a><a id="8465" href="README.Nary.html#8465" class="Bound">p</a> <a id="8467" class="Symbol">:</a> <a id="8469" href="README.Nary.html#822" class="Generalizable">A</a> <a id="8471" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8473" href="README.Nary.html#836" class="Generalizable">B</a> <a id="8475" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8477" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="8479" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8481" href="README.Nary.html#850" class="Generalizable">C</a> <a id="8483" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8485" href="README.Nary.html#864" class="Generalizable">D</a><a id="8486" class="Symbol">)</a> <a id="8488" class="Symbol">→</a> <a id="8490" class="Symbol">(</a><a id="8491" href="README.Nary.html#822" class="Generalizable">A</a> <a id="8493" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8495" href="README.Nary.html#836" class="Generalizable">B</a> <a id="8497" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8499" href="Data.Fin.Base.html#1212" class="Datatype">Fin</a> <a id="8503" class="Symbol">_</a> <a id="8505" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8507" href="README.Nary.html#850" class="Generalizable">C</a> <a id="8509" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8511" href="README.Nary.html#864" class="Generalizable">D</a><a id="8512" class="Symbol">)</a>
<a id="8514" href="README.Nary.html#8454" class="Function">update₁</a> <a id="8522" class="Symbol">=</a> <a id="8524" href="Data.Product.Nary.NonDependent.html#8799" class="Function">updateₙ</a> <a id="8532" class="Number">5</a> <a id="8534" class="Symbol">(</a><a id="8535" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8537" class="Number">2</a><a id="8538" class="Symbol">)</a> <a id="8540" href="Data.Fin.Base.html#1905" class="Function">fromℕ</a>

<a id="8547" class="Comment">-- We can explicitly use the primed version of `updateₙ` to make it known to</a>
<a id="8624" class="Comment">-- Agda that the update function is non dependent. This type of information</a>
<a id="8700" class="Comment">-- is useful for inference: the tighter the constraints, the easier it is to</a>
<a id="8777" class="Comment">-- find a solution (if possible).</a>

<a id="update₂"></a><a id="8812" href="README.Nary.html#8812" class="Function">update₂</a> <a id="8820" class="Symbol">:</a> <a id="8822" class="Symbol">(</a><a id="8823" href="README.Nary.html#8823" class="Bound">p</a> <a id="8825" class="Symbol">:</a> <a id="8827" href="README.Nary.html#822" class="Generalizable">A</a> <a id="8829" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8831" href="README.Nary.html#836" class="Generalizable">B</a> <a id="8833" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8835" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="8837" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8839" href="README.Nary.html#850" class="Generalizable">C</a> <a id="8841" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8843" href="README.Nary.html#864" class="Generalizable">D</a><a id="8844" class="Symbol">)</a> <a id="8846" class="Symbol">→</a> <a id="8848" class="Symbol">(</a><a id="8849" href="README.Nary.html#822" class="Generalizable">A</a> <a id="8851" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8853" href="README.Nary.html#836" class="Generalizable">B</a> <a id="8855" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8857" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="8862" href="README.Nary.html#864" class="Generalizable">D</a> <a id="8864" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8866" href="README.Nary.html#850" class="Generalizable">C</a> <a id="8868" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8870" href="README.Nary.html#864" class="Generalizable">D</a><a id="8871" class="Symbol">)</a>
<a id="8873" href="README.Nary.html#8812" class="Function">update₂</a> <a id="8881" class="Symbol">=</a> <a id="8883" class="Symbol">λ</a> <a id="8885" href="README.Nary.html#8885" class="Bound">p</a> <a id="8887" class="Symbol">→</a> <a id="8889" href="Data.Product.Nary.NonDependent.html#9139" class="Function">updateₙ′</a> <a id="8898" class="Number">5</a> <a id="8900" class="Symbol">(</a><a id="8901" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8903" class="Number">2</a><a id="8904" class="Symbol">)</a> <a id="8906" class="Symbol">(λ</a> <a id="8909" href="README.Nary.html#8909" class="Bound">n</a> <a id="8911" class="Symbol">→</a> <a id="8913" href="Data.List.Base.html#5163" class="Function">replicate</a> <a id="8923" href="README.Nary.html#8909" class="Bound">n</a> <a id="8925" class="Symbol">(</a><a id="8926" href="Data.Product.Nary.NonDependent.html#6433" class="Function">projₙ</a> <a id="8932" class="Number">5</a> <a id="8934" class="Symbol">(</a><a id="8935" href="Data.Fin.html#739" class="Function Operator">#</a> <a id="8937" class="Number">4</a><a id="8938" class="Symbol">)</a> <a id="8940" href="README.Nary.html#8885" class="Bound">p</a><a id="8941" class="Symbol">))</a> <a id="8944" href="README.Nary.html#8885" class="Bound">p</a>

<a id="8947" class="Comment">-----------------------------------------------------------------------</a>
<a id="9019" class="Comment">-- _%=_⊢_ : ∀ n → (C → D) → (A₁ → ⋯ Aₙ → D → B) → A₁ → ⋯ → Aₙ → C → B</a>

<a id="9090" class="Comment">-- Traditional composition (also known as the index update operator `_⊢_`</a>
<a id="9164" class="Comment">-- in `Relation.Unary`) focuses solely on the first argument of an n-ary</a>
<a id="9237" class="Comment">-- function. `_%=_⊢_` on the other hand allows us to touch any one of the</a>
<a id="9311" class="Comment">-- arguments.</a>

<a id="9326" class="Comment">-- In the following example we have a function `f : A → B` and `replicate`</a>
<a id="9401" class="Comment">-- of type `ℕ → B → List B`. We want ̀f` to act on the second argument of</a>
<a id="9475" class="Comment">-- replicate. Which we can do like so.</a>

<a id="compose₁"></a><a id="9515" href="README.Nary.html#9515" class="Function">compose₁</a> <a id="9524" class="Symbol">:</a> <a id="9526" class="Symbol">(</a><a id="9527" href="README.Nary.html#822" class="Generalizable">A</a> <a id="9529" class="Symbol">→</a> <a id="9531" href="README.Nary.html#836" class="Generalizable">B</a><a id="9532" class="Symbol">)</a> <a id="9534" class="Symbol">→</a> <a id="9536" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9538" class="Symbol">→</a> <a id="9540" href="README.Nary.html#822" class="Generalizable">A</a> <a id="9542" class="Symbol">→</a> <a id="9544" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9549" href="README.Nary.html#836" class="Generalizable">B</a>
<a id="9551" href="README.Nary.html#9515" class="Function">compose₁</a> <a id="9560" href="README.Nary.html#9560" class="Bound">f</a> <a id="9562" class="Symbol">=</a> <a id="9564" class="Number">1</a> <a id="9566" href="Function.Nary.NonDependent.Base.html#3863" class="Function Operator">%=</a> <a id="9569" href="README.Nary.html#9560" class="Bound">f</a> <a id="9571" href="Function.Nary.NonDependent.Base.html#3863" class="Function Operator">⊢</a> <a id="9573" href="Data.List.Base.html#5163" class="Function">replicate</a>

<a id="9584" class="Comment">-- Here we spell out the equivalent explicit variable-manipulation and</a>
<a id="9655" class="Comment">-- prove the two functions equal.</a>

<a id="compose₁′"></a><a id="9690" href="README.Nary.html#9690" class="Function">compose₁′</a> <a id="9700" class="Symbol">:</a> <a id="9702" class="Symbol">(</a><a id="9703" href="README.Nary.html#822" class="Generalizable">A</a> <a id="9705" class="Symbol">→</a> <a id="9707" href="README.Nary.html#836" class="Generalizable">B</a><a id="9708" class="Symbol">)</a> <a id="9710" class="Symbol">→</a> <a id="9712" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9714" class="Symbol">→</a> <a id="9716" href="README.Nary.html#822" class="Generalizable">A</a> <a id="9718" class="Symbol">→</a> <a id="9720" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9725" href="README.Nary.html#836" class="Generalizable">B</a>
<a id="9727" href="README.Nary.html#9690" class="Function">compose₁′</a> <a id="9737" href="README.Nary.html#9737" class="Bound">f</a> <a id="9739" href="README.Nary.html#9739" class="Bound">n</a> <a id="9741" href="README.Nary.html#9741" class="Bound">a</a> <a id="9743" class="Symbol">=</a> <a id="9745" href="Data.List.Base.html#5163" class="Function">replicate</a> <a id="9755" href="README.Nary.html#9739" class="Bound">n</a> <a id="9757" class="Symbol">(</a><a id="9758" href="README.Nary.html#9737" class="Bound">f</a> <a id="9760" href="README.Nary.html#9741" class="Bound">a</a><a id="9761" class="Symbol">)</a>

<a id="compose₁-eq"></a><a id="9764" href="README.Nary.html#9764" class="Function">compose₁-eq</a> <a id="9776" class="Symbol">:</a> <a id="9778" href="README.Nary.html#9515" class="Function">compose₁</a> <a id="9787" class="Symbol">{</a><a id="9788" href="README.Nary.html#800" class="Generalizable">a</a><a id="9789" class="Symbol">}</a> <a id="9791" class="Symbol">{</a><a id="9792" href="README.Nary.html#822" class="Generalizable">A</a><a id="9793" class="Symbol">}</a> <a id="9795" class="Symbol">{</a><a id="9796" href="README.Nary.html#802" class="Generalizable">b</a><a id="9797" class="Symbol">}</a> <a id="9799" class="Symbol">{</a><a id="9800" href="README.Nary.html#836" class="Generalizable">B</a><a id="9801" class="Symbol">}</a> <a id="9803" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="9805" href="README.Nary.html#9690" class="Function">compose₁′</a>
<a id="9815" href="README.Nary.html#9764" class="Function">compose₁-eq</a> <a id="9827" class="Symbol">=</a> <a id="9829" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="9835" class="Comment">-----------------------------------------------------------------------</a>
<a id="9907" class="Comment">-- _∷=_⊢_ : ∀ n → A → (A₁ → ⋯ Aₙ → A → B) → A₁ → ⋯ → Aₙ → B</a>

<a id="9968" class="Comment">-- Partial application usually focuses on the first argument of a function.</a>
<a id="10044" class="Comment">-- We can now partially apply a function in any of its arguments using</a>
<a id="10115" class="Comment">-- `_∷=_⊢_`. Reusing our example involving replicate: we can specialise it</a>
<a id="10190" class="Comment">-- to only output finite lists of `0`:</a>

<a id="apply₁"></a><a id="10230" href="README.Nary.html#10230" class="Function">apply₁</a> <a id="10237" class="Symbol">:</a> <a id="10239" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="10241" class="Symbol">→</a> <a id="10243" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="10248" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="10250" href="README.Nary.html#10230" class="Function">apply₁</a> <a id="10257" class="Symbol">=</a> <a id="10259" class="Number">1</a> <a id="10261" href="Function.Nary.NonDependent.Base.html#4035" class="Function Operator">∷=</a> <a id="10264" class="Number">0</a> <a id="10266" href="Function.Nary.NonDependent.Base.html#4035" class="Function Operator">⊢</a> <a id="10268" href="Data.List.Base.html#5163" class="Function">replicate</a>

<a id="apply₁-eq"></a><a id="10279" href="README.Nary.html#10279" class="Function">apply₁-eq</a> <a id="10289" class="Symbol">:</a> <a id="10291" href="README.Nary.html#10230" class="Function">apply₁</a> <a id="10298" class="Number">3</a> <a id="10300" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="10302" class="Number">0</a> <a id="10304" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10306" class="Number">0</a> <a id="10308" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10310" class="Number">0</a> <a id="10312" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="10314" class="InductiveConstructor">[]</a>
<a id="10317" href="README.Nary.html#10279" class="Function">apply₁-eq</a> <a id="10327" class="Symbol">=</a> <a id="10329" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="10335" class="Comment">------------------------------------------------------------------------</a>
<a id="10408" class="Comment">-- holeₙ : ∀ n → (A → (A₁ → ⋯ Aₙ → B)) → A₁ → ⋯ → Aₙ → (A → B)</a>

<a id="10472" class="Comment">-- As we have seen earlier, `cong` acts on a function&#39;s first variable.</a>
<a id="10544" class="Comment">-- If we want to access the second one, we can use `flip`. But what about</a>
<a id="10618" class="Comment">-- the fourth one? We typically use an explicit λ-abstraction shuffling</a>
<a id="10690" class="Comment">-- variables. Not anymore.</a>

<a id="10718" class="Comment">-- Reusing mod-helper just because it takes a lot of arguments:</a>

<a id="hole₁"></a><a id="10783" href="README.Nary.html#10783" class="Function">hole₁</a> <a id="10789" class="Symbol">:</a> <a id="10791" class="Symbol">∀</a> <a id="10793" href="README.Nary.html#10793" class="Bound">k</a> <a id="10795" href="README.Nary.html#10795" class="Bound">m</a> <a id="10797" href="README.Nary.html#10797" class="Bound">n</a> <a id="10799" href="README.Nary.html#10799" class="Bound">j</a> <a id="10801" class="Symbol">→</a> <a id="10803" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10814" href="README.Nary.html#10793" class="Bound">k</a> <a id="10816" class="Symbol">(</a><a id="10817" href="README.Nary.html#10795" class="Bound">m</a> <a id="10819" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="10821" class="Number">1</a><a id="10822" class="Symbol">)</a> <a id="10824" href="README.Nary.html#10797" class="Bound">n</a> <a id="10826" href="README.Nary.html#10799" class="Bound">j</a> <a id="10828" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="10830" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10841" href="README.Nary.html#10793" class="Bound">k</a> <a id="10843" class="Symbol">(</a><a id="10844" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="10848" href="README.Nary.html#10795" class="Bound">m</a><a id="10849" class="Symbol">)</a> <a id="10851" href="README.Nary.html#10797" class="Bound">n</a> <a id="10853" href="README.Nary.html#10799" class="Bound">j</a>
<a id="10855" href="README.Nary.html#10783" class="Function">hole₁</a> <a id="10861" class="Symbol">=</a> <a id="10863" class="Symbol">λ</a> <a id="10865" href="README.Nary.html#10865" class="Bound">k</a> <a id="10867" href="README.Nary.html#10867" class="Bound">m</a> <a id="10869" href="README.Nary.html#10869" class="Bound">n</a> <a id="10871" href="README.Nary.html#10871" class="Bound">j</a> <a id="10873" class="Symbol">→</a> <a id="10875" href="Relation.Binary.PropositionalEquality.Core.html#1139" class="Function">cong</a> <a id="10880" class="Symbol">(</a><a id="10881" href="Function.Nary.NonDependent.Base.html#4159" class="Function">holeₙ</a> <a id="10887" class="Number">2</a> <a id="10889" class="Symbol">(</a><a id="10890" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="10901" href="README.Nary.html#10865" class="Bound">k</a><a id="10902" class="Symbol">)</a> <a id="10904" href="README.Nary.html#10869" class="Bound">n</a> <a id="10906" href="README.Nary.html#10871" class="Bound">j</a><a id="10907" class="Symbol">)</a> <a id="10909" class="Symbol">(</a><a id="10910" href="Data.Nat.Properties.html#14756" class="Function">+-comm</a> <a id="10917" href="README.Nary.html#10867" class="Bound">m</a> <a id="10919" class="Number">1</a><a id="10920" class="Symbol">)</a>

<a id="10923" class="Comment">-----------------------------------------------------------------------</a>
<a id="10995" class="Comment">-- mapₙ : ∀ n → (B → C) → (A₁ → ⋯ Aₙ → B) → (A₁ → ⋯ → Aₙ → C)</a>

<a id="11058" class="Comment">-- (R →_) gives us the reader monad (and, a fortiori, functor). That is to</a>
<a id="11133" class="Comment">-- say that given a function (A → B) and an (R → A) we can get an (R → B)</a>
<a id="11207" class="Comment">-- This generalises to n-ary functions.</a>

<a id="11248" class="Comment">-- Reusing our `composeₙ` example: instead of applying `f` to the replicated</a>
<a id="11325" class="Comment">-- element, we can map it on the resulting list. Giving us:</a>

<a id="map₁"></a><a id="11386" href="README.Nary.html#11386" class="Function">map₁</a> <a id="11391" class="Symbol">:</a> <a id="11393" class="Symbol">(</a><a id="11394" href="README.Nary.html#822" class="Generalizable">A</a> <a id="11396" class="Symbol">→</a> <a id="11398" href="README.Nary.html#836" class="Generalizable">B</a><a id="11399" class="Symbol">)</a> <a id="11401" class="Symbol">→</a> <a id="11403" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="11405" class="Symbol">→</a> <a id="11407" href="README.Nary.html#822" class="Generalizable">A</a> <a id="11409" class="Symbol">→</a> <a id="11411" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="11416" href="README.Nary.html#836" class="Generalizable">B</a>
<a id="11418" href="README.Nary.html#11386" class="Function">map₁</a> <a id="11423" href="README.Nary.html#11423" class="Bound">f</a> <a id="11425" class="Symbol">=</a> <a id="11427" href="Function.Nary.NonDependent.Base.html#3687" class="Function">mapₙ</a> <a id="11432" class="Number">2</a> <a id="11434" class="Symbol">(</a><a id="11435" href="Data.List.Base.html#1572" class="Function">map</a> <a id="11439" href="README.Nary.html#11423" class="Bound">f</a><a id="11440" class="Symbol">)</a> <a id="11442" href="Data.List.Base.html#5163" class="Function">replicate</a>

<a id="11453" class="Comment">------------------------------------------------------------------------</a>
<a id="11526" class="Comment">-- constₙ : ∀ n → B → A₁ → ⋯ → Aₙ → B</a>

<a id="11565" class="Comment">-- `const` is basically `pure` for the reader monad discussed above. Just</a>
<a id="11639" class="Comment">-- like we can generalise the functorial action corresponding to the reader</a>
<a id="11715" class="Comment">-- functor to n-ary functions, we can do the same for `pure`.</a>

<a id="const₁"></a><a id="11778" href="README.Nary.html#11778" class="Function">const₁</a> <a id="11785" class="Symbol">:</a> <a id="11787" href="README.Nary.html#822" class="Generalizable">A</a> <a id="11789" class="Symbol">→</a> <a id="11791" href="README.Nary.html#836" class="Generalizable">B</a> <a id="11793" class="Symbol">→</a> <a id="11795" href="README.Nary.html#850" class="Generalizable">C</a> <a id="11797" class="Symbol">→</a> <a id="11799" href="README.Nary.html#864" class="Generalizable">D</a> <a id="11801" class="Symbol">→</a> <a id="11803" href="README.Nary.html#878" class="Generalizable">E</a> <a id="11805" class="Symbol">→</a> <a id="11807" href="README.Nary.html#822" class="Generalizable">A</a>
<a id="11809" href="README.Nary.html#11778" class="Function">const₁</a> <a id="11816" class="Symbol">=</a> <a id="11818" href="Function.Nary.NonDependent.Base.html#4541" class="Function">constₙ</a> <a id="11825" class="Number">4</a>

<a id="11828" class="Comment">-- Together with `holeₙ`, this means we can make a constant function out</a>
<a id="11901" class="Comment">-- of any of the arguments. The fourth for instance:</a>

<a id="const₂"></a><a id="11955" href="README.Nary.html#11955" class="Function">const₂</a> <a id="11962" class="Symbol">:</a> <a id="11964" href="README.Nary.html#822" class="Generalizable">A</a> <a id="11966" class="Symbol">→</a> <a id="11968" href="README.Nary.html#836" class="Generalizable">B</a> <a id="11970" class="Symbol">→</a> <a id="11972" href="README.Nary.html#850" class="Generalizable">C</a> <a id="11974" class="Symbol">→</a> <a id="11976" href="README.Nary.html#864" class="Generalizable">D</a> <a id="11978" class="Symbol">→</a> <a id="11980" href="README.Nary.html#878" class="Generalizable">E</a> <a id="11982" class="Symbol">→</a> <a id="11984" href="README.Nary.html#864" class="Generalizable">D</a>
<a id="11986" href="README.Nary.html#11955" class="Function">const₂</a> <a id="11993" class="Symbol">=</a> <a id="11995" href="Function.Nary.NonDependent.Base.html#4159" class="Function">holeₙ</a> <a id="12001" class="Number">3</a> <a id="12003" class="Symbol">(</a><a id="12004" href="Function.Nary.NonDependent.Base.html#4541" class="Function">constₙ</a> <a id="12011" class="Number">4</a><a id="12012" class="Symbol">)</a>

<a id="12015" class="Comment">------------------------------------------------------------------------</a>
<a id="12088" class="Comment">-- Generalised quantifiers</a>
<a id="12115" class="Comment">------------------------------------------------------------------------</a>

<a id="12189" class="Comment">-- As we have seen multiple times already, one of the advantages of working</a>
<a id="12265" class="Comment">-- with non-dependent products is that they can be easily inferred. This is</a>
<a id="12341" class="Comment">-- a prime opportunity to define generic quantifiers.</a>

<a id="12396" class="Comment">-- And because n-ary relations are Set-terminated, there is no ambiguity</a>
<a id="12469" class="Comment">-- where to split between arguments &amp; codomain. As a consequence Agda can</a>
<a id="12543" class="Comment">-- infer even `n`, the number of arguments. We can use notations which are</a>
<a id="12618" class="Comment">-- just like the ones defined in `Relation.Unary`.</a>

<a id="12670" class="Comment">------------------------------------------------------------------------</a>
<a id="12743" class="Comment">-- ∃⟨_⟩ : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="12783" class="Comment">-- ∃⟨ P ⟩ = ∃ λ a₁ → ⋯ → ∃ λ aₙ → P a₁ ⋯ aₙ</a>

<a id="12828" class="Comment">-- Returning to our favourite function taking a lot of arguments: we can</a>
<a id="12901" class="Comment">-- find a set of input for which it evaluates to 666</a>

<a id="exist₁"></a><a id="12955" href="README.Nary.html#12955" class="Function">exist₁</a> <a id="12962" class="Symbol">:</a> <a id="12964" href="Relation.Nary.html#2393" class="Function Operator">∃⟨</a> <a id="12967" class="Symbol">(λ</a> <a id="12970" href="README.Nary.html#12970" class="Bound">k</a> <a id="12972" href="README.Nary.html#12972" class="Bound">m</a> <a id="12974" href="README.Nary.html#12974" class="Bound">n</a> <a id="12976" href="README.Nary.html#12976" class="Bound">j</a> <a id="12978" class="Symbol">→</a> <a id="12980" href="Agda.Builtin.Nat.html#3023" class="Primitive">mod-helper</a> <a id="12991" href="README.Nary.html#12970" class="Bound">k</a> <a id="12993" href="README.Nary.html#12972" class="Bound">m</a> <a id="12995" href="README.Nary.html#12974" class="Bound">n</a> <a id="12997" href="README.Nary.html#12976" class="Bound">j</a> <a id="12999" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13001" class="Number">666</a><a id="13004" class="Symbol">)</a> <a id="13006" href="Relation.Nary.html#2393" class="Function Operator">⟩</a>
<a id="13008" href="README.Nary.html#12955" class="Function">exist₁</a> <a id="13015" class="Symbol">=</a> <a id="13017" class="Number">19</a> <a id="13020" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13022" class="Number">793</a> <a id="13026" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13028" class="Number">3059</a> <a id="13033" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13035" class="Number">10</a> <a id="13038" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="13040" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>

<a id="13046" class="Comment">------------------------------------------------------------------------</a>
<a id="13119" class="Comment">-- ∀[_] : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13159" class="Comment">-- ∀[_] P = ∀ {a₁} → ⋯ → ∀ {aₙ} → P a₁ ⋯ aₙ</a>

<a id="all₁"></a><a id="13204" href="README.Nary.html#13204" class="Function">all₁</a> <a id="13209" class="Symbol">:</a> <a id="13211" href="Relation.Nary.html#2669" class="Function Operator">∀[</a> <a id="13214" class="Symbol">(λ</a> <a id="13217" class="Symbol">(</a><a id="13218" href="README.Nary.html#13218" class="Bound">a₁</a> <a id="13221" href="README.Nary.html#13221" class="Bound">a₂</a> <a id="13224" class="Symbol">:</a> <a id="13226" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13227" class="Symbol">)</a> <a id="13229" class="Symbol">→</a> <a id="13231" href="Relation.Nullary.html#1520" class="Record">Dec</a> <a id="13235" class="Symbol">(</a><a id="13236" href="README.Nary.html#13218" class="Bound">a₁</a> <a id="13239" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13241" href="README.Nary.html#13221" class="Bound">a₂</a><a id="13243" class="Symbol">))</a> <a id="13246" href="Relation.Nary.html#2669" class="Function Operator">]</a>
<a id="13248" href="README.Nary.html#13204" class="Function">all₁</a> <a id="13253" class="Symbol">{</a><a id="13254" href="README.Nary.html#13254" class="Bound">a₁</a><a id="13256" class="Symbol">}</a> <a id="13258" class="Symbol">{</a><a id="13259" href="README.Nary.html#13259" class="Bound">a₂</a><a id="13261" class="Symbol">}</a> <a id="13263" class="Symbol">=</a> <a id="13265" href="README.Nary.html#13254" class="Bound">a₁</a> <a id="13268" href="Data.Nat.Properties.html#2945" class="Function Operator">≟</a> <a id="13270" href="README.Nary.html#13259" class="Bound">a₂</a>

<a id="13274" class="Comment">------------------------------------------------------------------------</a>
<a id="13347" class="Comment">-- Π : (A₁ → ⋯ → Aₙ → Set r) → Set _</a>
<a id="13384" class="Comment">-- Π P = ∀ a₁ → ⋯ → ∀ aₙ → P a₁ ⋯ aₙ</a>

<a id="all₂"></a><a id="13422" href="README.Nary.html#13422" class="Function">all₂</a> <a id="13427" class="Symbol">:</a> <a id="13429" href="Relation.Nary.html#2532" class="Function Operator">Π[</a> <a id="13432" class="Symbol">(λ</a> <a id="13435" class="Symbol">(</a><a id="13436" href="README.Nary.html#13436" class="Bound">a₁</a> <a id="13439" href="README.Nary.html#13439" class="Bound">a₂</a> <a id="13442" class="Symbol">:</a> <a id="13444" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13445" class="Symbol">)</a> <a id="13447" class="Symbol">→</a> <a id="13449" href="Relation.Nullary.html#1520" class="Record">Dec</a> <a id="13453" class="Symbol">(</a><a id="13454" href="README.Nary.html#13436" class="Bound">a₁</a> <a id="13457" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="13459" href="README.Nary.html#13439" class="Bound">a₂</a><a id="13461" class="Symbol">))</a> <a id="13464" href="Relation.Nary.html#2532" class="Function Operator">]</a>
<a id="13466" href="README.Nary.html#13422" class="Function">all₂</a> <a id="13471" class="Symbol">=</a> <a id="13473" href="Data.Nat.Properties.html#2945" class="Function Operator">_≟_</a>

<a id="13478" class="Comment">------------------------------------------------------------------------</a>
<a id="13551" class="Comment">-- _⇒_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13630" class="Comment">-- P ⇒ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ → Q a₁ ⋯ aₙ</a>

<a id="antisym"></a><a id="13682" href="README.Nary.html#13682" class="Function">antisym</a> <a id="13690" class="Symbol">:</a> <a id="13692" href="Relation.Nary.html#2669" class="Function Operator">∀[</a> <a id="13695" href="Data.Nat.Base.html#1473" class="Datatype Operator">_≤_</a> <a id="13699" href="Relation.Nary.html#5068" class="Function Operator">⇒</a> <a id="13701" href="Data.Nat.Base.html#1832" class="Function Operator">_≥_</a> <a id="13705" href="Relation.Nary.html#5068" class="Function Operator">⇒</a> <a id="13707" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">_≡_</a> <a id="13711" href="Relation.Nary.html#2669" class="Function Operator">]</a>
<a id="13713" href="README.Nary.html#13682" class="Function">antisym</a> <a id="13721" class="Symbol">=</a> <a id="13723" href="Data.Nat.Properties.html#4978" class="Function">≤-antisym</a>

<a id="13734" class="Comment">------------------------------------------------------------------------</a>
<a id="13807" class="Comment">-- _∪_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="13886" class="Comment">-- P ∪ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ ⊎ Q a₁ ⋯ aₙ</a>

<a id="≤-&gt;-connex"></a><a id="13938" href="README.Nary.html#13938" class="Function">≤-&gt;-connex</a> <a id="13949" class="Symbol">:</a> <a id="13951" href="Relation.Nary.html#2532" class="Function Operator">Π[</a> <a id="13954" href="Data.Nat.Base.html#1473" class="Datatype Operator">_≤_</a> <a id="13958" href="Relation.Nary.html#5358" class="Function Operator">∪</a> <a id="13960" href="Data.Nat.Base.html#1862" class="Function Operator">_&gt;_</a> <a id="13964" href="Relation.Nary.html#2532" class="Function Operator">]</a>
<a id="13966" href="README.Nary.html#13938" class="Function">≤-&gt;-connex</a> <a id="13977" href="README.Nary.html#13977" class="Bound">m</a> <a id="13979" href="README.Nary.html#13979" class="Bound">n</a> <a id="13981" class="Keyword">with</a> <a id="13986" href="Data.Nat.Properties.html#10322" class="Function">&lt;-cmp</a> <a id="13992" href="README.Nary.html#13977" class="Bound">m</a> <a id="13994" href="README.Nary.html#13979" class="Bound">n</a>
<a id="13996" class="Symbol">...</a> <a id="14000" class="Symbol">|</a> <a id="14002" href="Relation.Binary.Definitions.html#2787" class="InductiveConstructor">tri&lt;</a> <a id="14007" href="README.Nary.html#14007" class="Bound">a</a> <a id="14009" href="README.Nary.html#14009" class="Bound">¬b</a> <a id="14012" href="README.Nary.html#14012" class="Bound">¬c</a> <a id="14015" class="Symbol">=</a> <a id="14017" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="14022" class="Symbol">(</a><a id="14023" href="Data.Nat.Properties.html#8200" class="Function">&lt;⇒≤</a> <a id="14027" href="README.Nary.html#14007" class="Bound">a</a><a id="14028" class="Symbol">)</a>
<a id="14030" class="Symbol">...</a> <a id="14034" class="Symbol">|</a> <a id="14036" href="Relation.Binary.Definitions.html#2841" class="InductiveConstructor">tri≈</a> <a id="14041" href="README.Nary.html#14041" class="Bound">¬a</a> <a id="14044" href="README.Nary.html#14044" class="Bound">b</a> <a id="14046" href="README.Nary.html#14046" class="Bound">¬c</a> <a id="14049" class="Symbol">=</a> <a id="14051" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="14056" class="Symbol">(</a><a id="14057" href="Data.Nat.Properties.html#4822" class="Function">≤-reflexive</a> <a id="14069" href="README.Nary.html#14044" class="Bound">b</a><a id="14070" class="Symbol">)</a>
<a id="14072" class="Symbol">...</a> <a id="14076" class="Symbol">|</a> <a id="14078" href="Relation.Binary.Definitions.html#2895" class="InductiveConstructor">tri&gt;</a> <a id="14083" href="README.Nary.html#14083" class="Bound">¬a</a> <a id="14086" href="README.Nary.html#14086" class="Bound">¬b</a> <a id="14089" href="README.Nary.html#14089" class="Bound">c</a> <a id="14091" class="Symbol">=</a> <a id="14093" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="14098" href="README.Nary.html#14089" class="Bound">c</a>

<a id="14101" class="Comment">------------------------------------------------------------------------</a>
<a id="14174" class="Comment">-- _∩_ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set s) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14253" class="Comment">-- P ∩ Q = λ a₁ → ⋯ → λ aₙ → P a₁ ⋯ aₙ × Q a₁ ⋯ aₙ</a>

<a id="&lt;-inversion"></a><a id="14305" href="README.Nary.html#14305" class="Function">&lt;-inversion</a> <a id="14317" class="Symbol">:</a> <a id="14319" href="Relation.Nary.html#2669" class="Function Operator">∀[</a> <a id="14322" href="Data.Nat.Base.html#1583" class="Function Operator">_&lt;_</a> <a id="14326" href="Relation.Nary.html#5068" class="Function Operator">⇒</a> <a id="14328" href="Data.Nat.Base.html#1473" class="Datatype Operator">_≤_</a> <a id="14332" href="Relation.Nary.html#5219" class="Function Operator">∩</a> <a id="14334" href="Relation.Binary.PropositionalEquality.Core.html#839" class="Function Operator">_≢_</a> <a id="14338" href="Relation.Nary.html#2669" class="Function Operator">]</a>
<a id="14340" href="README.Nary.html#14305" class="Function">&lt;-inversion</a> <a id="14352" href="README.Nary.html#14352" class="Bound">m&lt;n</a> <a id="14356" class="Symbol">=</a> <a id="14358" href="Data.Nat.Properties.html#8200" class="Function">&lt;⇒≤</a> <a id="14362" href="README.Nary.html#14352" class="Bound">m&lt;n</a> <a id="14366" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14368" href="Data.Nat.Properties.html#8283" class="Function">&lt;⇒≢</a> <a id="14372" href="README.Nary.html#14352" class="Bound">m&lt;n</a>

<a id="14377" class="Comment">------------------------------------------------------------------------</a>
<a id="14450" class="Comment">-- ∁ : (A₁ → ⋯ → Aₙ → Set r) → (A₁ → ⋯ → Aₙ → Set _)</a>
<a id="14503" class="Comment">-- ∁ P = λ a₁ → ⋯ → λ aₙ → ¬ (P a₁ ⋯ aₙ)</a>

<a id="m&lt;n⇒m≱n"></a><a id="14545" href="README.Nary.html#14545" class="Function">m&lt;n⇒m≱n</a> <a id="14553" class="Symbol">:</a> <a id="14555" href="Relation.Nary.html#2669" class="Function Operator">∀[</a> <a id="14558" href="Data.Nat.Base.html#1862" class="Function Operator">_&gt;_</a> <a id="14562" href="Relation.Nary.html#5068" class="Function Operator">⇒</a> <a id="14564" href="Relation.Nary.html#5481" class="Function">∁</a> <a id="14566" href="Data.Nat.Base.html#1473" class="Datatype Operator">_≤_</a> <a id="14570" href="Relation.Nary.html#2669" class="Function Operator">]</a>
<a id="14572" href="README.Nary.html#14545" class="Function">m&lt;n⇒m≱n</a> <a id="14580" href="README.Nary.html#14580" class="Bound">m&gt;n</a> <a id="14584" href="README.Nary.html#14584" class="Bound">m≤n</a> <a id="14588" class="Symbol">=</a> <a id="14590" href="Data.Nat.Properties.html#8415" class="Function">&lt;⇒≱</a> <a id="14594" href="README.Nary.html#14580" class="Bound">m&gt;n</a> <a id="14598" href="README.Nary.html#14584" class="Bound">m≤n</a>
</pre></body></html>