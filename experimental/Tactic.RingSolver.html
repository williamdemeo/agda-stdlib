<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--cubical-compatible</a> <a id="305" class="Pragma">--safe</a> <a id="312" class="Symbol">#-}</a>

<a id="317" class="Keyword">module</a> <a id="324" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="342" class="Keyword">where</a>

<a id="349" class="Keyword">open</a> <a id="354" class="Keyword">import</a> <a id="361" href="Algebra.html" class="Module">Algebra</a>
<a id="369" class="Keyword">open</a> <a id="374" class="Keyword">import</a> <a id="381" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>   <a id="397" class="Symbol">as</a> <a id="400" class="Module">Fin</a>     <a id="408" class="Keyword">using</a> <a id="414" class="Symbol">(</a><a id="415" href="Data.Fin.Base.html#1212" class="Datatype">Fin</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>   <a id="448" class="Symbol">as</a> <a id="451" class="Module">Vec</a>     <a id="459" class="Keyword">using</a> <a id="465" class="Symbol">(</a><a id="466" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a><a id="469" class="Symbol">;</a> <a id="471" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">_∷_</a><a id="474" class="Symbol">;</a> <a id="476" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a><a id="478" class="Symbol">)</a>
<a id="480" class="Keyword">open</a> <a id="485" class="Keyword">import</a> <a id="492" href="Data.List.Base.html" class="Module">Data.List.Base</a>  <a id="508" class="Symbol">as</a> <a id="511" class="Module">List</a>    <a id="519" class="Keyword">using</a> <a id="525" class="Symbol">(</a><a id="526" href="Agda.Builtin.List.html#130" class="Datatype">List</a><a id="530" class="Symbol">;</a> <a id="532" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="535" class="Symbol">;</a> <a id="537" href="Data.List.Base.html#7191" class="InductiveConstructor">[]</a><a id="539" class="Symbol">)</a>
<a id="541" class="Keyword">open</a> <a id="546" class="Keyword">import</a> <a id="553" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="569" class="Symbol">as</a> <a id="572" class="Module">Maybe</a>   <a id="580" class="Keyword">using</a> <a id="586" class="Symbol">(</a><a id="587" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a><a id="592" class="Symbol">;</a> <a id="594" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a><a id="598" class="Symbol">;</a> <a id="600" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a><a id="607" class="Symbol">;</a> <a id="609" href="Data.Maybe.Base.html#1641" class="Function">fromMaybe</a><a id="618" class="Symbol">)</a>
<a id="620" class="Keyword">open</a> <a id="625" class="Keyword">import</a> <a id="632" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>              <a id="659" class="Keyword">using</a> <a id="665" class="Symbol">(</a><a id="666" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="667" class="Symbol">;</a> <a id="669" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="672" class="Symbol">;</a> <a id="674" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="678" class="Symbol">;</a> <a id="680" href="Data.Nat.Base.html#1239" class="Primitive Operator">_&lt;ᵇ_</a><a id="684" class="Symbol">)</a>
<a id="686" class="Keyword">open</a> <a id="691" class="Keyword">import</a> <a id="698" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>             <a id="725" class="Keyword">using</a> <a id="731" class="Symbol">(</a><a id="732" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="736" class="Symbol">;</a> <a id="738" href="Data.Bool.Base.html#1292" class="Function Operator">if_then_else_</a><a id="751" class="Symbol">;</a> <a id="753" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="757" class="Symbol">;</a> <a id="759" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="764" class="Symbol">)</a>
<a id="766" class="Keyword">open</a> <a id="771" class="Keyword">import</a> <a id="778" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>             <a id="805" class="Keyword">using</a> <a id="811" class="Symbol">(</a><a id="812" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a><a id="813" class="Symbol">)</a>
<a id="815" class="Keyword">open</a> <a id="820" class="Keyword">import</a> <a id="827" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="844" class="Symbol">as</a> <a id="847" class="Module">String</a> <a id="854" class="Keyword">using</a> <a id="860" class="Symbol">(</a><a id="861" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="867" class="Symbol">;</a> <a id="869" href="Data.String.Base.html#2413" class="Function Operator">_++_</a><a id="873" class="Symbol">;</a> <a id="875" href="Data.String.Base.html#2873" class="Function">parens</a><a id="881" class="Symbol">)</a>
<a id="883" class="Keyword">open</a> <a id="888" class="Keyword">import</a> <a id="895" href="Data.Product.html" class="Module">Data.Product</a>               <a id="922" class="Keyword">using</a> <a id="928" class="Symbol">(</a><a id="929" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="932" class="Symbol">;</a> <a id="934" href="Agda.Builtin.Sigma.html#234" class="Field">proj₁</a><a id="939" class="Symbol">)</a>
<a id="941" class="Keyword">open</a> <a id="946" class="Keyword">import</a> <a id="953" href="Function.html" class="Module">Function</a>
<a id="962" class="Keyword">open</a> <a id="967" class="Keyword">import</a> <a id="974" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="1002" class="Keyword">open</a> <a id="1007" class="Keyword">import</a> <a id="1014" href="Reflection.html" class="Module">Reflection</a>
<a id="1025" class="Keyword">open</a> <a id="1030" class="Keyword">import</a> <a id="1037" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="1061" class="Keyword">open</a> <a id="1066" class="Keyword">import</a> <a id="1073" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a> <a id="1093" class="Symbol">as</a> <a id="1096" class="Module">Term</a>
<a id="1101" class="Keyword">open</a> <a id="1106" class="Keyword">import</a> <a id="1113" href="Reflection.AST.AlphaEquality.html" class="Module">Reflection.AST.AlphaEquality</a>
<a id="1142" class="Keyword">open</a> <a id="1147" class="Keyword">import</a> <a id="1154" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="1174" class="Symbol">as</a> <a id="1177" class="Module">Name</a>
<a id="1182" class="Keyword">open</a> <a id="1187" class="Keyword">import</a> <a id="1194" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>
<a id="1216" class="Keyword">open</a> <a id="1221" class="Keyword">import</a> <a id="1228" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a>
<a id="1248" class="Keyword">open</a> <a id="1253" class="Keyword">import</a> <a id="1260" href="Data.List.Reflection.html" class="Module">Data.List.Reflection</a>
<a id="1281" class="Keyword">import</a> <a id="1288" href="Data.Vec.Reflection.html" class="Module">Data.Vec.Reflection</a> <a id="1308" class="Symbol">as</a> <a id="1311" class="Module">Vec</a>

<a id="1316" class="Keyword">open</a> <a id="1321" class="Keyword">import</a> <a id="1328" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1360" class="Keyword">renaming</a> <a id="1369" class="Symbol">(</a><a id="1370" href="Tactic.RingSolver.NonReflective.html#2962" class="Function">solve</a> <a id="1376" class="Symbol">to</a> <a id="1379" class="Function">solver</a><a id="1385" class="Symbol">)</a>
<a id="1387" class="Keyword">open</a> <a id="1392" class="Keyword">import</a> <a id="1399" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1444" class="Keyword">open</a> <a id="1449" class="Keyword">import</a> <a id="1456" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1486" class="Symbol">as</a> <a id="1489" class="Module">NatSet</a>

<a id="1497" class="Keyword">open</a> <a id="1502" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1258" class="Module">AlmostCommutativeRing</a>

<a id="1525" class="Comment">------------------------------------------------------------------------</a>
<a id="1598" class="Comment">-- Utilities</a>

<a id="1612" class="Keyword">private</a>
  <a id="VarMap"></a><a id="1622" href="Tactic.RingSolver.html#1622" class="Function">VarMap</a> <a id="1629" class="Symbol">:</a> <a id="1631" href="Agda.Primitive.html#320" class="Primitive">Set</a>
  <a id="1637" href="Tactic.RingSolver.html#1622" class="Function">VarMap</a> <a id="1644" class="Symbol">=</a> <a id="1646" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1648" class="Symbol">→</a> <a id="1650" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1656" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>

  <a id="getVisible"></a><a id="1664" href="Tactic.RingSolver.html#1664" class="Function">getVisible</a> <a id="1675" class="Symbol">:</a> <a id="1677" href="Agda.Builtin.Reflection.html#3679" class="Datatype">Arg</a> <a id="1681" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="1686" class="Symbol">→</a> <a id="1688" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1694" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="1701" href="Tactic.RingSolver.html#1664" class="Function">getVisible</a> <a id="1712" class="Symbol">(</a><a id="1713" href="Agda.Builtin.Reflection.html#3715" class="InductiveConstructor">arg</a> <a id="1717" class="Symbol">(</a><a id="1718" href="Agda.Builtin.Reflection.html#3620" class="InductiveConstructor">arg-info</a> <a id="1727" href="Agda.Builtin.Reflection.html#2745" class="InductiveConstructor">visible</a> <a id="1735" class="Symbol">_)</a> <a id="1738" href="Tactic.RingSolver.html#1738" class="Bound">x</a><a id="1739" class="Symbol">)</a> <a id="1741" class="Symbol">=</a> <a id="1743" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="1748" href="Tactic.RingSolver.html#1738" class="Bound">x</a>
  <a id="1752" href="Tactic.RingSolver.html#1664" class="CatchallClause Function">getVisible</a><a id="1762" class="CatchallClause"> </a><a id="1763" class="CatchallClause Symbol">_</a>                            <a id="1792" class="Symbol">=</a> <a id="1794" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

  <a id="getVisibleArgs"></a><a id="1805" href="Tactic.RingSolver.html#1805" class="Function">getVisibleArgs</a> <a id="1820" class="Symbol">:</a> <a id="1822" class="Symbol">∀</a> <a id="1824" href="Tactic.RingSolver.html#1824" class="Bound">n</a> <a id="1826" class="Symbol">→</a> <a id="1828" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="1833" class="Symbol">→</a> <a id="1835" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1841" class="Symbol">(</a><a id="1842" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a> <a id="1846" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="1851" href="Tactic.RingSolver.html#1824" class="Bound">n</a><a id="1852" class="Symbol">)</a>
  <a id="1856" href="Tactic.RingSolver.html#1805" class="Function">getVisibleArgs</a> <a id="1871" href="Tactic.RingSolver.html#1871" class="Bound">n</a> <a id="1873" class="Symbol">(</a><a id="1874" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="1878" class="Symbol">_</a> <a id="1880" href="Tactic.RingSolver.html#1880" class="Bound">xs</a><a id="1882" class="Symbol">)</a> <a id="1884" class="Symbol">=</a> <a id="1886" href="Data.Maybe.Base.html#2029" class="Function">Maybe.map</a> <a id="1896" href="Data.Vec.Base.html#8875" class="Function">Vec.reverse</a>
    <a id="1912" class="Symbol">(</a><a id="1913" href="Data.List.Base.html#4317" class="Function">List.foldl</a> <a id="1924" href="Tactic.RingSolver.html#1975" class="Function">f</a> <a id="1926" href="Tactic.RingSolver.html#2119" class="Function">c</a> <a id="1928" class="Symbol">(</a><a id="1929" href="Data.List.Base.html#1657" class="Function">List.mapMaybe</a> <a id="1943" href="Tactic.RingSolver.html#1664" class="Function">getVisible</a> <a id="1954" href="Tactic.RingSolver.html#1880" class="Bound">xs</a><a id="1956" class="Symbol">)</a> <a id="1958" href="Tactic.RingSolver.html#1871" class="Bound">n</a><a id="1959" class="Symbol">)</a>
    <a id="1965" class="Keyword">where</a>
    <a id="1975" href="Tactic.RingSolver.html#1975" class="Function">f</a> <a id="1977" class="Symbol">:</a> <a id="1979" class="Symbol">(∀</a> <a id="1982" href="Tactic.RingSolver.html#1982" class="Bound">n</a> <a id="1984" class="Symbol">→</a> <a id="1986" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1992" class="Symbol">(</a><a id="1993" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a> <a id="1997" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2002" href="Tactic.RingSolver.html#1982" class="Bound">n</a><a id="2003" class="Symbol">))</a> <a id="2006" class="Symbol">→</a> <a id="2008" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2013" class="Symbol">→</a> <a id="2015" class="Symbol">∀</a> <a id="2017" href="Tactic.RingSolver.html#2017" class="Bound">n</a> <a id="2019" class="Symbol">→</a> <a id="2021" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="2027" class="Symbol">(</a><a id="2028" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a> <a id="2032" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2037" href="Tactic.RingSolver.html#2017" class="Bound">n</a><a id="2038" class="Symbol">)</a>
    <a id="2044" href="Tactic.RingSolver.html#1975" class="Function">f</a> <a id="2046" href="Tactic.RingSolver.html#2046" class="Bound">xs</a> <a id="2049" href="Tactic.RingSolver.html#2049" class="Bound">x</a> <a id="2051" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="2059" class="Symbol">=</a> <a id="2061" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2066" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a>
    <a id="2073" href="Tactic.RingSolver.html#1975" class="Function">f</a> <a id="2075" href="Tactic.RingSolver.html#2075" class="Bound">xs</a> <a id="2078" href="Tactic.RingSolver.html#2078" class="Bound">x</a> <a id="2080" class="Symbol">(</a><a id="2081" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2085" href="Tactic.RingSolver.html#2085" class="Bound">n</a><a id="2086" class="Symbol">)</a> <a id="2088" class="Symbol">=</a> <a id="2090" href="Data.Maybe.Base.html#2029" class="Function">Maybe.map</a> <a id="2100" class="Symbol">(</a><a id="2101" href="Tactic.RingSolver.html#2078" class="Bound">x</a> <a id="2103" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷_</a><a id="2105" class="Symbol">)</a> <a id="2107" class="Symbol">(</a><a id="2108" href="Tactic.RingSolver.html#2075" class="Bound">xs</a> <a id="2111" href="Tactic.RingSolver.html#2085" class="Bound">n</a><a id="2112" class="Symbol">)</a>

    <a id="2119" href="Tactic.RingSolver.html#2119" class="Function">c</a> <a id="2121" class="Symbol">:</a> <a id="2123" class="Symbol">∀</a> <a id="2125" href="Tactic.RingSolver.html#2125" class="Bound">n</a> <a id="2127" class="Symbol">→</a> <a id="2129" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="2135" class="Symbol">(</a><a id="2136" href="Data.Vec.Base.html#1066" class="Datatype">Vec</a> <a id="2140" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2145" href="Tactic.RingSolver.html#2125" class="Bound">n</a><a id="2146" class="Symbol">)</a>
    <a id="2152" href="Tactic.RingSolver.html#2119" class="Function">c</a> <a id="2154" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="2163" class="Symbol">=</a> <a id="2165" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2170" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a>
    <a id="2177" href="Tactic.RingSolver.html#2119" class="Function">c</a> <a id="2179" class="Symbol">(</a><a id="2180" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2184" class="Symbol">_</a> <a id="2186" class="Symbol">)</a> <a id="2188" class="Symbol">=</a> <a id="2190" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
  <a id="2200" href="Tactic.RingSolver.html#1805" class="CatchallClause Function">getVisibleArgs</a><a id="2214" class="CatchallClause"> </a><a id="2215" class="CatchallClause Symbol">_</a><a id="2216" class="CatchallClause"> </a><a id="2217" class="CatchallClause Symbol">_</a> <a id="2219" class="Symbol">=</a> <a id="2221" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

  <a id="curriedTerm"></a><a id="2232" href="Tactic.RingSolver.html#2232" class="Function">curriedTerm</a> <a id="2244" class="Symbol">:</a> <a id="2246" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a> <a id="2253" class="Symbol">→</a> <a id="2255" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="2262" href="Tactic.RingSolver.html#2232" class="Function">curriedTerm</a> <a id="2274" class="Symbol">=</a> <a id="2276" href="Data.List.Base.html#4216" class="Function">List.foldr</a> <a id="2287" href="Tactic.RingSolver.html#2328" class="Function">go</a> <a id="2290" href="Data.Vec.Reflection.html#679" class="Function">Vec.`[]</a> <a id="2298" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2300" href="Tactic.RingSolver.Core.NatSet.html#3299" class="Function">NatSet.toList</a>
    <a id="2318" class="Keyword">where</a>
    <a id="2328" href="Tactic.RingSolver.html#2328" class="Function">go</a> <a id="2331" class="Symbol">:</a> <a id="2333" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2335" class="Symbol">→</a> <a id="2337" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2342" class="Symbol">→</a> <a id="2344" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
    <a id="2353" href="Tactic.RingSolver.html#2328" class="Function">go</a> <a id="2356" href="Tactic.RingSolver.html#2356" class="Bound">x</a> <a id="2358" href="Tactic.RingSolver.html#2358" class="Bound">xs</a> <a id="2361" class="Symbol">=</a> <a id="2363" href="Agda.Builtin.Reflection.html#4815" class="InductiveConstructor">var</a> <a id="2367" href="Tactic.RingSolver.html#2356" class="Bound">x</a> <a id="2369" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a> <a id="2372" href="Data.Vec.Reflection.html#729" class="Function Operator">Vec.`∷</a> <a id="2379" href="Tactic.RingSolver.html#2358" class="Bound">xs</a>

<a id="2383" class="Comment">------------------------------------------------------------------------</a>
<a id="2456" class="Comment">-- Reflection utilities for rings</a>

<a id="`AlmostCommutativeRing"></a><a id="2491" href="Tactic.RingSolver.html#2491" class="Function">`AlmostCommutativeRing</a> <a id="2514" class="Symbol">:</a> <a id="2516" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="2521" href="Tactic.RingSolver.html#2491" class="Function">`AlmostCommutativeRing</a> <a id="2544" class="Symbol">=</a> <a id="2546" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="2550" class="Symbol">(</a><a id="2551" class="Keyword">quote</a> <a id="2557" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1258" class="Record">AlmostCommutativeRing</a><a id="2578" class="Symbol">)</a> <a id="2580" class="Symbol">(</a><a id="2581" class="Number">2</a> <a id="2583" href="Reflection.AST.Term.html#2528" class="Function Operator">⋯⟨∷⟩</a> <a id="2588" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="2590" class="Symbol">)</a>

<a id="2593" class="Keyword">record</a> <a id="RingOperatorTerms"></a><a id="2600" href="Tactic.RingSolver.html#2600" class="Record">RingOperatorTerms</a> <a id="2618" class="Symbol">:</a> <a id="2620" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2624" class="Keyword">where</a>
  <a id="2632" class="Keyword">constructor</a> <a id="add⇒_mul⇒_pow⇒_neg⇒_sub⇒_"></a><a id="2644" href="Tactic.RingSolver.html#2644" class="InductiveConstructor Operator">add⇒_mul⇒_pow⇒_neg⇒_sub⇒_</a>
  <a id="2672" class="Keyword">field</a>
    <a id="RingOperatorTerms.add"></a><a id="2682" href="Tactic.RingSolver.html#2682" class="Field">add</a> <a id="RingOperatorTerms.mul"></a><a id="2686" href="Tactic.RingSolver.html#2686" class="Field">mul</a> <a id="RingOperatorTerms.pow"></a><a id="2690" href="Tactic.RingSolver.html#2690" class="Field">pow</a> <a id="RingOperatorTerms.neg"></a><a id="2694" href="Tactic.RingSolver.html#2694" class="Field">neg</a> <a id="RingOperatorTerms.sub"></a><a id="2698" href="Tactic.RingSolver.html#2698" class="Field">sub</a> <a id="2702" class="Symbol">:</a> <a id="2704" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>

<a id="checkIsRing"></a><a id="2710" href="Tactic.RingSolver.html#2710" class="Function">checkIsRing</a> <a id="2722" class="Symbol">:</a> <a id="2724" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2729" class="Symbol">→</a> <a id="2731" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="2734" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="2739" href="Tactic.RingSolver.html#2710" class="Function">checkIsRing</a> <a id="2751" href="Tactic.RingSolver.html#2751" class="Bound">ring</a> <a id="2756" class="Symbol">=</a> <a id="2758" href="Agda.Builtin.Reflection.html#8591" class="Postulate">checkType</a> <a id="2768" href="Tactic.RingSolver.html#2751" class="Bound">ring</a> <a id="2773" href="Tactic.RingSolver.html#2491" class="Function">`AlmostCommutativeRing</a>

<a id="2797" class="Keyword">module</a> <a id="RingReflection"></a><a id="2804" href="Tactic.RingSolver.html#2804" class="Module">RingReflection</a> <a id="2819" class="Symbol">(</a><a id="2820" href="Tactic.RingSolver.html#2820" class="Bound">`ring</a> <a id="2826" class="Symbol">:</a> <a id="2828" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="2832" class="Symbol">)</a> <a id="2834" class="Keyword">where</a>

  <a id="2843" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
  <a id="2911" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
  <a id="2978" class="Comment">-- the required ring arguments</a>
  <a id="3011" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
  <a id="3059" class="Keyword">infixr</a> <a id="3066" class="Number">6</a> <a id="3068" href="Tactic.RingSolver.html#3075" class="Function Operator">_$ʳ_</a>
  <a id="RingReflection._$ʳ_"></a><a id="3075" href="Tactic.RingSolver.html#3075" class="Function Operator">_$ʳ_</a> <a id="3080" class="Symbol">:</a> <a id="3082" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="3087" class="Symbol">→</a> <a id="3089" href="Reflection.AST.Argument.html#1547" class="Function">Args</a> <a id="3094" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="3099" class="Symbol">→</a> <a id="3101" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3108" href="Tactic.RingSolver.html#3108" class="Bound">nm</a> <a id="3111" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3114" href="Tactic.RingSolver.html#3114" class="Bound">args</a> <a id="3119" class="Symbol">=</a> <a id="3121" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="3125" href="Tactic.RingSolver.html#3108" class="Bound">nm</a> <a id="3128" class="Symbol">(</a><a id="3129" class="Number">2</a> <a id="3131" href="Reflection.AST.Term.html#2841" class="Function Operator">⋯⟅∷⟆</a> <a id="3136" href="Tactic.RingSolver.html#2820" class="Bound">`ring</a> <a id="3142" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3146" href="Tactic.RingSolver.html#3114" class="Bound">args</a><a id="3150" class="Symbol">)</a>

  <a id="RingReflection.`Carrier"></a><a id="3155" href="Tactic.RingSolver.html#3155" class="Function">`Carrier</a> <a id="3164" class="Symbol">:</a> <a id="3166" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3173" href="Tactic.RingSolver.html#3155" class="Function">`Carrier</a> <a id="3182" class="Symbol">=</a> <a id="3184" class="Keyword">quote</a> <a id="3190" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1396" class="Field">Carrier</a> <a id="3198" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3201" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>

  <a id="RingReflection.`refl"></a><a id="3207" href="Tactic.RingSolver.html#3207" class="Function">`refl</a> <a id="3213" class="Symbol">:</a> <a id="3215" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3222" href="Tactic.RingSolver.html#3207" class="Function">`refl</a> <a id="3228" class="Symbol">=</a> <a id="3230" class="Keyword">quote</a> <a id="3236" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2559" class="Function">refl</a> <a id="3241" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3244" class="Symbol">(</a><a id="3245" class="Number">1</a> <a id="3247" href="Reflection.AST.Term.html#2841" class="Function Operator">⋯⟅∷⟆</a> <a id="3252" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3254" class="Symbol">)</a>

  <a id="RingReflection.`sym"></a><a id="3259" href="Tactic.RingSolver.html#3259" class="Function">`sym</a> <a id="3264" class="Symbol">:</a> <a id="3266" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="3271" class="Symbol">→</a> <a id="3273" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3280" href="Tactic.RingSolver.html#3259" class="Function">`sym</a> <a id="3285" href="Tactic.RingSolver.html#3285" class="Bound">x≈y</a> <a id="3289" class="Symbol">=</a> <a id="3291" class="Keyword">quote</a> <a id="3297" href="Relation.Binary.Structures.html#1603" class="Function">sym</a> <a id="3301" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3304" class="Symbol">(</a><a id="3305" class="Number">2</a> <a id="3307" href="Reflection.AST.Term.html#2841" class="Function Operator">⋯⟅∷⟆</a> <a id="3312" href="Tactic.RingSolver.html#3285" class="Bound">x≈y</a> <a id="3316" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3320" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3322" class="Symbol">)</a>

  <a id="RingReflection.`trans"></a><a id="3327" href="Tactic.RingSolver.html#3327" class="Function">`trans</a> <a id="3334" class="Symbol">:</a> <a id="3336" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="3341" class="Symbol">→</a> <a id="3343" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="3348" class="Symbol">→</a> <a id="3350" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3357" href="Tactic.RingSolver.html#3327" class="Function">`trans</a> <a id="3364" href="Tactic.RingSolver.html#3364" class="Bound">x≈y</a> <a id="3368" href="Tactic.RingSolver.html#3368" class="Bound">y≈z</a> <a id="3372" class="Symbol">=</a> <a id="3374" class="Keyword">quote</a> <a id="3380" href="Relation.Binary.Structures.html#1629" class="Function">trans</a> <a id="3386" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3389" class="Symbol">(</a><a id="3390" class="Number">3</a> <a id="3392" href="Reflection.AST.Term.html#2841" class="Function Operator">⋯⟅∷⟆</a> <a id="3397" href="Tactic.RingSolver.html#3364" class="Bound">x≈y</a> <a id="3401" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3405" href="Tactic.RingSolver.html#3368" class="Bound">y≈z</a> <a id="3409" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3413" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3415" class="Symbol">)</a>

  <a id="3420" class="Comment">-- Normalises each of the fields of the ring operator so we can</a>
  <a id="3486" class="Comment">-- compare the result against the normalised definitions we come</a>
  <a id="3553" class="Comment">-- across when converting the term passed to the macro.</a>
  <a id="RingReflection.getRingOperatorTerms"></a><a id="3611" href="Tactic.RingSolver.html#3611" class="Function">getRingOperatorTerms</a> <a id="3632" class="Symbol">:</a> <a id="3634" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="3637" href="Tactic.RingSolver.html#2600" class="Record">RingOperatorTerms</a>
  <a id="3657" href="Tactic.RingSolver.html#3611" class="Function">getRingOperatorTerms</a> <a id="3678" class="Symbol">=</a> <a id="3680" class="Symbol">⦇</a>
    <a id="3686" href="Tactic.RingSolver.html#2644" class="InductiveConstructor Operator">add⇒</a> <a id="3691" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3701" class="Symbol">(</a><a id="3702" class="Keyword">quote</a> <a id="3708" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1476" class="Field Operator">_+_</a>  <a id="3713" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3716" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3718" class="Symbol">)</a>
    <a id="3724" href="Tactic.RingSolver.html#2644" class="InductiveConstructor Operator">mul⇒</a> <a id="3729" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3739" class="Symbol">(</a><a id="3740" class="Keyword">quote</a> <a id="3746" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1518" class="Field Operator">_*_</a>  <a id="3751" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3754" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3756" class="Symbol">)</a>
    <a id="3762" href="Tactic.RingSolver.html#2644" class="InductiveConstructor Operator">pow⇒</a> <a id="3767" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3777" class="Symbol">(</a><a id="3778" class="Keyword">quote</a> <a id="3784" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2417" class="Function Operator">_^_</a>  <a id="3789" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3792" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3794" class="Symbol">)</a>
    <a id="3800" href="Tactic.RingSolver.html#2644" class="InductiveConstructor Operator">neg⇒</a> <a id="3805" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3815" class="Symbol">(</a><a id="3816" class="Keyword">quote</a> <a id="3822" class="Symbol">(</a><a id="3823" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1560" class="Field Operator">-_</a><a id="3825" class="Symbol">)</a> <a id="3827" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3830" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3832" class="Symbol">)</a>
    <a id="3838" href="Tactic.RingSolver.html#2644" class="InductiveConstructor Operator">sub⇒</a> <a id="3843" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3853" class="Symbol">(</a><a id="3854" class="Keyword">quote</a> <a id="3860" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2500" class="Function Operator">_-_</a>  <a id="3865" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="3868" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3870" class="Symbol">)</a>
    <a id="3876" class="Symbol">⦈</a>

<a id="3879" class="Comment">------------------------------------------------------------------------</a>
<a id="3952" class="Comment">-- Reflection utilities for ring solver</a>

<a id="3993" class="Keyword">module</a> <a id="RingSolverReflection"></a><a id="4000" href="Tactic.RingSolver.html#4000" class="Module">RingSolverReflection</a> <a id="4021" class="Symbol">(</a><a id="4022" href="Tactic.RingSolver.html#4022" class="Bound">ring</a> <a id="4027" class="Symbol">:</a> <a id="4029" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="4033" class="Symbol">)</a> <a id="4035" class="Symbol">(</a><a id="4036" href="Tactic.RingSolver.html#4036" class="Bound">numberOfVariables</a> <a id="4054" class="Symbol">:</a> <a id="4056" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4057" class="Symbol">)</a> <a id="4059" class="Keyword">where</a>
  <a id="4067" class="Keyword">open</a> <a id="4072" href="Tactic.RingSolver.html#2804" class="Module">RingReflection</a> <a id="4087" href="Tactic.RingSolver.html#4022" class="Bound">ring</a>

  <a id="RingSolverReflection.`numberOfVariables"></a><a id="4095" href="Tactic.RingSolver.html#4095" class="Function">`numberOfVariables</a> <a id="4114" class="Symbol">:</a> <a id="4116" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4123" href="Tactic.RingSolver.html#4095" class="Function">`numberOfVariables</a> <a id="4142" class="Symbol">=</a> <a id="4144" href="Data.Nat.Reflection.html#653" class="Function">toTerm</a> <a id="4151" href="Tactic.RingSolver.html#4036" class="Bound">numberOfVariables</a>

  <a id="4172" class="Comment">-- This function applies the hidden arguments that the constructors</a>
  <a id="4242" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
  <a id="4315" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
  <a id="4384" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
  <a id="4453" class="Comment">-- make things easier we supply the third because we know it.</a>
  <a id="4517" class="Keyword">infix</a> <a id="4523" class="Number">-1</a> <a id="4526" href="Tactic.RingSolver.html#4533" class="Function Operator">_$ᵉ_</a>
  <a id="RingSolverReflection._$ᵉ_"></a><a id="4533" href="Tactic.RingSolver.html#4533" class="Function Operator">_$ᵉ_</a> <a id="4538" class="Symbol">:</a> <a id="4540" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="4545" class="Symbol">→</a> <a id="4547" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="4552" class="Symbol">(</a><a id="4553" href="Agda.Builtin.Reflection.html#3679" class="Datatype">Arg</a> <a id="4557" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="4561" class="Symbol">)</a> <a id="4563" class="Symbol">→</a> <a id="4565" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4572" href="Tactic.RingSolver.html#4572" class="Bound">e</a> <a id="4574" href="Tactic.RingSolver.html#4533" class="Function Operator">$ᵉ</a> <a id="4577" href="Tactic.RingSolver.html#4577" class="Bound">xs</a> <a id="4580" class="Symbol">=</a> <a id="4582" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="4586" href="Tactic.RingSolver.html#4572" class="Bound">e</a> <a id="4588" class="Symbol">(</a><a id="4589" class="Number">1</a> <a id="4591" href="Reflection.AST.Term.html#2841" class="Function Operator">⋯⟅∷⟆</a> <a id="4596" href="Tactic.RingSolver.html#3155" class="Function">`Carrier</a> <a id="4605" href="Reflection.AST.Argument.html#1760" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4609" href="Tactic.RingSolver.html#4095" class="Function">`numberOfVariables</a> <a id="4628" href="Reflection.AST.Argument.html#1760" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4632" href="Tactic.RingSolver.html#4577" class="Bound">xs</a><a id="4634" class="Symbol">)</a>

  <a id="4639" class="Comment">-- A constant expression.</a>
  <a id="RingSolverReflection.`Κ"></a><a id="4667" href="Tactic.RingSolver.html#4667" class="Function">`Κ</a> <a id="4670" class="Symbol">:</a> <a id="4672" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4677" class="Symbol">→</a> <a id="4679" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4686" href="Tactic.RingSolver.html#4667" class="Function">`Κ</a> <a id="4689" href="Tactic.RingSolver.html#4689" class="Bound">x</a> <a id="4691" class="Symbol">=</a> <a id="4693" class="Keyword">quote</a> <a id="4699" href="Tactic.RingSolver.Core.Expression.html#547" class="InductiveConstructor">Κ</a> <a id="4701" href="Tactic.RingSolver.html#4533" class="Function Operator">$ᵉ</a> <a id="4704" class="Symbol">(</a><a id="4705" href="Tactic.RingSolver.html#4689" class="Bound">x</a> <a id="4707" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4711" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="4713" class="Symbol">)</a>

  <a id="RingSolverReflection.`I"></a><a id="4718" href="Tactic.RingSolver.html#4718" class="Function">`I</a> <a id="4721" class="Symbol">:</a> <a id="4723" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4728" class="Symbol">→</a> <a id="4730" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4737" href="Tactic.RingSolver.html#4718" class="Function">`I</a> <a id="4740" href="Tactic.RingSolver.html#4740" class="Bound">x</a> <a id="4742" class="Symbol">=</a> <a id="4744" class="Keyword">quote</a> <a id="4750" href="Tactic.RingSolver.Core.Expression.html#598" class="InductiveConstructor">Ι</a> <a id="4752" href="Tactic.RingSolver.html#4533" class="Function Operator">$ᵉ</a> <a id="4755" class="Symbol">(</a><a id="4756" href="Tactic.RingSolver.html#4740" class="Bound">x</a> <a id="4758" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4762" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="4764" class="Symbol">)</a>

  <a id="RingSolverReflection._`⊜_"></a><a id="4769" href="Tactic.RingSolver.html#4769" class="Function Operator">_`⊜_</a> <a id="4774" class="Symbol">:</a> <a id="4776" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4781" class="Symbol">→</a> <a id="4783" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4788" class="Symbol">→</a> <a id="4790" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4797" href="Tactic.RingSolver.html#4797" class="Bound">x</a> <a id="4799" href="Tactic.RingSolver.html#4769" class="Function Operator">`⊜</a> <a id="4802" href="Tactic.RingSolver.html#4802" class="Bound">y</a> <a id="4804" class="Symbol">=</a> <a id="4806" class="Keyword">quote</a> <a id="4812" href="Tactic.RingSolver.NonReflective.html#3324" class="Function Operator">_⊜_</a>  <a id="4817" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="4820" class="Symbol">(</a><a id="4821" href="Tactic.RingSolver.html#4095" class="Function">`numberOfVariables</a> <a id="4840" href="Reflection.AST.Argument.html#1760" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4844" href="Tactic.RingSolver.html#4797" class="Bound">x</a> <a id="4846" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4850" href="Tactic.RingSolver.html#4802" class="Bound">y</a> <a id="4852" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4856" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="4858" class="Symbol">)</a>

  <a id="RingSolverReflection.`correct"></a><a id="4863" href="Tactic.RingSolver.html#4863" class="Function">`correct</a> <a id="4872" class="Symbol">:</a> <a id="4874" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4879" class="Symbol">→</a> <a id="4881" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4886" class="Symbol">→</a> <a id="4888" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4895" href="Tactic.RingSolver.html#4863" class="Function">`correct</a> <a id="4904" href="Tactic.RingSolver.html#4904" class="Bound">x</a> <a id="4906" href="Tactic.RingSolver.html#4906" class="Bound">ρ</a> <a id="4908" class="Symbol">=</a> <a id="4910" class="Keyword">quote</a> <a id="4916" href="Tactic.RingSolver.NonReflective.html#2298" class="Function">Ops.correct</a> <a id="4928" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="4931" class="Symbol">(</a><a id="4932" class="Number">1</a> <a id="4934" href="Reflection.AST.Term.html#2841" class="Function Operator">⋯⟅∷⟆</a> <a id="4939" href="Tactic.RingSolver.html#4904" class="Bound">x</a> <a id="4941" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4945" href="Tactic.RingSolver.html#4906" class="Bound">ρ</a> <a id="4947" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4951" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="4953" class="Symbol">)</a>

  <a id="RingSolverReflection.`solver"></a><a id="4958" href="Tactic.RingSolver.html#4958" class="Function">`solver</a> <a id="4966" class="Symbol">:</a> <a id="4968" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4973" class="Symbol">→</a> <a id="4975" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4980" class="Symbol">→</a> <a id="4982" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4989" href="Tactic.RingSolver.html#4958" class="Function">`solver</a> <a id="4997" href="Tactic.RingSolver.html#4997" class="Bound">`f</a> <a id="5000" href="Tactic.RingSolver.html#5000" class="Bound">`eq</a> <a id="5004" class="Symbol">=</a> <a id="5006" class="Keyword">quote</a> <a id="5012" href="Tactic.RingSolver.html#1379" class="Function">solver</a> <a id="5019" href="Tactic.RingSolver.html#3075" class="Function Operator">$ʳ</a> <a id="5022" class="Symbol">(</a><a id="5023" href="Tactic.RingSolver.html#4095" class="Function">`numberOfVariables</a> <a id="5042" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5046" href="Tactic.RingSolver.html#4997" class="Bound">`f</a> <a id="5049" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5053" href="Tactic.RingSolver.html#5000" class="Bound">`eq</a> <a id="5057" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5061" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="5063" class="Symbol">)</a>

  <a id="5068" class="Comment">-- Converts the raw terms provided by the macro into the `Expr`s</a>
  <a id="5135" class="Comment">-- used internally by the solver.</a>
  <a id="5171" class="Comment">--</a>
  <a id="5176" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
  <a id="5242" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
  <a id="5305" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
  <a id="5371" class="Comment">-- might look for its constructors: however, we want to deal with</a>
  <a id="5439" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
  <a id="5506" class="Comment">-- Term type contained type information we might be able to</a>
  <a id="5568" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
  <a id="5609" class="Comment">--</a>
  <a id="5614" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
  <a id="5683" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
  <a id="5751" class="Comment">-- will just assume that it has a constant expression.</a>
  <a id="RingSolverReflection.convertTerm"></a><a id="5808" href="Tactic.RingSolver.html#5808" class="Function">convertTerm</a> <a id="5820" class="Symbol">:</a> <a id="5822" href="Tactic.RingSolver.html#2600" class="Record">RingOperatorTerms</a> <a id="5840" class="Symbol">→</a> <a id="5842" href="Tactic.RingSolver.html#1622" class="Function">VarMap</a> <a id="5849" class="Symbol">→</a> <a id="5851" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="5856" class="Symbol">→</a> <a id="5858" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="5861" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="5868" href="Tactic.RingSolver.html#5808" class="Function">convertTerm</a> <a id="5880" href="Tactic.RingSolver.html#5880" class="Bound">operatorTerms</a> <a id="5894" href="Tactic.RingSolver.html#5894" class="Bound">varMap</a> <a id="5901" class="Symbol">=</a> <a id="5903" href="Tactic.RingSolver.html#5980" class="Function">convert</a>
    <a id="5915" class="Keyword">where</a>
    <a id="5925" class="Keyword">open</a> <a id="5930" href="Tactic.RingSolver.html#2600" class="Module">RingOperatorTerms</a> <a id="5948" href="Tactic.RingSolver.html#5880" class="Bound">operatorTerms</a>

    <a id="5967" class="Keyword">mutual</a>
      <a id="5980" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="5988" class="Symbol">:</a> <a id="5990" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="5995" class="Symbol">→</a> <a id="5997" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="6000" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="6011" class="Comment">-- First try and match directly against the fields</a>
      <a id="6068" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="6076" class="Symbol">(</a><a id="6077" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6081" class="Symbol">(</a><a id="6082" class="Keyword">quote</a> <a id="6088" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1476" class="Field Operator">_+_</a><a id="6091" class="Symbol">)</a> <a id="6093" href="Tactic.RingSolver.html#6093" class="Bound">xs</a><a id="6095" class="Symbol">)</a> <a id="6097" class="Symbol">=</a> <a id="6099" href="Tactic.RingSolver.html#7071" class="Function">convertOp₂</a> <a id="6110" class="Symbol">(</a><a id="6111" class="Keyword">quote</a> <a id="6117" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a><a id="6120" class="Symbol">)</a> <a id="6122" href="Tactic.RingSolver.html#6093" class="Bound">xs</a>
      <a id="6131" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="6139" class="Symbol">(</a><a id="6140" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6144" class="Symbol">(</a><a id="6145" class="Keyword">quote</a> <a id="6151" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1518" class="Field Operator">_*_</a><a id="6154" class="Symbol">)</a> <a id="6156" href="Tactic.RingSolver.html#6156" class="Bound">xs</a><a id="6158" class="Symbol">)</a> <a id="6160" class="Symbol">=</a> <a id="6162" href="Tactic.RingSolver.html#7071" class="Function">convertOp₂</a> <a id="6173" class="Symbol">(</a><a id="6174" class="Keyword">quote</a> <a id="6180" href="Tactic.RingSolver.Core.Expression.html#700" class="InductiveConstructor Operator">_⊗_</a><a id="6183" class="Symbol">)</a> <a id="6185" href="Tactic.RingSolver.html#6156" class="Bound">xs</a>
      <a id="6194" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="6202" class="Symbol">(</a><a id="6203" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6207" class="Symbol">(</a><a id="6208" class="Keyword">quote</a>  <a id="6215" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1560" class="Field Operator">-_</a><a id="6217" class="Symbol">)</a> <a id="6219" href="Tactic.RingSolver.html#6219" class="Bound">xs</a><a id="6221" class="Symbol">)</a> <a id="6223" class="Symbol">=</a> <a id="6225" href="Tactic.RingSolver.html#7358" class="Function">convertOp₁</a> <a id="6236" class="Symbol">(</a><a id="6237" class="Keyword">quote</a>  <a id="6244" href="Tactic.RingSolver.Core.Expression.html#814" class="InductiveConstructor Operator">⊝_</a><a id="6246" class="Symbol">)</a> <a id="6248" href="Tactic.RingSolver.html#6219" class="Bound">xs</a>
      <a id="6257" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="6265" class="Symbol">(</a><a id="6266" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6270" class="Symbol">(</a><a id="6271" class="Keyword">quote</a> <a id="6277" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2417" class="Function Operator">_^_</a><a id="6280" class="Symbol">)</a> <a id="6282" href="Tactic.RingSolver.html#6282" class="Bound">xs</a><a id="6284" class="Symbol">)</a> <a id="6286" class="Symbol">=</a> <a id="6288" href="Tactic.RingSolver.html#7597" class="Function">convertExp</a> <a id="6299" href="Tactic.RingSolver.html#6282" class="Bound">xs</a>
      <a id="6308" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="6316" class="Symbol">(</a><a id="6317" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6321" class="Symbol">(</a><a id="6322" class="Keyword">quote</a> <a id="6328" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2500" class="Function Operator">_-_</a><a id="6331" class="Symbol">)</a> <a id="6333" href="Tactic.RingSolver.html#6333" class="Bound">xs</a><a id="6335" class="Symbol">)</a> <a id="6337" class="Symbol">=</a> <a id="6339" href="Tactic.RingSolver.html#7848" class="Function">convertSub</a> <a id="6350" href="Tactic.RingSolver.html#6333" class="Bound">xs</a>
      <a id="6359" class="Comment">-- Other definitions the underlying implementation of the ring&#39;s fields</a>
      <a id="6437" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="6445" class="Symbol">(</a><a id="6446" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6450" href="Tactic.RingSolver.html#6450" class="Bound">nm</a>          <a id="6462" href="Tactic.RingSolver.html#6462" class="Bound">xs</a><a id="6464" class="Symbol">)</a> <a id="6466" class="Symbol">=</a> <a id="6468" href="Tactic.RingSolver.html#8149" class="Function">convertUnknownName</a> <a id="6487" href="Tactic.RingSolver.html#6450" class="Bound">nm</a> <a id="6490" href="Tactic.RingSolver.html#6462" class="Bound">xs</a>
      <a id="6499" class="Comment">-- Variables</a>
      <a id="6518" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="6526" href="Tactic.RingSolver.html#6526" class="Bound">v</a><a id="6527" class="Symbol">@(</a><a id="6529" href="Agda.Builtin.Reflection.html#4815" class="InductiveConstructor">var</a> <a id="6533" href="Tactic.RingSolver.html#6533" class="Bound">x</a> <a id="6535" class="Symbol">_)</a>          <a id="6547" class="Symbol">=</a> <a id="6549" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="6556" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="6558" href="Data.Maybe.Base.html#1641" class="Function">fromMaybe</a> <a id="6568" class="Symbol">(</a><a id="6569" href="Tactic.RingSolver.html#4667" class="Function">`Κ</a> <a id="6572" href="Tactic.RingSolver.html#6526" class="Bound">v</a><a id="6573" class="Symbol">)</a> <a id="6575" class="Symbol">(</a><a id="6576" href="Tactic.RingSolver.html#5894" class="Bound">varMap</a> <a id="6583" href="Tactic.RingSolver.html#6533" class="Bound">x</a><a id="6584" class="Symbol">)</a>
      <a id="6592" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
      <a id="6646" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="6654" class="Symbol">(</a><a id="6655" href="Data.Nat.Reflection.html#616" class="InductiveConstructor">`suc</a> <a id="6660" href="Tactic.RingSolver.html#6660" class="Bound">x</a><a id="6661" class="Symbol">)</a>             <a id="6675" class="Symbol">=</a> <a id="6677" href="Tactic.RingSolver.html#8672" class="Function">convertSuc</a> <a id="6688" href="Tactic.RingSolver.html#6660" class="Bound">x</a>
      <a id="6696" class="Comment">-- Otherwise we&#39;re forced to treat it as a constant</a>
      <a id="6754" href="Tactic.RingSolver.html#5980" class="CatchallClause Function">convert</a><a id="6761" class="CatchallClause"> </a><a id="6762" href="Tactic.RingSolver.html#6762" class="CatchallClause Bound">t</a>                    <a id="6783" class="Symbol">=</a> <a id="6785" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="6792" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="6794" href="Tactic.RingSolver.html#4667" class="Function">`Κ</a> <a id="6797" href="Tactic.RingSolver.html#6762" class="Bound">t</a>

      <a id="6806" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
      <a id="6875" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
      <a id="6945" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
      <a id="7014" class="Comment">-- by just taking the last two explicit arguments.</a>
      <a id="7071" href="Tactic.RingSolver.html#7071" class="Function">convertOp₂</a> <a id="7082" class="Symbol">:</a> <a id="7084" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="7089" class="Symbol">→</a> <a id="7091" href="Reflection.AST.Argument.html#1547" class="Function">Args</a> <a id="7096" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7101" class="Symbol">→</a> <a id="7103" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7106" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="7117" href="Tactic.RingSolver.html#7071" class="Function">convertOp₂</a> <a id="7128" href="Tactic.RingSolver.html#7128" class="Bound">nm</a> <a id="7131" class="Symbol">(</a><a id="7132" href="Tactic.RingSolver.html#7132" class="Bound">x</a> <a id="7134" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7138" href="Tactic.RingSolver.html#7138" class="Bound">y</a> <a id="7140" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7144" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7146" class="Symbol">)</a> <a id="7148" class="Symbol">=</a> <a id="7150" class="Keyword">do</a>
        <a id="7161" href="Tactic.RingSolver.html#7161" class="Bound">x&#39;</a> <a id="7164" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="7166" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="7174" href="Tactic.RingSolver.html#7132" class="Bound">x</a>
        <a id="7184" href="Tactic.RingSolver.html#7184" class="Bound">y&#39;</a> <a id="7187" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="7189" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="7197" href="Tactic.RingSolver.html#7138" class="Bound">y</a>
        <a id="7207" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="7214" class="Symbol">(</a><a id="7215" href="Tactic.RingSolver.html#7128" class="Bound">nm</a> <a id="7218" href="Tactic.RingSolver.html#4533" class="Function Operator">$ᵉ</a> <a id="7221" class="Symbol">(</a><a id="7222" href="Tactic.RingSolver.html#7161" class="Bound">x&#39;</a> <a id="7225" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7229" href="Tactic.RingSolver.html#7184" class="Bound">y&#39;</a> <a id="7232" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7236" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7238" class="Symbol">))</a>
      <a id="7247" href="Tactic.RingSolver.html#7071" class="CatchallClause Function">convertOp₂</a><a id="7257" class="CatchallClause"> </a><a id="7258" href="Tactic.RingSolver.html#7258" class="CatchallClause Bound">nm</a><a id="7260" class="CatchallClause"> </a><a id="7261" class="CatchallClause Symbol">(</a><a id="7262" href="Tactic.RingSolver.html#7262" class="CatchallClause Bound">x</a><a id="7263" class="CatchallClause"> </a><a id="7264" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7265" class="CatchallClause"> </a><a id="7266" href="Tactic.RingSolver.html#7266" class="CatchallClause Bound">xs</a><a id="7268" class="CatchallClause Symbol">)</a>         <a id="7278" class="Symbol">=</a> <a id="7280" href="Tactic.RingSolver.html#7071" class="Function">convertOp₂</a> <a id="7291" href="Tactic.RingSolver.html#7258" class="Bound">nm</a> <a id="7294" href="Tactic.RingSolver.html#7266" class="Bound">xs</a>
      <a id="7303" href="Tactic.RingSolver.html#7071" class="CatchallClause Function">convertOp₂</a><a id="7313" class="CatchallClause"> </a><a id="7314" class="CatchallClause Symbol">_</a><a id="7315" class="CatchallClause">  </a><a id="7317" class="CatchallClause Symbol">_</a>                <a id="7334" class="Symbol">=</a> <a id="7336" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="7343" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

      <a id="7358" href="Tactic.RingSolver.html#7358" class="Function">convertOp₁</a> <a id="7369" class="Symbol">:</a> <a id="7371" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="7376" class="Symbol">→</a> <a id="7378" href="Reflection.AST.Argument.html#1547" class="Function">Args</a> <a id="7383" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7388" class="Symbol">→</a> <a id="7390" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7393" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="7404" href="Tactic.RingSolver.html#7358" class="Function">convertOp₁</a> <a id="7415" href="Tactic.RingSolver.html#7415" class="Bound">nm</a> <a id="7418" class="Symbol">(</a><a id="7419" href="Tactic.RingSolver.html#7419" class="Bound">x</a> <a id="7421" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7425" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7427" class="Symbol">)</a> <a id="7429" class="Symbol">=</a> <a id="7431" class="Keyword">do</a>
        <a id="7442" href="Tactic.RingSolver.html#7442" class="Bound">x&#39;</a> <a id="7445" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="7447" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="7455" href="Tactic.RingSolver.html#7419" class="Bound">x</a>
        <a id="7465" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="7472" class="Symbol">(</a><a id="7473" href="Tactic.RingSolver.html#7415" class="Bound">nm</a> <a id="7476" href="Tactic.RingSolver.html#4533" class="Function Operator">$ᵉ</a> <a id="7479" class="Symbol">(</a><a id="7480" href="Tactic.RingSolver.html#7442" class="Bound">x&#39;</a> <a id="7483" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7487" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7489" class="Symbol">))</a>
      <a id="7498" href="Tactic.RingSolver.html#7358" class="CatchallClause Function">convertOp₁</a><a id="7508" class="CatchallClause"> </a><a id="7509" href="Tactic.RingSolver.html#7509" class="CatchallClause Bound">nm</a><a id="7511" class="CatchallClause"> </a><a id="7512" class="CatchallClause Symbol">(</a><a id="7513" href="Tactic.RingSolver.html#7513" class="CatchallClause Bound">x</a><a id="7514" class="CatchallClause"> </a><a id="7515" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7516" class="CatchallClause"> </a><a id="7517" href="Tactic.RingSolver.html#7517" class="CatchallClause Bound">xs</a><a id="7519" class="CatchallClause Symbol">)</a>   <a id="7523" class="Symbol">=</a> <a id="7525" href="Tactic.RingSolver.html#7358" class="Function">convertOp₁</a> <a id="7536" href="Tactic.RingSolver.html#7509" class="Bound">nm</a> <a id="7539" href="Tactic.RingSolver.html#7517" class="Bound">xs</a>
      <a id="7548" href="Tactic.RingSolver.html#7358" class="CatchallClause Function">convertOp₁</a><a id="7558" class="CatchallClause"> </a><a id="7559" class="CatchallClause Symbol">_</a><a id="7560" class="CatchallClause">  </a><a id="7562" class="CatchallClause Symbol">_</a>          <a id="7573" class="Symbol">=</a> <a id="7575" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="7582" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

      <a id="7597" href="Tactic.RingSolver.html#7597" class="Function">convertExp</a> <a id="7608" class="Symbol">:</a> <a id="7610" href="Reflection.AST.Argument.html#1547" class="Function">Args</a> <a id="7615" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7620" class="Symbol">→</a> <a id="7622" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7625" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="7636" href="Tactic.RingSolver.html#7597" class="Function">convertExp</a> <a id="7647" class="Symbol">(</a><a id="7648" href="Tactic.RingSolver.html#7648" class="Bound">x</a> <a id="7650" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7654" href="Tactic.RingSolver.html#7654" class="Bound">y</a> <a id="7656" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7660" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7662" class="Symbol">)</a> <a id="7664" class="Symbol">=</a> <a id="7666" class="Keyword">do</a>
        <a id="7677" href="Tactic.RingSolver.html#7677" class="Bound">x&#39;</a> <a id="7680" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="7682" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="7690" href="Tactic.RingSolver.html#7648" class="Bound">x</a>
        <a id="7700" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="7707" class="Symbol">(</a><a id="7708" class="Keyword">quote</a> <a id="7714" href="Tactic.RingSolver.Core.Expression.html#757" class="InductiveConstructor Operator">_⊛_</a> <a id="7718" href="Tactic.RingSolver.html#4533" class="Function Operator">$ᵉ</a> <a id="7721" class="Symbol">(</a><a id="7722" href="Tactic.RingSolver.html#7677" class="Bound">x&#39;</a> <a id="7725" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7729" href="Tactic.RingSolver.html#7654" class="Bound">y</a> <a id="7731" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7735" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7737" class="Symbol">))</a>
      <a id="7746" href="Tactic.RingSolver.html#7597" class="CatchallClause Function">convertExp</a><a id="7756" class="CatchallClause"> </a><a id="7757" class="CatchallClause Symbol">(</a><a id="7758" href="Tactic.RingSolver.html#7758" class="CatchallClause Bound">x</a><a id="7759" class="CatchallClause"> </a><a id="7760" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7761" class="CatchallClause"> </a><a id="7762" href="Tactic.RingSolver.html#7762" class="CatchallClause Bound">xs</a><a id="7764" class="CatchallClause Symbol">)</a>         <a id="7774" class="Symbol">=</a> <a id="7776" href="Tactic.RingSolver.html#7597" class="Function">convertExp</a> <a id="7787" href="Tactic.RingSolver.html#7762" class="Bound">xs</a>
      <a id="7796" href="Tactic.RingSolver.html#7597" class="CatchallClause Function">convertExp</a><a id="7806" class="CatchallClause"> </a><a id="7807" class="CatchallClause Symbol">_</a>                <a id="7824" class="Symbol">=</a> <a id="7826" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="7833" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

      <a id="7848" href="Tactic.RingSolver.html#7848" class="Function">convertSub</a> <a id="7859" class="Symbol">:</a> <a id="7861" href="Reflection.AST.Argument.html#1547" class="Function">Args</a> <a id="7866" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7871" class="Symbol">→</a> <a id="7873" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7876" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="7887" href="Tactic.RingSolver.html#7848" class="Function">convertSub</a> <a id="7898" class="Symbol">(</a><a id="7899" href="Tactic.RingSolver.html#7899" class="Bound">x</a> <a id="7901" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7905" href="Tactic.RingSolver.html#7905" class="Bound">y</a> <a id="7907" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7911" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7913" class="Symbol">)</a> <a id="7915" class="Symbol">=</a> <a id="7917" class="Keyword">do</a>
        <a id="7928" href="Tactic.RingSolver.html#7928" class="Bound">x&#39;</a>  <a id="7932" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="7934" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="7942" href="Tactic.RingSolver.html#7899" class="Bound">x</a>
        <a id="7952" href="Tactic.RingSolver.html#7952" class="Bound">-y&#39;</a> <a id="7956" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="7958" href="Tactic.RingSolver.html#7358" class="Function">convertOp₁</a> <a id="7969" class="Symbol">(</a><a id="7970" class="Keyword">quote</a> <a id="7976" class="Symbol">(</a><a id="7977" href="Tactic.RingSolver.Core.Expression.html#814" class="InductiveConstructor Operator">⊝_</a><a id="7979" class="Symbol">))</a> <a id="7982" class="Symbol">(</a><a id="7983" href="Tactic.RingSolver.html#7905" class="Bound">y</a> <a id="7985" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7989" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7991" class="Symbol">)</a>
        <a id="8001" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="8008" class="Symbol">(</a><a id="8009" class="Keyword">quote</a> <a id="8015" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a> <a id="8019" href="Tactic.RingSolver.html#4533" class="Function Operator">$ᵉ</a> <a id="8022" href="Tactic.RingSolver.html#7928" class="Bound">x&#39;</a> <a id="8025" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8029" href="Tactic.RingSolver.html#7952" class="Bound">-y&#39;</a> <a id="8033" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8037" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="8039" class="Symbol">)</a>
      <a id="8047" href="Tactic.RingSolver.html#7848" class="CatchallClause Function">convertSub</a><a id="8057" class="CatchallClause"> </a><a id="8058" class="CatchallClause Symbol">(</a><a id="8059" href="Tactic.RingSolver.html#8059" class="CatchallClause Bound">x</a><a id="8060" class="CatchallClause"> </a><a id="8061" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8062" class="CatchallClause"> </a><a id="8063" href="Tactic.RingSolver.html#8063" class="CatchallClause Bound">xs</a><a id="8065" class="CatchallClause Symbol">)</a>         <a id="8075" class="Symbol">=</a> <a id="8077" href="Tactic.RingSolver.html#7848" class="Function">convertSub</a> <a id="8088" href="Tactic.RingSolver.html#8063" class="Bound">xs</a>
      <a id="8097" href="Tactic.RingSolver.html#7848" class="CatchallClause Function">convertSub</a><a id="8107" class="CatchallClause"> </a><a id="8108" class="CatchallClause Symbol">_</a>                <a id="8125" class="Symbol">=</a> <a id="8127" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="8134" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

      <a id="8149" href="Tactic.RingSolver.html#8149" class="Function">convertUnknownName</a> <a id="8168" class="Symbol">:</a> <a id="8170" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="8175" class="Symbol">→</a> <a id="8177" href="Reflection.AST.Argument.html#1547" class="Function">Args</a> <a id="8182" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8187" class="Symbol">→</a> <a id="8189" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="8192" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="8203" href="Tactic.RingSolver.html#8149" class="Function">convertUnknownName</a> <a id="8222" href="Tactic.RingSolver.html#8222" class="Bound">nm</a> <a id="8225" href="Tactic.RingSolver.html#8225" class="Bound">xs</a> <a id="8228" class="Symbol">=</a> <a id="8230" class="Keyword">do</a>
        <a id="8241" href="Tactic.RingSolver.html#8241" class="Bound">nameTerm</a> <a id="8250" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="8252" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="8262" class="Symbol">(</a><a id="8263" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8267" href="Tactic.RingSolver.html#8222" class="Bound">nm</a> <a id="8270" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="8272" class="Symbol">)</a>
        <a id="8282" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8285" class="Symbol">(</a><a id="8286" href="Tactic.RingSolver.html#8241" class="Bound">nameTerm</a> <a id="8295" href="Reflection.AST.AlphaEquality.html#1307" class="Field Operator">=α=</a> <a id="8299" href="Tactic.RingSolver.html#2682" class="Function">add</a><a id="8302" class="Symbol">)</a> <a id="8304" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8309" href="Tactic.RingSolver.html#7071" class="Function">convertOp₂</a> <a id="8320" class="Symbol">(</a><a id="8321" class="Keyword">quote</a> <a id="8327" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a><a id="8330" class="Symbol">)</a> <a id="8332" href="Tactic.RingSolver.html#8225" class="Bound">xs</a> <a id="8335" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
          <a id="8350" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8353" class="Symbol">(</a><a id="8354" href="Tactic.RingSolver.html#8241" class="Bound">nameTerm</a> <a id="8363" href="Reflection.AST.AlphaEquality.html#1307" class="Field Operator">=α=</a> <a id="8367" href="Tactic.RingSolver.html#2686" class="Function">mul</a><a id="8370" class="Symbol">)</a> <a id="8372" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8377" href="Tactic.RingSolver.html#7071" class="Function">convertOp₂</a> <a id="8388" class="Symbol">(</a><a id="8389" class="Keyword">quote</a> <a id="8395" href="Tactic.RingSolver.Core.Expression.html#700" class="InductiveConstructor Operator">_⊗_</a><a id="8398" class="Symbol">)</a> <a id="8400" href="Tactic.RingSolver.html#8225" class="Bound">xs</a> <a id="8403" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
            <a id="8420" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8423" class="Symbol">(</a><a id="8424" href="Tactic.RingSolver.html#8241" class="Bound">nameTerm</a> <a id="8433" href="Reflection.AST.AlphaEquality.html#1307" class="Field Operator">=α=</a> <a id="8437" href="Tactic.RingSolver.html#2694" class="Function">neg</a><a id="8440" class="Symbol">)</a> <a id="8442" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8447" href="Tactic.RingSolver.html#7358" class="Function">convertOp₁</a> <a id="8458" class="Symbol">(</a><a id="8459" class="Keyword">quote</a> <a id="8465" href="Tactic.RingSolver.Core.Expression.html#814" class="InductiveConstructor Operator">⊝_</a><a id="8467" class="Symbol">)</a>  <a id="8470" href="Tactic.RingSolver.html#8225" class="Bound">xs</a> <a id="8473" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
              <a id="8492" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8495" class="Symbol">(</a><a id="8496" href="Tactic.RingSolver.html#8241" class="Bound">nameTerm</a> <a id="8505" href="Reflection.AST.AlphaEquality.html#1307" class="Field Operator">=α=</a> <a id="8509" href="Tactic.RingSolver.html#2690" class="Function">pow</a><a id="8512" class="Symbol">)</a> <a id="8514" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8519" href="Tactic.RingSolver.html#7597" class="Function">convertExp</a>             <a id="8542" href="Tactic.RingSolver.html#8225" class="Bound">xs</a> <a id="8545" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
                <a id="8566" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8569" class="Symbol">(</a><a id="8570" href="Tactic.RingSolver.html#8241" class="Bound">nameTerm</a> <a id="8579" href="Reflection.AST.AlphaEquality.html#1307" class="Field Operator">=α=</a> <a id="8583" href="Tactic.RingSolver.html#2698" class="Function">sub</a><a id="8586" class="Symbol">)</a> <a id="8588" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8593" href="Tactic.RingSolver.html#7848" class="Function">convertSub</a>            <a id="8615" href="Tactic.RingSolver.html#8225" class="Bound">xs</a> <a id="8618" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
                  <a id="8641" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="8648" class="Symbol">(</a><a id="8649" href="Tactic.RingSolver.html#4667" class="Function">`Κ</a> <a id="8652" class="Symbol">(</a><a id="8653" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8657" href="Tactic.RingSolver.html#8222" class="Bound">nm</a> <a id="8660" href="Tactic.RingSolver.html#8225" class="Bound">xs</a><a id="8662" class="Symbol">))</a>

      <a id="8672" href="Tactic.RingSolver.html#8672" class="Function">convertSuc</a> <a id="8683" class="Symbol">:</a> <a id="8685" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8690" class="Symbol">→</a> <a id="8692" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="8695" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="8706" href="Tactic.RingSolver.html#8672" class="Function">convertSuc</a> <a id="8717" href="Tactic.RingSolver.html#8717" class="Bound">x</a> <a id="8719" class="Symbol">=</a> <a id="8721" class="Keyword">do</a> <a id="8724" href="Tactic.RingSolver.html#8724" class="Bound">x&#39;</a> <a id="8727" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="8729" href="Tactic.RingSolver.html#5980" class="Function">convert</a> <a id="8737" href="Tactic.RingSolver.html#8717" class="Bound">x</a><a id="8738" class="Symbol">;</a> <a id="8740" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="8747" class="Symbol">(</a><a id="8748" class="Keyword">quote</a> <a id="8754" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a> <a id="8758" href="Tactic.RingSolver.html#4533" class="Function Operator">$ᵉ</a> <a id="8761" class="Symbol">(</a><a id="8762" href="Tactic.RingSolver.html#4667" class="Function">`Κ</a> <a id="8765" class="Symbol">(</a><a id="8766" href="Data.Nat.Reflection.html#653" class="Function">toTerm</a> <a id="8773" class="Number">1</a><a id="8774" class="Symbol">)</a> <a id="8776" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8780" href="Tactic.RingSolver.html#8724" class="Bound">x&#39;</a> <a id="8783" href="Reflection.AST.Argument.html#1664" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8787" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="8789" class="Symbol">))</a>

<a id="8793" class="Comment">------------------------------------------------------------------------</a>
<a id="8866" class="Comment">-- Macros</a>
<a id="8876" class="Comment">------------------------------------------------------------------------</a>
<a id="8949" class="Comment">-- Quantified macro</a>

<a id="8970" class="Keyword">open</a> <a id="8975" href="Tactic.RingSolver.html#2804" class="Module">RingReflection</a>
<a id="8990" class="Keyword">open</a> <a id="8995" href="Tactic.RingSolver.html#4000" class="Module">RingSolverReflection</a>

<a id="malformedForallTypeError"></a><a id="9017" href="Tactic.RingSolver.html#9017" class="Function">malformedForallTypeError</a> <a id="9042" class="Symbol">:</a> <a id="9044" class="Symbol">∀</a> <a id="9046" class="Symbol">{</a><a id="9047" href="Tactic.RingSolver.html#9047" class="Bound">a</a><a id="9048" class="Symbol">}</a> <a id="9050" class="Symbol">{</a><a id="9051" href="Tactic.RingSolver.html#9051" class="Bound">A</a> <a id="9053" class="Symbol">:</a> <a id="9055" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="9059" href="Tactic.RingSolver.html#9047" class="Bound">a</a><a id="9060" class="Symbol">}</a> <a id="9062" class="Symbol">→</a> <a id="9064" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9069" class="Symbol">→</a> <a id="9071" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9074" href="Tactic.RingSolver.html#9051" class="Bound">A</a>
<a id="9076" href="Tactic.RingSolver.html#9017" class="Function">malformedForallTypeError</a> <a id="9101" href="Tactic.RingSolver.html#9101" class="Bound">found</a> <a id="9107" class="Symbol">=</a> <a id="9109" href="Agda.Builtin.Reflection.html#8492" class="Postulate">typeError</a>
  <a id="9121" class="Symbol">(</a> <a id="9123" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="9130" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="9159" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9161" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="9168" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a>
  <a id="9228" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9230" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="9237" class="String">&quot;Instead: &quot;</a>
  <a id="9251" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9253" href="Agda.Builtin.Reflection.html#7931" class="InductiveConstructor">termErr</a> <a id="9261" href="Tactic.RingSolver.html#9101" class="Bound">found</a>
  <a id="9269" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9271" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9273" class="Symbol">)</a>

<a id="quantifiedVarMap"></a><a id="9276" href="Tactic.RingSolver.html#9276" class="Function">quantifiedVarMap</a> <a id="9293" class="Symbol">:</a> <a id="9295" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9297" class="Symbol">→</a> <a id="9299" href="Tactic.RingSolver.html#1622" class="Function">VarMap</a>
<a id="9306" href="Tactic.RingSolver.html#9276" class="Function">quantifiedVarMap</a> <a id="9323" href="Tactic.RingSolver.html#9323" class="Bound">numVars</a> <a id="9331" href="Tactic.RingSolver.html#9331" class="Bound">i</a> <a id="9333" class="Symbol">=</a>
  <a id="9337" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="9340" href="Tactic.RingSolver.html#9331" class="Bound">i</a> <a id="9342" href="Data.Nat.Base.html#1239" class="Primitive Operator">&lt;ᵇ</a> <a id="9345" href="Tactic.RingSolver.html#9323" class="Bound">numVars</a>
    <a id="9357" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="9362" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="9367" class="Symbol">(</a><a id="9368" href="Agda.Builtin.Reflection.html#4815" class="InductiveConstructor">var</a> <a id="9372" href="Tactic.RingSolver.html#9331" class="Bound">i</a> <a id="9374" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9376" class="Symbol">)</a>
    <a id="9382" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="9387" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

<a id="constructCallToSolver"></a><a id="9396" href="Tactic.RingSolver.html#9396" class="Function">constructCallToSolver</a> <a id="9418" class="Symbol">:</a> <a id="9420" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9425" class="Symbol">→</a> <a id="9427" href="Tactic.RingSolver.html#2600" class="Record">RingOperatorTerms</a> <a id="9445" class="Symbol">→</a> <a id="9447" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9452" href="Agda.Builtin.String.html#318" class="Postulate">String</a> <a id="9459" class="Symbol">→</a> <a id="9461" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9466" class="Symbol">→</a> <a id="9468" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9473" class="Symbol">→</a> <a id="9475" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9478" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="9483" href="Tactic.RingSolver.html#9396" class="Function">constructCallToSolver</a> <a id="9505" href="Tactic.RingSolver.html#9505" class="Bound">`ring</a> <a id="9511" href="Tactic.RingSolver.html#9511" class="Bound">opNames</a> <a id="9519" href="Tactic.RingSolver.html#9519" class="Bound">variables</a> <a id="9529" href="Tactic.RingSolver.html#9529" class="Bound">`lhs</a> <a id="9534" href="Tactic.RingSolver.html#9534" class="Bound">`rhs</a> <a id="9539" class="Symbol">=</a> <a id="9541" class="Keyword">do</a>
  <a id="9546" href="Tactic.RingSolver.html#9546" class="Bound">`lhsExpr</a> <a id="9555" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="9557" href="Tactic.RingSolver.html#9826" class="Function">conv</a> <a id="9562" href="Tactic.RingSolver.html#9529" class="Bound">`lhs</a>
  <a id="9569" href="Tactic.RingSolver.html#9569" class="Bound">`rhsExpr</a> <a id="9578" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="9580" href="Tactic.RingSolver.html#9826" class="Function">conv</a> <a id="9585" href="Tactic.RingSolver.html#9534" class="Bound">`rhs</a>

  <a id="9593" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="9600" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="9602" href="Tactic.RingSolver.html#4958" class="Function">`solver</a> <a id="9610" href="Tactic.RingSolver.html#9505" class="Bound">`ring</a> <a id="9616" href="Tactic.RingSolver.html#9777" class="Function">numVars</a>
                    <a id="9644" class="Symbol">(</a><a id="9645" href="Reflection.AST.Term.html#3503" class="Function">prependVLams</a> <a id="9658" href="Tactic.RingSolver.html#9519" class="Bound">variables</a> <a id="9668" class="Symbol">(</a><a id="9669" href="Tactic.RingSolver.html#4769" class="Function Operator">_`⊜_</a> <a id="9674" href="Tactic.RingSolver.html#9505" class="Bound">`ring</a> <a id="9680" href="Tactic.RingSolver.html#9777" class="Function">numVars</a> <a id="9688" href="Tactic.RingSolver.html#9546" class="Bound">`lhsExpr</a> <a id="9697" href="Tactic.RingSolver.html#9569" class="Bound">`rhsExpr</a><a id="9705" class="Symbol">))</a>
                    <a id="9728" class="Symbol">(</a><a id="9729" href="Reflection.AST.Term.html#3405" class="Function">prependHLams</a> <a id="9742" href="Tactic.RingSolver.html#9519" class="Bound">variables</a> <a id="9752" class="Symbol">(</a><a id="9753" href="Tactic.RingSolver.html#3207" class="Function">`refl</a> <a id="9759" href="Tactic.RingSolver.html#9505" class="Bound">`ring</a><a id="9764" class="Symbol">))</a>
  <a id="9769" class="Keyword">where</a>
  <a id="9777" href="Tactic.RingSolver.html#9777" class="Function">numVars</a> <a id="9785" class="Symbol">:</a> <a id="9787" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
  <a id="9791" href="Tactic.RingSolver.html#9777" class="Function">numVars</a> <a id="9799" class="Symbol">=</a> <a id="9801" href="Data.List.Base.html#4888" class="Function">List.length</a> <a id="9813" href="Tactic.RingSolver.html#9519" class="Bound">variables</a>

  <a id="9826" href="Tactic.RingSolver.html#9826" class="Function">conv</a> <a id="9831" class="Symbol">:</a> <a id="9833" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9838" class="Symbol">→</a> <a id="9840" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9843" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="9850" href="Tactic.RingSolver.html#9826" class="Function">conv</a> <a id="9855" class="Symbol">=</a> <a id="9857" href="Tactic.RingSolver.html#5808" class="Function">convertTerm</a> <a id="9869" href="Tactic.RingSolver.html#9505" class="Bound">`ring</a> <a id="9875" href="Tactic.RingSolver.html#9777" class="Function">numVars</a> <a id="9883" href="Tactic.RingSolver.html#9511" class="Bound">opNames</a> <a id="9891" class="Symbol">(</a><a id="9892" href="Tactic.RingSolver.html#9276" class="Function">quantifiedVarMap</a> <a id="9909" href="Tactic.RingSolver.html#9777" class="Function">numVars</a><a id="9916" class="Symbol">)</a>

<a id="9919" class="Comment">-- This is the main macro which solves for equations in which the</a>
<a id="9985" class="Comment">-- variables are universally quantified over:</a>
<a id="10031" class="Comment">--</a>
<a id="10034" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="10069" class="Comment">--   lemma = solve-∀ ring</a>
<a id="10095" class="Comment">--</a>
<a id="10098" class="Comment">-- where ring is your implementation of AlmostCommutativeRing.</a>
<a id="10161" class="Comment">-- (Find some example implementations in</a>
<a id="10202" class="Comment">-- Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>
<a id="solve-∀-macro"></a><a id="10262" href="Tactic.RingSolver.html#10262" class="Function">solve-∀-macro</a> <a id="10276" class="Symbol">:</a> <a id="10278" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="10283" class="Symbol">→</a> <a id="10285" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="10290" class="Symbol">→</a> <a id="10292" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="10295" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
<a id="10297" href="Tactic.RingSolver.html#10262" class="Function">solve-∀-macro</a> <a id="10311" href="Tactic.RingSolver.html#10311" class="Bound">ring</a> <a id="10316" href="Tactic.RingSolver.html#10316" class="Bound">hole</a> <a id="10321" class="Symbol">=</a> <a id="10323" class="Keyword">do</a>
  <a id="10328" href="Tactic.RingSolver.html#10328" class="Bound">`ring</a> <a id="10334" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="10336" href="Tactic.RingSolver.html#2710" class="Function">checkIsRing</a> <a id="10348" class="Symbol">(</a><a id="10349" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="10353" href="Tactic.RingSolver.html#10311" class="Bound">ring</a> <a id="10358" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="10360" class="Symbol">)</a>
  <a id="10364" href="Agda.Builtin.Reflection.html#9504" class="Postulate">commitTC</a>
  <a id="10375" href="Tactic.RingSolver.html#10375" class="Bound">operatorTerms</a> <a id="10389" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="10391" href="Tactic.RingSolver.html#3611" class="Function">getRingOperatorTerms</a> <a id="10412" href="Tactic.RingSolver.html#10328" class="Bound">`ring</a>

  <a id="10421" class="Comment">-- Obtain and sanitise the goal type</a>
  <a id="10460" href="Tactic.RingSolver.html#10460" class="Bound">`hole</a> <a id="10466" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="10468" href="Agda.Builtin.Reflection.html#8555" class="Postulate">inferType</a> <a id="10478" href="Tactic.RingSolver.html#10316" class="Bound">hole</a> <a id="10483" href="Reflection.TCM.Syntax.html#676" class="Function Operator">&gt;&gt;=</a> <a id="10487" href="Agda.Builtin.Reflection.html#8670" class="Postulate">reduce</a>
  <a id="10496" class="Keyword">let</a> <a id="10500" href="Tactic.RingSolver.html#10500" class="Bound">variablesAndTypes</a> <a id="10518" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10520" href="Tactic.RingSolver.html#10520" class="Bound">equation</a> <a id="10529" class="Symbol">=</a> <a id="10531" href="Reflection.AST.Term.html#3134" class="Function">stripPis</a> <a id="10540" href="Tactic.RingSolver.html#10460" class="Bound">`hole</a>

  <a id="10549" class="Keyword">let</a> <a id="10553" href="Tactic.RingSolver.html#10553" class="Bound">variables</a> <a id="10563" class="Symbol">=</a> <a id="10565" href="Data.List.Base.html#1572" class="Function">List.map</a> <a id="10574" href="Agda.Builtin.Sigma.html#234" class="Field">proj₁</a> <a id="10580" href="Tactic.RingSolver.html#10500" class="Bound">variablesAndTypes</a>
  <a id="10600" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="10605" class="Symbol">(</a><a id="10606" href="Tactic.RingSolver.html#10606" class="Bound">lhs</a> <a id="10610" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷</a> <a id="10612" href="Tactic.RingSolver.html#10612" class="Bound">rhs</a> <a id="10616" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷</a> <a id="10618" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a><a id="10620" class="Symbol">)</a> <a id="10622" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="10624" href="Reflection.TCM.Syntax.html#517" class="Function">pure</a> <a id="10629" class="Symbol">(</a><a id="10630" href="Tactic.RingSolver.html#1805" class="Function">getVisibleArgs</a> <a id="10645" class="Number">2</a> <a id="10647" href="Tactic.RingSolver.html#10520" class="Bound">equation</a><a id="10655" class="Symbol">)</a>
    <a id="10661" class="Keyword">where</a> <a id="10667" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="10675" class="Symbol">→</a> <a id="10677" href="Tactic.RingSolver.html#9017" class="Function">malformedForallTypeError</a> <a id="10702" href="Tactic.RingSolver.html#10460" class="Bound">`hole</a>

  <a id="10711" href="Tactic.RingSolver.html#10711" class="Bound">solverCall</a> <a id="10722" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="10724" href="Tactic.RingSolver.html#9396" class="Function">constructCallToSolver</a> <a id="10746" href="Tactic.RingSolver.html#10328" class="Bound">`ring</a> <a id="10752" href="Tactic.RingSolver.html#10375" class="Bound">operatorTerms</a> <a id="10766" href="Tactic.RingSolver.html#10553" class="Bound">variables</a> <a id="10776" href="Tactic.RingSolver.html#10606" class="Bound">lhs</a> <a id="10780" href="Tactic.RingSolver.html#10612" class="Bound">rhs</a>
  <a id="10786" href="Agda.Builtin.Reflection.html#8452" class="Postulate">unify</a> <a id="10792" href="Tactic.RingSolver.html#10316" class="Bound">hole</a> <a id="10797" href="Tactic.RingSolver.html#10711" class="Bound">solverCall</a>

<a id="10809" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="10817" href="Tactic.RingSolver.html#10817" class="Function">solve-∀</a> <a id="10825" class="Symbol">:</a> <a id="10827" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="10832" class="Symbol">→</a> <a id="10834" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="10839" class="Symbol">→</a> <a id="10841" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="10844" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
  <a id="10848" href="Tactic.RingSolver.html#10817" class="Function">solve-∀</a> <a id="10856" class="Symbol">=</a> <a id="10858" href="Tactic.RingSolver.html#10262" class="Function">solve-∀-macro</a>

<a id="10873" class="Comment">------------------------------------------------------------------------</a>
<a id="10946" class="Comment">-- Unquantified macro</a>

<a id="malformedArgumentListError"></a><a id="10969" href="Tactic.RingSolver.html#10969" class="Function">malformedArgumentListError</a> <a id="10996" class="Symbol">:</a> <a id="10998" class="Symbol">∀</a> <a id="11000" class="Symbol">{</a><a id="11001" href="Tactic.RingSolver.html#11001" class="Bound">a</a><a id="11002" class="Symbol">}</a> <a id="11004" class="Symbol">{</a><a id="11005" href="Tactic.RingSolver.html#11005" class="Bound">A</a> <a id="11007" class="Symbol">:</a> <a id="11009" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="11013" href="Tactic.RingSolver.html#11001" class="Bound">a</a><a id="11014" class="Symbol">}</a> <a id="11016" class="Symbol">→</a> <a id="11018" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11023" class="Symbol">→</a> <a id="11025" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="11028" href="Tactic.RingSolver.html#11005" class="Bound">A</a>
<a id="11030" href="Tactic.RingSolver.html#10969" class="Function">malformedArgumentListError</a> <a id="11057" href="Tactic.RingSolver.html#11057" class="Bound">found</a> <a id="11063" class="Symbol">=</a> <a id="11065" href="Agda.Builtin.Reflection.html#8492" class="Postulate">typeError</a>
  <a id="11077" class="Symbol">(</a> <a id="11079" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11086" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11115" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11117" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11124" class="String">&quot;First argument should be a list of free variables.&quot;</a>
  <a id="11179" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11181" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11188" class="String">&quot;Instead: &quot;</a>
  <a id="11202" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11204" href="Agda.Builtin.Reflection.html#7931" class="InductiveConstructor">termErr</a> <a id="11212" href="Tactic.RingSolver.html#11057" class="Bound">found</a>
  <a id="11220" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11222" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="11224" class="Symbol">)</a>

<a id="malformedGoalError"></a><a id="11227" href="Tactic.RingSolver.html#11227" class="Function">malformedGoalError</a> <a id="11246" class="Symbol">:</a> <a id="11248" class="Symbol">∀</a> <a id="11250" class="Symbol">{</a><a id="11251" href="Tactic.RingSolver.html#11251" class="Bound">a</a><a id="11252" class="Symbol">}</a> <a id="11254" class="Symbol">{</a><a id="11255" href="Tactic.RingSolver.html#11255" class="Bound">A</a> <a id="11257" class="Symbol">:</a> <a id="11259" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="11263" href="Tactic.RingSolver.html#11251" class="Bound">a</a><a id="11264" class="Symbol">}</a> <a id="11266" class="Symbol">→</a> <a id="11268" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11273" class="Symbol">→</a> <a id="11275" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="11278" href="Tactic.RingSolver.html#11255" class="Bound">A</a>
<a id="11280" href="Tactic.RingSolver.html#11227" class="Function">malformedGoalError</a> <a id="11299" href="Tactic.RingSolver.html#11299" class="Bound">found</a> <a id="11305" class="Symbol">=</a> <a id="11307" href="Agda.Builtin.Reflection.html#8492" class="Postulate">typeError</a>
  <a id="11319" class="Symbol">(</a> <a id="11321" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11328" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11357" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11359" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11366" class="String">&quot;Goal type should be of the form: LHS ≈ RHS&quot;</a>
  <a id="11413" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11415" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11422" class="String">&quot;Instead: &quot;</a>
  <a id="11436" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11438" href="Agda.Builtin.Reflection.html#7931" class="InductiveConstructor">termErr</a> <a id="11446" href="Tactic.RingSolver.html#11299" class="Bound">found</a>
  <a id="11454" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11456" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="11458" class="Symbol">)</a>

<a id="checkIsListOfVariables"></a><a id="11461" href="Tactic.RingSolver.html#11461" class="Function">checkIsListOfVariables</a> <a id="11484" class="Symbol">:</a> <a id="11486" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11491" class="Symbol">→</a> <a id="11493" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11498" class="Symbol">→</a> <a id="11500" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="11503" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="11508" href="Tactic.RingSolver.html#11461" class="Function">checkIsListOfVariables</a> <a id="11531" href="Tactic.RingSolver.html#11531" class="Bound">`ring</a> <a id="11537" href="Tactic.RingSolver.html#11537" class="Bound">`xs</a> <a id="11541" class="Symbol">=</a> <a id="11543" href="Agda.Builtin.Reflection.html#8591" class="Postulate">checkType</a> <a id="11553" href="Tactic.RingSolver.html#11537" class="Bound">`xs</a> <a id="11557" class="Symbol">(</a><a id="11558" href="Data.List.Reflection.html#471" class="Function">`List</a> <a id="11564" class="Symbol">(</a><a id="11565" href="Tactic.RingSolver.html#3155" class="Function">`Carrier</a> <a id="11574" href="Tactic.RingSolver.html#11531" class="Bound">`ring</a><a id="11579" class="Symbol">))</a> <a id="11582" href="Reflection.TCM.Syntax.html#676" class="Function Operator">&gt;&gt;=</a> <a id="11586" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a>

<a id="11597" class="Comment">-- Extracts the deBruijn indices from a list of variables</a>
<a id="getVariableIndices"></a><a id="11655" href="Tactic.RingSolver.html#11655" class="Function">getVariableIndices</a> <a id="11674" class="Symbol">:</a> <a id="11676" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11681" class="Symbol">→</a> <a id="11683" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="11689" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a>
<a id="11696" href="Tactic.RingSolver.html#11655" class="Function">getVariableIndices</a> <a id="11715" class="Symbol">=</a> <a id="11717" href="Tactic.RingSolver.html#11733" class="Function">go</a> <a id="11720" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>
  <a id="11725" class="Keyword">where</a>
  <a id="11733" href="Tactic.RingSolver.html#11733" class="Function">go</a> <a id="11736" class="Symbol">:</a> <a id="11738" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a> <a id="11745" class="Symbol">→</a> <a id="11747" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11752" class="Symbol">→</a> <a id="11754" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="11760" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a>
  <a id="11769" href="Tactic.RingSolver.html#11733" class="Function">go</a> <a id="11772" href="Tactic.RingSolver.html#11772" class="Bound">t</a> <a id="11774" class="Symbol">(</a><a id="11775" href="Agda.Builtin.Reflection.html#4815" class="InductiveConstructor">var</a> <a id="11779" href="Tactic.RingSolver.html#11779" class="Bound">i</a> <a id="11781" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a> <a id="11784" href="Data.List.Reflection.html#965" class="InductiveConstructor Operator">`∷`</a> <a id="11788" href="Tactic.RingSolver.html#11788" class="Bound">xs</a><a id="11790" class="Symbol">)</a> <a id="11792" class="Symbol">=</a> <a id="11794" href="Tactic.RingSolver.html#11733" class="Function">go</a> <a id="11797" class="Symbol">(</a><a id="11798" href="Tactic.RingSolver.Core.NatSet.html#2242" class="Function">insert</a> <a id="11805" href="Tactic.RingSolver.html#11779" class="Bound">i</a> <a id="11807" href="Tactic.RingSolver.html#11772" class="Bound">t</a><a id="11808" class="Symbol">)</a> <a id="11810" href="Tactic.RingSolver.html#11788" class="Bound">xs</a>
  <a id="11815" href="Tactic.RingSolver.html#11733" class="Function">go</a> <a id="11818" href="Tactic.RingSolver.html#11818" class="Bound">t</a> <a id="11820" href="Data.List.Reflection.html#921" class="InductiveConstructor">`[]`</a>              <a id="11838" class="Symbol">=</a> <a id="11840" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="11845" href="Tactic.RingSolver.html#11818" class="Bound">t</a>
  <a id="11849" href="Tactic.RingSolver.html#11733" class="CatchallClause Function">go</a><a id="11851" class="CatchallClause"> </a><a id="11852" class="CatchallClause Symbol">_</a><a id="11853" class="CatchallClause"> </a><a id="11854" class="CatchallClause Symbol">_</a>                 <a id="11872" class="Symbol">=</a> <a id="11874" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

<a id="constructSolution"></a><a id="11883" href="Tactic.RingSolver.html#11883" class="Function">constructSolution</a> <a id="11901" class="Symbol">:</a> <a id="11903" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11908" class="Symbol">→</a> <a id="11910" href="Tactic.RingSolver.html#2600" class="Record">RingOperatorTerms</a> <a id="11928" class="Symbol">→</a> <a id="11930" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a> <a id="11937" class="Symbol">→</a> <a id="11939" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11944" class="Symbol">→</a> <a id="11946" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11951" class="Symbol">→</a> <a id="11953" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="11956" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="11961" href="Tactic.RingSolver.html#11883" class="Function">constructSolution</a> <a id="11979" href="Tactic.RingSolver.html#11979" class="Bound">`ring</a> <a id="11985" href="Tactic.RingSolver.html#11985" class="Bound">opTerms</a> <a id="11993" href="Tactic.RingSolver.html#11993" class="Bound">variables</a> <a id="12003" href="Tactic.RingSolver.html#12003" class="Bound">`lhs</a> <a id="12008" href="Tactic.RingSolver.html#12008" class="Bound">`rhs</a> <a id="12013" class="Symbol">=</a> <a id="12015" class="Keyword">do</a>
  <a id="12020" href="Tactic.RingSolver.html#12020" class="Bound">`lhsExpr</a> <a id="12029" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="12031" href="Tactic.RingSolver.html#12306" class="Function">conv</a> <a id="12036" href="Tactic.RingSolver.html#12003" class="Bound">`lhs</a>
  <a id="12043" href="Tactic.RingSolver.html#12043" class="Bound">`rhsExpr</a> <a id="12052" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="12054" href="Tactic.RingSolver.html#12306" class="Function">conv</a> <a id="12059" href="Tactic.RingSolver.html#12008" class="Bound">`rhs</a>
  <a id="12066" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="12073" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="12075" href="Tactic.RingSolver.html#3327" class="Function">`trans</a> <a id="12082" href="Tactic.RingSolver.html#11979" class="Bound">`ring</a> <a id="12088" class="Symbol">(</a><a id="12089" href="Tactic.RingSolver.html#3259" class="Function">`sym</a> <a id="12094" href="Tactic.RingSolver.html#11979" class="Bound">`ring</a> <a id="12100" href="Tactic.RingSolver.html#12020" class="Bound">`lhsExpr</a><a id="12108" class="Symbol">)</a> <a id="12110" href="Tactic.RingSolver.html#12043" class="Bound">`rhsExpr</a>
  <a id="12121" class="Keyword">where</a>
  <a id="12129" href="Tactic.RingSolver.html#12129" class="Function">numVars</a> <a id="12137" class="Symbol">=</a> <a id="12139" href="Data.List.Base.html#4888" class="Function">List.length</a> <a id="12151" href="Tactic.RingSolver.html#11993" class="Bound">variables</a>

  <a id="12164" href="Tactic.RingSolver.html#12164" class="Function">varMap</a> <a id="12171" class="Symbol">:</a> <a id="12173" href="Tactic.RingSolver.html#1622" class="Function">VarMap</a>
  <a id="12182" href="Tactic.RingSolver.html#12164" class="Function">varMap</a> <a id="12189" href="Tactic.RingSolver.html#12189" class="Bound">i</a> <a id="12191" class="Symbol">=</a> <a id="12193" href="Data.Maybe.Base.html#2029" class="Function">Maybe.map</a> <a id="12203" class="Symbol">(λ</a> <a id="12206" href="Tactic.RingSolver.html#12206" class="Bound">x</a> <a id="12208" class="Symbol">→</a> <a id="12210" href="Tactic.RingSolver.html#4718" class="Function">`I</a> <a id="12213" href="Tactic.RingSolver.html#11979" class="Bound">`ring</a> <a id="12219" href="Tactic.RingSolver.html#12129" class="Function">numVars</a> <a id="12227" class="Symbol">(</a><a id="12228" href="Data.Nat.Reflection.html#728" class="Function">toFinTerm</a> <a id="12238" href="Tactic.RingSolver.html#12206" class="Bound">x</a><a id="12239" class="Symbol">))</a> <a id="12242" class="Symbol">(</a><a id="12243" href="Tactic.RingSolver.Core.NatSet.html#2890" class="Function">lookup</a> <a id="12250" href="Tactic.RingSolver.html#11993" class="Bound">variables</a> <a id="12260" href="Tactic.RingSolver.html#12189" class="Bound">i</a><a id="12261" class="Symbol">)</a>

  <a id="12266" href="Tactic.RingSolver.html#12266" class="Function">ρ</a> <a id="12268" class="Symbol">:</a> <a id="12270" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="12277" href="Tactic.RingSolver.html#12266" class="Function">ρ</a> <a id="12279" class="Symbol">=</a> <a id="12281" href="Tactic.RingSolver.html#2232" class="Function">curriedTerm</a> <a id="12293" href="Tactic.RingSolver.html#11993" class="Bound">variables</a>

  <a id="12306" href="Tactic.RingSolver.html#12306" class="Function">conv</a> <a id="12311" class="Symbol">=</a> <a id="12313" class="Symbol">λ</a> <a id="12315" href="Tactic.RingSolver.html#12315" class="Bound">t</a> <a id="12317" class="Symbol">→</a> <a id="12319" class="Keyword">do</a>
    <a id="12326" href="Tactic.RingSolver.html#12326" class="Bound">t&#39;</a> <a id="12329" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="12331" href="Tactic.RingSolver.html#5808" class="Function">convertTerm</a> <a id="12343" href="Tactic.RingSolver.html#11979" class="Bound">`ring</a> <a id="12349" href="Tactic.RingSolver.html#12129" class="Function">numVars</a> <a id="12357" href="Tactic.RingSolver.html#11985" class="Bound">opTerms</a> <a id="12365" href="Tactic.RingSolver.html#12164" class="Function">varMap</a> <a id="12372" href="Tactic.RingSolver.html#12315" class="Bound">t</a>
    <a id="12378" href="Reflection.TCM.html#1025" class="Postulate">return</a> <a id="12385" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="12387" href="Tactic.RingSolver.html#4863" class="Function">`correct</a> <a id="12396" href="Tactic.RingSolver.html#11979" class="Bound">`ring</a> <a id="12402" href="Tactic.RingSolver.html#12129" class="Function">numVars</a> <a id="12410" href="Tactic.RingSolver.html#12326" class="Bound">t&#39;</a> <a id="12413" href="Tactic.RingSolver.html#12266" class="Function">ρ</a>

<a id="12416" class="Comment">-- Use this macro when you want to solve something *under* a lambda. For example:</a>
<a id="12498" class="Comment">-- say you have a long proof, and you just want the solver to deal with an</a>
<a id="12573" class="Comment">-- intermediate step. Call it like so:</a>
<a id="12612" class="Comment">--</a>
<a id="12615" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="12667" class="Comment">--   lemma₃ x y = begin</a>
<a id="12691" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="12750" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="12804" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="12835" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="12858" class="Comment">--</a>
<a id="12861" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="12928" class="Comment">-- ring implementation (as before).</a>
<a id="solve-macro"></a><a id="12964" href="Tactic.RingSolver.html#12964" class="Function">solve-macro</a> <a id="12976" class="Symbol">:</a> <a id="12978" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="12983" class="Symbol">→</a> <a id="12985" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="12990" class="Symbol">→</a> <a id="12992" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="12997" class="Symbol">→</a> <a id="12999" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="13002" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
<a id="13004" href="Tactic.RingSolver.html#12964" class="Function">solve-macro</a> <a id="13016" href="Tactic.RingSolver.html#13016" class="Bound">variables</a> <a id="13026" href="Tactic.RingSolver.html#13026" class="Bound">ring</a> <a id="13031" href="Tactic.RingSolver.html#13031" class="Bound">hole</a> <a id="13036" class="Symbol">=</a> <a id="13038" class="Keyword">do</a>
  <a id="13043" href="Tactic.RingSolver.html#13043" class="Bound">`ring</a> <a id="13049" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="13051" href="Tactic.RingSolver.html#2710" class="Function">checkIsRing</a> <a id="13063" class="Symbol">(</a><a id="13064" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="13068" href="Tactic.RingSolver.html#13026" class="Bound">ring</a> <a id="13073" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="13075" class="Symbol">)</a>
  <a id="13079" href="Agda.Builtin.Reflection.html#9504" class="Postulate">commitTC</a>
  <a id="13090" href="Tactic.RingSolver.html#13090" class="Bound">operatorTerms</a> <a id="13104" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="13106" href="Tactic.RingSolver.html#3611" class="Function">getRingOperatorTerms</a> <a id="13127" href="Tactic.RingSolver.html#13043" class="Bound">`ring</a>

  <a id="13136" class="Comment">-- Obtain and sanitise the list of variables</a>
  <a id="13183" href="Tactic.RingSolver.html#13183" class="Bound">listOfVariables′</a> <a id="13200" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="13202" href="Tactic.RingSolver.html#11461" class="Function">checkIsListOfVariables</a> <a id="13225" href="Tactic.RingSolver.html#13043" class="Bound">`ring</a> <a id="13231" href="Tactic.RingSolver.html#13016" class="Bound">variables</a>
  <a id="13243" href="Agda.Builtin.Reflection.html#9504" class="Postulate">commitTC</a>
  <a id="13254" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="13259" href="Tactic.RingSolver.html#13259" class="Bound">variableIndices</a> <a id="13275" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="13277" href="Reflection.TCM.Syntax.html#517" class="Function">pure</a> <a id="13282" class="Symbol">(</a><a id="13283" href="Tactic.RingSolver.html#11655" class="Function">getVariableIndices</a> <a id="13302" href="Tactic.RingSolver.html#13183" class="Bound">listOfVariables′</a><a id="13318" class="Symbol">)</a>
    <a id="13324" class="Keyword">where</a> <a id="13330" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="13338" class="Symbol">→</a> <a id="13340" href="Tactic.RingSolver.html#10969" class="Function">malformedArgumentListError</a> <a id="13367" href="Tactic.RingSolver.html#13183" class="Bound">listOfVariables′</a>

  <a id="13387" class="Comment">-- Obtain and santise the goal type</a>
  <a id="13425" href="Tactic.RingSolver.html#13425" class="Bound">hole′</a> <a id="13431" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="13433" href="Agda.Builtin.Reflection.html#8555" class="Postulate">inferType</a> <a id="13443" href="Tactic.RingSolver.html#13031" class="Bound">hole</a> <a id="13448" href="Reflection.TCM.Syntax.html#676" class="Function Operator">&gt;&gt;=</a> <a id="13452" href="Agda.Builtin.Reflection.html#8670" class="Postulate">reduce</a>
  <a id="13461" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="13466" class="Symbol">(</a><a id="13467" href="Tactic.RingSolver.html#13467" class="Bound">lhs</a> <a id="13471" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷</a> <a id="13473" href="Tactic.RingSolver.html#13473" class="Bound">rhs</a> <a id="13477" href="Data.Vec.Base.html#1121" class="InductiveConstructor Operator">∷</a> <a id="13479" href="Data.Vec.Base.html#1102" class="InductiveConstructor">[]</a><a id="13481" class="Symbol">)</a> <a id="13483" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="13485" href="Reflection.TCM.Syntax.html#517" class="Function">pure</a> <a id="13490" class="Symbol">(</a><a id="13491" href="Tactic.RingSolver.html#1805" class="Function">getVisibleArgs</a> <a id="13506" class="Number">2</a> <a id="13508" href="Tactic.RingSolver.html#13425" class="Bound">hole′</a><a id="13513" class="Symbol">)</a>
    <a id="13519" class="Keyword">where</a> <a id="13525" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="13533" class="Symbol">→</a> <a id="13535" href="Tactic.RingSolver.html#11227" class="Function">malformedGoalError</a> <a id="13554" href="Tactic.RingSolver.html#13425" class="Bound">hole′</a>

  <a id="13563" href="Tactic.RingSolver.html#13563" class="Bound">solution</a> <a id="13572" href="Reflection.TCM.Syntax.html#676" class="Function Operator">←</a> <a id="13574" href="Tactic.RingSolver.html#11883" class="Function">constructSolution</a> <a id="13592" href="Tactic.RingSolver.html#13043" class="Bound">`ring</a> <a id="13598" href="Tactic.RingSolver.html#13090" class="Bound">operatorTerms</a> <a id="13612" href="Tactic.RingSolver.html#13259" class="Bound">variableIndices</a> <a id="13628" href="Tactic.RingSolver.html#13467" class="Bound">lhs</a> <a id="13632" href="Tactic.RingSolver.html#13473" class="Bound">rhs</a>
  <a id="13638" href="Agda.Builtin.Reflection.html#8452" class="Postulate">unify</a> <a id="13644" href="Tactic.RingSolver.html#13031" class="Bound">hole</a> <a id="13649" href="Tactic.RingSolver.html#13563" class="Bound">solution</a>

<a id="13659" class="Keyword">macro</a>
  <a id="solve"></a><a id="13667" href="Tactic.RingSolver.html#13667" class="Function">solve</a> <a id="13673" class="Symbol">:</a> <a id="13675" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="13680" class="Symbol">→</a> <a id="13682" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="13687" class="Symbol">→</a> <a id="13689" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="13694" class="Symbol">→</a> <a id="13696" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="13699" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
  <a id="13703" href="Tactic.RingSolver.html#13667" class="Function">solve</a> <a id="13709" class="Symbol">=</a> <a id="13711" href="Tactic.RingSolver.html#12964" class="Function">solve-macro</a>
</pre></body></html>