<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Case</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the case expressions can be used with anonymous</a>
<a id="178" class="Comment">-- pattern-matching lambda abstractions</a>
<a id="218" class="Comment">------------------------------------------------------------------------</a>

<a id="292" class="Symbol">{-#</a> <a id="296" class="Keyword">OPTIONS</a> <a id="304" class="Pragma">--without-K</a> <a id="316" class="Pragma">--safe</a> <a id="323" class="Symbol">#-}</a>

<a id="328" class="Keyword">module</a> <a id="335" href="README.Case.html" class="Module">README.Case</a> <a id="347" class="Keyword">where</a>

<a id="354" class="Keyword">open</a> <a id="359" class="Keyword">import</a> <a id="366" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="377" class="Keyword">hiding</a> <a id="384" class="Symbol">(</a><a id="385" href="Data.Fin.Base.html#5489" class="Function">pred</a><a id="389" class="Symbol">)</a>
<a id="391" class="Keyword">open</a> <a id="396" class="Keyword">import</a> <a id="403" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="414" class="Keyword">hiding</a> <a id="421" class="Symbol">(</a><a id="422" href="Data.Maybe.Base.html#1925" class="Function">from-just</a><a id="431" class="Symbol">)</a>
<a id="433" class="Keyword">open</a> <a id="438" class="Keyword">import</a> <a id="445" href="Data.Nat.html" class="Module">Data.Nat</a>   <a id="456" class="Keyword">hiding</a> <a id="463" class="Symbol">(</a><a id="464" href="Data.Nat.Base.html#2741" class="Function">pred</a><a id="468" class="Symbol">)</a>
<a id="470" class="Keyword">open</a> <a id="475" class="Keyword">import</a> <a id="482" href="Data.List.html" class="Module">Data.List</a>
<a id="492" class="Keyword">open</a> <a id="497" class="Keyword">import</a> <a id="504" href="Data.Sum.html" class="Module">Data.Sum</a>
<a id="513" class="Keyword">open</a> <a id="518" class="Keyword">import</a> <a id="525" href="Data.Product.html" class="Module">Data.Product</a>
<a id="538" class="Keyword">open</a> <a id="543" class="Keyword">import</a> <a id="550" href="Function.html" class="Module">Function</a> <a id="559" class="Keyword">using</a> <a id="565" class="Symbol">(</a><a id="566" href="Function.Base.html#4121" class="Function Operator">case_of_</a><a id="574" class="Symbol">;</a> <a id="576" href="Function.Base.html#3034" class="Function Operator">case_return_of_</a><a id="591" class="Symbol">)</a>
<a id="593" class="Keyword">open</a> <a id="598" class="Keyword">import</a> <a id="605" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="622" class="Keyword">open</a> <a id="627" class="Keyword">import</a> <a id="634" href="Relation.Binary.html" class="Module">Relation.Binary</a>
<a id="650" class="Keyword">open</a> <a id="655" class="Keyword">import</a> <a id="662" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="701" class="Comment">------------------------------------------------------------------------</a>
<a id="774" class="Comment">-- Different types of pattern-matching lambdas</a>

<a id="822" class="Comment">-- absurd pattern</a>

<a id="empty"></a><a id="841" href="README.Case.html#841" class="Function">empty</a> <a id="847" class="Symbol">:</a> <a id="849" class="Symbol">∀</a> <a id="851" class="Symbol">{</a><a id="852" href="README.Case.html#852" class="Bound">a</a><a id="853" class="Symbol">}</a> <a id="855" class="Symbol">{</a><a id="856" href="README.Case.html#856" class="Bound">A</a> <a id="858" class="Symbol">:</a> <a id="860" class="PrimitiveType">Set</a> <a id="864" href="README.Case.html#852" class="Bound">a</a><a id="865" class="Symbol">}</a> <a id="867" class="Symbol">→</a> <a id="869" href="Data.Fin.Base.html#1138" class="Datatype">Fin</a> <a id="873" class="Number">0</a> <a id="875" class="Symbol">→</a> <a id="877" href="README.Case.html#856" class="Bound">A</a>
<a id="879" href="README.Case.html#841" class="Function">empty</a> <a id="885" href="README.Case.html#885" class="Bound">i</a> <a id="887" class="Symbol">=</a> <a id="889" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="894" href="README.Case.html#885" class="Bound">i</a> <a id="896" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="899" class="Symbol">λ</a> <a id="901" class="Symbol">()</a>

<a id="905" class="Comment">-- {}-delimited and ;-separated list of clauses</a>
<a id="953" class="Comment">-- Note that they do not need to be on different lines</a>

<a id="pred"></a><a id="1009" href="README.Case.html#1009" class="Function">pred</a> <a id="1014" class="Symbol">:</a> <a id="1016" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1018" class="Symbol">→</a> <a id="1020" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="1022" href="README.Case.html#1009" class="Function">pred</a> <a id="1027" href="README.Case.html#1027" class="Bound">n</a> <a id="1029" class="Symbol">=</a> <a id="1031" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="1036" href="README.Case.html#1027" class="Bound">n</a> <a id="1038" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="1041" class="Symbol">λ</a>
  <a id="1045" class="Symbol">{</a> <a id="1047" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="1055" class="Symbol">→</a> <a id="1057" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="1064" class="Symbol">;</a> <a id="1066" class="Symbol">(</a><a id="1067" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1071" href="README.Case.html#1071" class="Bound">n</a><a id="1072" class="Symbol">)</a> <a id="1074" class="Symbol">→</a> <a id="1076" href="README.Case.html#1071" class="Bound">n</a>
  <a id="1080" class="Symbol">}</a>

<a id="1083" class="Comment">-- where-introduced and indentation-identified block of list of clauses</a>

<a id="from-just"></a><a id="1156" href="README.Case.html#1156" class="Function">from-just</a> <a id="1166" class="Symbol">:</a> <a id="1168" class="Symbol">∀</a> <a id="1170" class="Symbol">{</a><a id="1171" href="README.Case.html#1171" class="Bound">a</a><a id="1172" class="Symbol">}</a> <a id="1174" class="Symbol">{</a><a id="1175" href="README.Case.html#1175" class="Bound">A</a> <a id="1177" class="Symbol">:</a> <a id="1179" class="PrimitiveType">Set</a> <a id="1183" href="README.Case.html#1171" class="Bound">a</a><a id="1184" class="Symbol">}</a> <a id="1186" class="Symbol">(</a><a id="1187" href="README.Case.html#1187" class="Bound">x</a> <a id="1189" class="Symbol">:</a> <a id="1191" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="1197" href="README.Case.html#1175" class="Bound">A</a><a id="1198" class="Symbol">)</a> <a id="1200" class="Symbol">→</a> <a id="1202" href="Data.Maybe.Base.html#1837" class="Function">From-just</a> <a id="1212" href="README.Case.html#1187" class="Bound">x</a>
<a id="1214" href="README.Case.html#1156" class="Function">from-just</a> <a id="1224" href="README.Case.html#1224" class="Bound">x</a> <a id="1226" class="Symbol">=</a> <a id="1228" href="Function.Base.html#3034" class="Function Operator">case</a> <a id="1233" href="README.Case.html#1224" class="Bound">x</a> <a id="1235" href="Function.Base.html#3034" class="Function Operator">return</a> <a id="1242" href="Data.Maybe.Base.html#1837" class="Function">From-just</a> <a id="1252" href="Function.Base.html#3034" class="Function Operator">of</a> <a id="1255" class="Symbol">λ</a> <a id="1257" class="Keyword">where</a>
  <a id="1265" class="Symbol">(</a><a id="1266" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a> <a id="1271" href="README.Case.html#1271" class="Bound">x</a><a id="1272" class="Symbol">)</a> <a id="1274" class="Symbol">→</a> <a id="1276" href="README.Case.html#1271" class="Bound">x</a>
  <a id="1280" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a>  <a id="1289" class="Symbol">→</a> <a id="1291" class="Symbol">_</a>

<a id="1294" class="Comment">------------------------------------------------------------------------</a>
<a id="1367" class="Comment">-- We can define some recursive functions with case</a>

<a id="plus"></a><a id="1420" href="README.Case.html#1420" class="Function">plus</a> <a id="1425" class="Symbol">:</a> <a id="1427" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1429" class="Symbol">→</a> <a id="1431" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1433" class="Symbol">→</a> <a id="1435" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="1437" href="README.Case.html#1420" class="Function">plus</a> <a id="1442" href="README.Case.html#1442" class="Bound">m</a> <a id="1444" href="README.Case.html#1444" class="Bound">n</a> <a id="1446" class="Symbol">=</a> <a id="1448" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="1453" href="README.Case.html#1442" class="Bound">m</a> <a id="1455" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="1458" class="Symbol">λ</a>
   <a id="1463" class="Symbol">{</a> <a id="1465" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="1473" class="Symbol">→</a> <a id="1475" href="README.Case.html#1444" class="Bound">n</a>
   <a id="1480" class="Symbol">;</a> <a id="1482" class="Symbol">(</a><a id="1483" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1487" href="README.Case.html#1487" class="Bound">m</a><a id="1488" class="Symbol">)</a> <a id="1490" class="Symbol">→</a> <a id="1492" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1496" class="Symbol">(</a><a id="1497" href="README.Case.html#1420" class="Function">plus</a> <a id="1502" href="README.Case.html#1487" class="Bound">m</a> <a id="1504" href="README.Case.html#1444" class="Bound">n</a><a id="1505" class="Symbol">)</a>
   <a id="1510" class="Symbol">}</a>

<a id="div2"></a><a id="1513" href="README.Case.html#1513" class="Function">div2</a> <a id="1518" class="Symbol">:</a> <a id="1520" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1522" class="Symbol">→</a> <a id="1524" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="1526" href="README.Case.html#1513" class="Function">div2</a> <a id="1531" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="1539" class="Symbol">=</a> <a id="1541" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
<a id="1546" href="README.Case.html#1513" class="Function">div2</a> <a id="1551" class="Symbol">(</a><a id="1552" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1556" href="README.Case.html#1556" class="Bound">m</a><a id="1557" class="Symbol">)</a> <a id="1559" class="Symbol">=</a> <a id="1561" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="1566" href="README.Case.html#1556" class="Bound">m</a> <a id="1568" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="1571" class="Symbol">λ</a> <a id="1573" class="Keyword">where</a>
  <a id="1581" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="1590" class="Symbol">→</a> <a id="1592" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>
  <a id="1599" class="Symbol">(</a><a id="1600" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1604" href="README.Case.html#1604" class="Bound">m′</a><a id="1606" class="Symbol">)</a> <a id="1608" class="Symbol">→</a> <a id="1610" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1614" class="Symbol">(</a><a id="1615" href="README.Case.html#1513" class="Function">div2</a> <a id="1620" href="README.Case.html#1604" class="Bound">m′</a><a id="1622" class="Symbol">)</a>


<a id="1626" class="Comment">-- Note that some natural uses of case are rejected by the termination</a>
<a id="1697" class="Comment">-- checker:</a>

<a id="1710" class="Comment">-- module _ {a} {A : Set a} (eq? : Decidable {A = A} _≡_) where</a>

<a id="1775" class="Comment">--  pairBy : List A → List (A ⊎ (A × A))</a>
<a id="1816" class="Comment">--  pairBy []           = []</a>
<a id="1845" class="Comment">--  pairBy (x ∷ [])     = inj₁ x ∷ []</a>
<a id="1883" class="Comment">--  pairBy (x ∷ y ∷ xs) = case eq? x y of λ where</a>
<a id="1933" class="Comment">--    (yes _) → inj₂ (x , y) ∷ pairBy xs</a>
<a id="1974" class="Comment">--    (no _)  → inj₁ x ∷ pairBy (y ∷ xs)</a>
</pre></body></html>