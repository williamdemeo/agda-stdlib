<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--cubical-compatible</a> <a id="305" class="Pragma">--safe</a> <a id="312" class="Symbol">#-}</a>

<a id="317" class="Keyword">module</a> <a id="324" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="342" class="Keyword">where</a>

<a id="349" class="Keyword">open</a> <a id="354" class="Keyword">import</a> <a id="361" href="Agda.Builtin.Reflection.html" class="Module">Agda.Builtin.Reflection</a>

<a id="386" class="Keyword">open</a> <a id="391" class="Keyword">import</a> <a id="398" href="Algebra.html" class="Module">Algebra</a>
<a id="406" class="Keyword">open</a> <a id="411" class="Keyword">import</a> <a id="418" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="429" class="Symbol">as</a> <a id="432" class="Module">Fin</a>   <a id="438" class="Keyword">using</a> <a id="444" class="Symbol">(</a><a id="445" href="Data.Fin.Base.html#1135" class="Datatype">Fin</a><a id="448" class="Symbol">)</a>
<a id="450" class="Keyword">open</a> <a id="455" class="Keyword">import</a> <a id="462" href="Data.Vec.html" class="Module">Data.Vec</a>   <a id="473" class="Symbol">as</a> <a id="476" class="Module">Vec</a>   <a id="482" class="Keyword">using</a> <a id="488" class="Symbol">(</a><a id="489" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a><a id="492" class="Symbol">;</a> <a id="494" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">_∷_</a><a id="497" class="Symbol">;</a> <a id="499" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a><a id="501" class="Symbol">)</a>
<a id="503" class="Keyword">open</a> <a id="508" class="Keyword">import</a> <a id="515" href="Data.List.html" class="Module">Data.List</a>  <a id="526" class="Symbol">as</a> <a id="529" class="Module">List</a>  <a id="535" class="Keyword">using</a> <a id="541" class="Symbol">(</a><a id="542" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="546" class="Symbol">;</a> <a id="548" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="551" class="Symbol">;</a> <a id="553" href="Data.List.Base.html#10392" class="InductiveConstructor">[]</a><a id="555" class="Symbol">)</a>
<a id="557" class="Keyword">open</a> <a id="562" class="Keyword">import</a> <a id="569" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="585" class="Symbol">as</a> <a id="588" class="Module">Maybe</a> <a id="594" class="Keyword">using</a> <a id="600" class="Symbol">(</a><a id="601" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a><a id="606" class="Symbol">;</a> <a id="608" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a><a id="612" class="Symbol">;</a> <a id="614" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="621" class="Symbol">;</a> <a id="623" href="Data.Maybe.Base.html#1641" class="Function">fromMaybe</a><a id="632" class="Symbol">)</a>
<a id="634" class="Keyword">open</a> <a id="639" class="Keyword">import</a> <a id="646" href="Data.Nat.html" class="Module">Data.Nat</a>            <a id="666" class="Keyword">using</a> <a id="672" class="Symbol">(</a><a id="673" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="674" class="Symbol">;</a> <a id="676" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="679" class="Symbol">;</a> <a id="681" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="685" class="Symbol">;</a> <a id="687" href="Data.Nat.Base.html#1310" class="Primitive Operator">_&lt;ᵇ_</a><a id="691" class="Symbol">)</a>
<a id="693" class="Keyword">open</a> <a id="698" class="Keyword">import</a> <a id="705" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a> <a id="725" class="Keyword">using</a> <a id="731" class="Symbol">(</a><a id="732" href="Data.Nat.Reflection.html#534" class="Function">toTerm</a><a id="738" class="Symbol">;</a> <a id="740" href="Data.Nat.Reflection.html#646" class="Function">toFinTerm</a><a id="749" class="Symbol">)</a>
<a id="751" class="Keyword">open</a> <a id="756" class="Keyword">import</a> <a id="763" href="Data.Bool.html" class="Module">Data.Bool</a>           <a id="783" class="Keyword">using</a> <a id="789" class="Symbol">(</a><a id="790" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="794" class="Symbol">;</a> <a id="796" href="Data.Bool.Base.html#1292" class="Function Operator">if_then_else_</a><a id="809" class="Symbol">;</a> <a id="811" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a><a id="815" class="Symbol">;</a> <a id="817" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a><a id="822" class="Symbol">)</a>
<a id="824" class="Keyword">open</a> <a id="829" class="Keyword">import</a> <a id="836" href="Data.Unit.html" class="Module">Data.Unit</a>           <a id="856" class="Keyword">using</a> <a id="862" class="Symbol">(</a><a id="863" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a><a id="864" class="Symbol">)</a>
<a id="866" class="Keyword">open</a> <a id="871" class="Keyword">import</a> <a id="878" href="Data.String.html" class="Module">Data.String</a>         <a id="898" class="Keyword">using</a> <a id="904" class="Symbol">(</a><a id="905" href="Agda.Builtin.String.html#335" class="Postulate">String</a><a id="911" class="Symbol">)</a>
<a id="913" class="Keyword">open</a> <a id="918" class="Keyword">import</a> <a id="925" href="Data.Product.html" class="Module">Data.Product</a>        <a id="945" class="Keyword">using</a> <a id="951" class="Symbol">(</a><a id="952" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="955" class="Symbol">)</a>
<a id="957" class="Keyword">open</a> <a id="962" class="Keyword">import</a> <a id="969" href="Function.html" class="Module">Function</a>
<a id="978" class="Keyword">open</a> <a id="983" class="Keyword">import</a> <a id="990" href="Reflection.Argument.html" class="Module">Reflection.Argument</a>
<a id="1010" class="Keyword">open</a> <a id="1015" class="Keyword">import</a> <a id="1022" href="Reflection.Term.html" class="Module">Reflection.Term</a>
<a id="1038" class="Keyword">open</a> <a id="1043" class="Keyword">import</a> <a id="1050" href="Reflection.TypeChecking.Monad.Syntax.html" class="Module">Reflection.TypeChecking.Monad.Syntax</a>

<a id="1088" class="Keyword">open</a> <a id="1093" class="Keyword">import</a> <a id="1100" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1132" class="Keyword">renaming</a> <a id="1141" class="Symbol">(</a><a id="1142" href="Tactic.RingSolver.NonReflective.html#2962" class="Function">solve</a> <a id="1148" class="Symbol">to</a> <a id="1151" class="Function">solve-fn</a><a id="1159" class="Symbol">)</a>
<a id="1161" class="Keyword">open</a> <a id="1166" class="Keyword">import</a> <a id="1173" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1218" class="Keyword">open</a> <a id="1223" class="Keyword">import</a> <a id="1230" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1260" class="Symbol">as</a> <a id="1263" class="Module">NatSet</a>
<a id="1270" class="Keyword">open</a> <a id="1275" class="Keyword">import</a> <a id="1282" href="Tactic.RingSolver.Core.ReflectionHelp.html" class="Module">Tactic.RingSolver.Core.ReflectionHelp</a>

<a id="1321" class="Keyword">open</a> <a id="1326" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1258" class="Module">AlmostCommutativeRing</a>

<a id="1349" class="Comment">------------------------------------------------------------------------</a>
<a id="1422" class="Comment">-- Processing</a>
<a id="1436" class="Comment">------------------------------------------------------------------------</a>

<a id="1510" class="Keyword">private</a>
  <a id="1520" class="Keyword">record</a> <a id="RingNames"></a><a id="1527" href="Tactic.RingSolver.html#1527" class="Record">RingNames</a> <a id="1537" class="Symbol">:</a> <a id="1539" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="1543" class="Keyword">where</a>
    <a id="1553" class="Keyword">constructor</a> <a id="+⇒_*⇒_^⇒_-⇒_"></a><a id="1565" href="Tactic.RingSolver.html#1565" class="InductiveConstructor Operator">+⇒_*⇒_^⇒_-⇒_</a>
    <a id="1582" class="Keyword">field</a>
      <a id="RingNames.+′"></a><a id="1594" href="Tactic.RingSolver.html#1594" class="Field">+′</a> <a id="RingNames.*′"></a><a id="1597" href="Tactic.RingSolver.html#1597" class="Field">*′</a> <a id="RingNames.^′"></a><a id="1600" href="Tactic.RingSolver.html#1600" class="Field">^′</a> <a id="RingNames.-′"></a><a id="1603" href="Tactic.RingSolver.html#1603" class="Field">-′</a> <a id="1606" class="Symbol">:</a> <a id="1608" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1614" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a>

  <a id="checkIsRing"></a><a id="1622" href="Tactic.RingSolver.html#1622" class="Function">checkIsRing</a> <a id="1634" class="Symbol">:</a> <a id="1636" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1641" class="Symbol">→</a> <a id="1643" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="1646" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="1653" href="Tactic.RingSolver.html#1622" class="Function">checkIsRing</a> <a id="1665" href="Tactic.RingSolver.html#1665" class="Bound">ring</a> <a id="1670" class="Symbol">=</a> <a id="1672" href="Agda.Builtin.Reflection.html#8914" class="Postulate">checkType</a> <a id="1682" href="Tactic.RingSolver.html#1665" class="Bound">ring</a> <a id="1687" class="Symbol">(</a><a id="1688" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="1692" class="Symbol">(</a><a id="1693" class="Keyword">quote</a> <a id="1699" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1258" class="Record">AlmostCommutativeRing</a><a id="1720" class="Symbol">)</a> <a id="1722" class="Symbol">(</a><a id="1723" class="Number">2</a> <a id="1725" href="Reflection.Term.html#2451" class="Function Operator">⋯⟨∷⟩</a> <a id="1730" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="1732" class="Symbol">))</a>

  <a id="getVariableIDs"></a><a id="1738" href="Tactic.RingSolver.html#1738" class="Function">getVariableIDs</a> <a id="1753" class="Symbol">:</a> <a id="1755" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1760" class="Symbol">→</a> <a id="1762" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1768" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a>
  <a id="1777" href="Tactic.RingSolver.html#1738" class="Function">getVariableIDs</a> <a id="1792" class="Symbol">=</a> <a id="1794" href="Tactic.RingSolver.html#1814" class="Function">go</a> <a id="1797" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
    <a id="1804" class="Keyword">where</a>
    <a id="1814" href="Tactic.RingSolver.html#1814" class="Function">go</a> <a id="1817" class="Symbol">:</a> <a id="1819" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a> <a id="1826" class="Symbol">→</a> <a id="1828" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1833" class="Symbol">→</a> <a id="1835" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="1841" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a>
    <a id="1852" href="Tactic.RingSolver.html#1814" class="Function">go</a> <a id="1855" href="Tactic.RingSolver.html#1855" class="Bound">t</a> <a id="1857" class="Symbol">(</a><a id="1858" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="1862" class="Symbol">(</a><a id="1863" class="Keyword">quote</a> <a id="1869" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">List._∷_</a><a id="1877" class="Symbol">)</a> <a id="1879" class="Symbol">(_</a> <a id="1882" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1884" class="Symbol">_</a> <a id="1886" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1888" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="1892" href="Tactic.RingSolver.html#1892" class="Bound">i</a> <a id="1894" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="1897" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="1901" href="Tactic.RingSolver.html#1901" class="Bound">xs</a> <a id="1904" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="1908" class="Symbol">_))</a> <a id="1912" class="Symbol">=</a> <a id="1914" href="Tactic.RingSolver.html#1814" class="Function">go</a> <a id="1917" class="Symbol">(</a><a id="1918" href="Tactic.RingSolver.Core.NatSet.html#2242" class="Function">insert</a> <a id="1925" href="Tactic.RingSolver.html#1892" class="Bound">i</a> <a id="1927" href="Tactic.RingSolver.html#1855" class="Bound">t</a><a id="1928" class="Symbol">)</a> <a id="1930" href="Tactic.RingSolver.html#1901" class="Bound">xs</a>
    <a id="1937" href="Tactic.RingSolver.html#1814" class="Function">go</a> <a id="1940" href="Tactic.RingSolver.html#1940" class="Bound">t</a> <a id="1942" class="Symbol">(</a><a id="1943" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="1947" class="Symbol">(</a><a id="1948" class="Keyword">quote</a> <a id="1954" href="Agda.Builtin.List.html#184" class="InductiveConstructor">List.List.[]</a><a id="1966" class="Symbol">)</a> <a id="1968" class="Symbol">_)</a>                           <a id="1997" class="Symbol">=</a> <a id="1999" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2004" href="Tactic.RingSolver.html#1940" class="Bound">t</a>
    <a id="2010" href="Tactic.RingSolver.html#1814" class="CatchallClause Function">go</a><a id="2012" class="CatchallClause"> </a><a id="2013" class="CatchallClause Symbol">_</a><a id="2014" class="CatchallClause"> </a><a id="2015" class="CatchallClause Symbol">_</a>                                                      <a id="2070" class="Symbol">=</a> <a id="2072" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

  <a id="2083" class="Keyword">module</a> <a id="OverRing"></a><a id="2090" href="Tactic.RingSolver.html#2090" class="Module">OverRing</a> <a id="2099" class="Symbol">(</a><a id="2100" href="Tactic.RingSolver.html#2100" class="Bound">ring</a> <a id="2105" class="Symbol">:</a> <a id="2107" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="2111" class="Symbol">)</a> <a id="2113" class="Keyword">where</a>

    <a id="2124" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
    <a id="2194" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
    <a id="2263" class="Comment">-- the required ring arguments</a>
    <a id="2298" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
    <a id="2348" class="Keyword">infixr</a> <a id="2355" class="Number">6</a> <a id="2357" href="Tactic.RingSolver.html#2367" class="Function Operator">_$ʳ_</a>

    <a id="OverRing._$ʳ_"></a><a id="2367" href="Tactic.RingSolver.html#2367" class="Function Operator">_$ʳ_</a> <a id="2372" class="Symbol">:</a> <a id="2374" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="2379" class="Symbol">→</a> <a id="2381" href="Reflection.Argument.html#1493" class="Function">Args</a> <a id="2386" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2391" class="Symbol">→</a> <a id="2393" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="2402" href="Tactic.RingSolver.html#2402" class="Bound">nm</a> <a id="2405" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="2408" href="Tactic.RingSolver.html#2408" class="Bound">args</a> <a id="2413" class="Symbol">=</a> <a id="2415" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2419" href="Tactic.RingSolver.html#2402" class="Bound">nm</a> <a id="2422" class="Symbol">(</a><a id="2423" class="Number">2</a> <a id="2425" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a> <a id="2430" href="Tactic.RingSolver.html#2100" class="Bound">ring</a> <a id="2435" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="2439" href="Tactic.RingSolver.html#2408" class="Bound">args</a><a id="2443" class="Symbol">)</a>

    <a id="OverRing.checkIsListOfVariables"></a><a id="2450" href="Tactic.RingSolver.html#2450" class="Function">checkIsListOfVariables</a> <a id="2473" class="Symbol">:</a> <a id="2475" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2480" class="Symbol">→</a> <a id="2482" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2485" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="2494" href="Tactic.RingSolver.html#2450" class="Function">checkIsListOfVariables</a> <a id="2517" href="Tactic.RingSolver.html#2517" class="Bound">xs</a> <a id="2520" class="Symbol">=</a>
      <a id="2528" href="Agda.Builtin.Reflection.html#8914" class="Postulate">checkType</a> <a id="2538" href="Tactic.RingSolver.html#2517" class="Bound">xs</a> <a id="2541" class="Symbol">(</a><a id="2542" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2546" class="Symbol">(</a><a id="2547" class="Keyword">quote</a> <a id="2553" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="2557" class="Symbol">)</a> <a id="2559" class="Symbol">(</a><a id="2560" class="Number">1</a> <a id="2562" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a> <a id="2567" class="Symbol">(</a><a id="2568" class="Keyword">quote</a> <a id="2574" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1396" class="Field">Carrier</a> <a id="2582" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="2585" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2587" class="Symbol">)</a> <a id="2589" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="2593" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2595" class="Symbol">))</a> <a id="2598" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">&gt;&gt;=</a> <a id="2602" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a>

    <a id="OverRing.getFieldName"></a><a id="2617" href="Tactic.RingSolver.html#2617" class="Function">getFieldName</a> <a id="2630" class="Symbol">:</a> <a id="2632" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="2637" class="Symbol">→</a> <a id="2639" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2642" class="Symbol">(</a><a id="2643" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2649" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="2653" class="Symbol">)</a>
    <a id="2659" href="Tactic.RingSolver.html#2617" class="Function">getFieldName</a> <a id="2672" href="Tactic.RingSolver.html#2672" class="Bound">nm</a> <a id="2675" class="Symbol">=</a> <a id="2677" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="2687" class="Symbol">(</a><a id="2688" href="Tactic.RingSolver.html#2672" class="Bound">nm</a> <a id="2691" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="2694" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2696" class="Symbol">)</a> <a id="2698" href="Reflection.TypeChecking.Monad.Syntax.html#1163" class="Function Operator">&lt;&amp;&gt;</a> <a id="2702" class="Symbol">λ</a> <a id="2704" class="Keyword">where</a>
      <a id="2716" class="Symbol">(</a><a id="2717" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2721" href="Tactic.RingSolver.html#2721" class="Bound">f</a> <a id="2723" href="Tactic.RingSolver.html#2723" class="Bound">args</a><a id="2727" class="Symbol">)</a> <a id="2729" class="Symbol">→</a> <a id="2731" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2736" href="Tactic.RingSolver.html#2721" class="Bound">f</a>
      <a id="2744" class="CatchallClause Symbol">_</a>            <a id="2757" class="Symbol">→</a> <a id="2759" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

    <a id="OverRing.getRingOperatorNames"></a><a id="2772" href="Tactic.RingSolver.html#2772" class="Function">getRingOperatorNames</a> <a id="2793" class="Symbol">:</a> <a id="2795" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="2798" href="Tactic.RingSolver.html#1527" class="Record">RingNames</a>
    <a id="2812" href="Tactic.RingSolver.html#2772" class="Function">getRingOperatorNames</a> <a id="2833" class="Symbol">=</a> <a id="2835" class="Symbol">⦇</a>
      <a id="2843" href="Tactic.RingSolver.html#1565" class="InductiveConstructor Operator">+⇒</a> <a id="2846" href="Tactic.RingSolver.html#2617" class="Function">getFieldName</a> <a id="2859" class="Symbol">(</a><a id="2860" class="Keyword">quote</a> <a id="2866" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1476" class="Field Operator">_+_</a><a id="2869" class="Symbol">)</a>
      <a id="2877" href="Tactic.RingSolver.html#1565" class="InductiveConstructor Operator">*⇒</a> <a id="2880" href="Tactic.RingSolver.html#2617" class="Function">getFieldName</a> <a id="2893" class="Symbol">(</a><a id="2894" class="Keyword">quote</a> <a id="2900" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1518" class="Field Operator">_*_</a><a id="2903" class="Symbol">)</a>
      <a id="2911" href="Tactic.RingSolver.html#1565" class="InductiveConstructor Operator">^⇒</a> <a id="2914" href="Tactic.RingSolver.html#2617" class="Function">getFieldName</a> <a id="2927" class="Symbol">(</a><a id="2928" class="Keyword">quote</a> <a id="2934" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2417" class="Function Operator">_^_</a><a id="2937" class="Symbol">)</a>
      <a id="2945" href="Tactic.RingSolver.html#1565" class="InductiveConstructor Operator">-⇒</a> <a id="2948" href="Tactic.RingSolver.html#2617" class="Function">getFieldName</a> <a id="2961" class="Symbol">(</a><a id="2962" class="Keyword">quote</a> <a id="2968" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1560" class="Field Operator">-_</a><a id="2970" class="Symbol">)</a>
      <a id="2978" class="Symbol">⦈</a>

    <a id="2985" class="Keyword">module</a> <a id="2992" href="Tactic.RingSolver.html#2992" class="Module">_</a> <a id="2994" class="Symbol">(</a><a id="2995" href="Tactic.RingSolver.html#2995" class="Bound">nms</a> <a id="2999" class="Symbol">:</a> <a id="3001" href="Tactic.RingSolver.html#1527" class="Record">RingNames</a><a id="3010" class="Symbol">)</a> <a id="3012" class="Symbol">(</a><a id="3013" href="Tactic.RingSolver.html#3013" class="Bound">numVars</a> <a id="3021" class="Symbol">:</a> <a id="3023" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3024" class="Symbol">)</a> <a id="3026" class="Keyword">where</a>
      <a id="3038" class="Keyword">open</a> <a id="3043" href="Tactic.RingSolver.html#1527" class="Module">RingNames</a> <a id="3053" href="Tactic.RingSolver.html#2995" class="Bound">nms</a>

      <a id="3064" class="Comment">-- This function applies the hidden arguments that the constructors</a>
      <a id="3138" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
      <a id="3215" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
      <a id="3288" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
      <a id="3361" class="Comment">-- make things easier we supply the third because we know it.</a>
      <a id="3429" class="Keyword">infix</a> <a id="3435" class="Number">-1</a> <a id="3438" href="Tactic.RingSolver.html#3449" class="Function Operator">_$ᵉ_</a>
      <a id="3449" href="Tactic.RingSolver.html#3449" class="Function Operator">_$ᵉ_</a> <a id="3454" class="Symbol">:</a> <a id="3456" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="3461" class="Symbol">→</a> <a id="3463" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3468" class="Symbol">(</a><a id="3469" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="3473" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3477" class="Symbol">)</a> <a id="3479" class="Symbol">→</a> <a id="3481" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="3492" href="Tactic.RingSolver.html#3492" class="Bound">e</a> <a id="3494" href="Tactic.RingSolver.html#3449" class="Function Operator">$ᵉ</a> <a id="3497" href="Tactic.RingSolver.html#3497" class="Bound">xs</a> <a id="3500" class="Symbol">=</a> <a id="3502" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="3506" href="Tactic.RingSolver.html#3492" class="Bound">e</a> <a id="3508" class="Symbol">(</a><a id="3509" class="Number">1</a> <a id="3511" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a> <a id="3516" class="Keyword">quote</a> <a id="3522" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1396" class="Field">Carrier</a> <a id="3530" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="3533" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="3536" href="Reflection.Argument.html#1617" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="3540" href="Data.Nat.Reflection.html#534" class="Function">toTerm</a> <a id="3547" href="Tactic.RingSolver.html#3013" class="Bound">numVars</a> <a id="3555" href="Reflection.Argument.html#1617" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="3559" href="Tactic.RingSolver.html#3497" class="Bound">xs</a><a id="3561" class="Symbol">)</a>

      <a id="3570" class="Comment">-- A constant expression.</a>
      <a id="3602" href="Tactic.RingSolver.html#3602" class="Function">Κ′</a> <a id="3605" class="Symbol">:</a> <a id="3607" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3612" class="Symbol">→</a> <a id="3614" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="3625" href="Tactic.RingSolver.html#3602" class="Function">Κ′</a> <a id="3628" href="Tactic.RingSolver.html#3628" class="Bound">x</a> <a id="3630" class="Symbol">=</a> <a id="3632" class="Keyword">quote</a> <a id="3638" href="Tactic.RingSolver.Core.Expression.html#547" class="InductiveConstructor">Κ</a> <a id="3640" href="Tactic.RingSolver.html#3449" class="Function Operator">$ᵉ</a> <a id="3643" class="Symbol">(</a><a id="3644" href="Tactic.RingSolver.html#3628" class="Bound">x</a> <a id="3646" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3650" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="3652" class="Symbol">)</a>

      <a id="3661" class="Keyword">infix</a> <a id="3667" class="Number">4</a> <a id="3669" href="Tactic.RingSolver.html#3680" class="Function Operator">_⇓≟_</a>
      <a id="3680" href="Tactic.RingSolver.html#3680" class="Function Operator">_⇓≟_</a> <a id="3685" class="Symbol">:</a> <a id="3687" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="3693" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="3698" class="Symbol">→</a> <a id="3700" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="3705" class="Symbol">→</a> <a id="3707" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
      <a id="3718" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="3726" href="Tactic.RingSolver.html#3680" class="Function Operator">⇓≟</a> <a id="3729" class="Symbol">_</a> <a id="3731" class="Symbol">=</a> <a id="3733" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a>
      <a id="3745" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="3750" href="Tactic.RingSolver.html#3750" class="Bound">x</a>  <a id="3753" href="Tactic.RingSolver.html#3680" class="Function Operator">⇓≟</a> <a id="3756" href="Tactic.RingSolver.html#3756" class="Bound">y</a> <a id="3758" class="Symbol">=</a> <a id="3760" href="Agda.Builtin.Reflection.html#539" class="Primitive">primQNameEquality</a> <a id="3778" href="Tactic.RingSolver.html#3750" class="Bound">x</a> <a id="3780" href="Tactic.RingSolver.html#3756" class="Bound">y</a>
      <a id="3788" class="Symbol">{-#</a> <a id="3792" class="Keyword">INLINE</a> <a id="3799" href="Tactic.RingSolver.html#3680" class="Function Operator">_⇓≟_</a> <a id="3804" class="Symbol">#-}</a>

      <a id="3815" class="Keyword">module</a> <a id="3822" href="Tactic.RingSolver.html#3822" class="Module">ToExpr</a> <a id="3829" class="Symbol">(</a><a id="3830" href="Tactic.RingSolver.html#3830" class="Bound">Ι′</a> <a id="3833" class="Symbol">:</a> <a id="3835" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="3837" class="Symbol">→</a> <a id="3839" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="3845" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3849" class="Symbol">)</a> <a id="3851" class="Keyword">where</a>
        <a id="3865" class="Keyword">mutual</a>
          <a id="3882" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
          <a id="3955" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
          <a id="4029" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
          <a id="4102" class="Comment">-- by just taking the last two explicit arguments.</a>
          <a id="4163" href="Tactic.RingSolver.html#4163" class="Function Operator">E⟨_⟩₂</a> <a id="4169" class="Symbol">:</a> <a id="4171" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="4176" class="Symbol">→</a> <a id="4178" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4183" class="Symbol">(</a><a id="4184" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4188" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="4192" class="Symbol">)</a> <a id="4194" class="Symbol">→</a> <a id="4196" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
          <a id="4211" href="Tactic.RingSolver.html#4163" class="Function Operator">E⟨</a> <a id="4214" href="Tactic.RingSolver.html#4214" class="Bound">nm</a> <a id="4217" href="Tactic.RingSolver.html#4163" class="Function Operator">⟩₂</a> <a id="4220" class="Symbol">(</a><a id="4221" href="Tactic.RingSolver.html#4221" class="Bound">x</a> <a id="4223" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4227" href="Tactic.RingSolver.html#4227" class="Bound">y</a> <a id="4229" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4233" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4235" class="Symbol">)</a> <a id="4237" class="Symbol">=</a> <a id="4239" href="Tactic.RingSolver.html#4214" class="Bound">nm</a> <a id="4242" href="Tactic.RingSolver.html#3449" class="Function Operator">$ᵉ</a> <a id="4245" class="Symbol">(</a><a id="4246" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="4248" href="Tactic.RingSolver.html#4221" class="Bound">x</a> <a id="4250" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4254" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="4256" href="Tactic.RingSolver.html#4227" class="Bound">y</a> <a id="4258" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4262" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4264" class="Symbol">)</a>
          <a id="4276" href="Tactic.RingSolver.html#4163" class="CatchallClause Function Operator">E⟨</a><a id="4278" class="CatchallClause"> </a><a id="4279" href="Tactic.RingSolver.html#4279" class="CatchallClause Bound">nm</a><a id="4281" class="CatchallClause"> </a><a id="4282" href="Tactic.RingSolver.html#4163" class="CatchallClause Function Operator">⟩₂</a><a id="4284" class="CatchallClause"> </a><a id="4285" class="CatchallClause Symbol">(</a><a id="4286" href="Tactic.RingSolver.html#4286" class="CatchallClause Bound">x</a><a id="4287" class="CatchallClause"> </a><a id="4288" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4289" class="CatchallClause"> </a><a id="4290" href="Tactic.RingSolver.html#4290" class="CatchallClause Bound">xs</a><a id="4292" class="CatchallClause Symbol">)</a>         <a id="4302" class="Symbol">=</a> <a id="4304" href="Tactic.RingSolver.html#4163" class="Function Operator">E⟨</a> <a id="4307" href="Tactic.RingSolver.html#4279" class="Bound">nm</a> <a id="4310" href="Tactic.RingSolver.html#4163" class="Function Operator">⟩₂</a> <a id="4313" href="Tactic.RingSolver.html#4290" class="Bound">xs</a>
          <a id="4326" href="Tactic.RingSolver.html#4163" class="CatchallClause Function Operator">E⟨</a><a id="4328" class="CatchallClause"> </a><a id="4329" href="Tactic.RingSolver.html#4329" class="CatchallClause Bound">nm</a><a id="4331" class="CatchallClause"> </a><a id="4332" href="Tactic.RingSolver.html#4163" class="CatchallClause Function Operator">⟩₂</a><a id="4334" class="CatchallClause"> </a><a id="4335" class="CatchallClause Symbol">_</a>                <a id="4352" class="Symbol">=</a> <a id="4354" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

          <a id="4373" href="Tactic.RingSolver.html#4373" class="Function Operator">E⟨_⟩₁</a> <a id="4379" class="Symbol">:</a> <a id="4381" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="4386" class="Symbol">→</a> <a id="4388" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4393" class="Symbol">(</a><a id="4394" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4398" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="4402" class="Symbol">)</a> <a id="4404" class="Symbol">→</a> <a id="4406" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
          <a id="4421" href="Tactic.RingSolver.html#4373" class="Function Operator">E⟨</a> <a id="4424" href="Tactic.RingSolver.html#4424" class="Bound">nm</a> <a id="4427" href="Tactic.RingSolver.html#4373" class="Function Operator">⟩₁</a> <a id="4430" class="Symbol">(</a><a id="4431" href="Tactic.RingSolver.html#4431" class="Bound">x</a> <a id="4433" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4437" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4439" class="Symbol">)</a> <a id="4441" class="Symbol">=</a> <a id="4443" href="Tactic.RingSolver.html#4424" class="Bound">nm</a> <a id="4446" href="Tactic.RingSolver.html#3449" class="Function Operator">$ᵉ</a> <a id="4449" class="Symbol">(</a><a id="4450" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="4452" href="Tactic.RingSolver.html#4431" class="Bound">x</a> <a id="4454" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4458" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4460" class="Symbol">)</a>
          <a id="4472" href="Tactic.RingSolver.html#4373" class="CatchallClause Function Operator">E⟨</a><a id="4474" class="CatchallClause"> </a><a id="4475" href="Tactic.RingSolver.html#4475" class="CatchallClause Bound">nm</a><a id="4477" class="CatchallClause"> </a><a id="4478" href="Tactic.RingSolver.html#4373" class="CatchallClause Function Operator">⟩₁</a><a id="4480" class="CatchallClause"> </a><a id="4481" class="CatchallClause Symbol">(</a><a id="4482" href="Tactic.RingSolver.html#4482" class="CatchallClause Bound">x</a><a id="4483" class="CatchallClause"> </a><a id="4484" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4485" class="CatchallClause"> </a><a id="4486" href="Tactic.RingSolver.html#4486" class="CatchallClause Bound">xs</a><a id="4488" class="CatchallClause Symbol">)</a>   <a id="4492" class="Symbol">=</a> <a id="4494" href="Tactic.RingSolver.html#4373" class="Function Operator">E⟨</a> <a id="4497" href="Tactic.RingSolver.html#4475" class="Bound">nm</a> <a id="4500" href="Tactic.RingSolver.html#4373" class="Function Operator">⟩₁</a> <a id="4503" href="Tactic.RingSolver.html#4486" class="Bound">xs</a>
          <a id="4516" href="Tactic.RingSolver.html#4373" class="CatchallClause Function Operator">E⟨</a><a id="4518" class="CatchallClause"> </a><a id="4519" class="CatchallClause Symbol">_</a><a id="4520" class="CatchallClause">  </a><a id="4522" href="Tactic.RingSolver.html#4373" class="CatchallClause Function Operator">⟩₁</a><a id="4524" class="CatchallClause"> </a><a id="4525" class="CatchallClause Symbol">_</a>          <a id="4536" class="Symbol">=</a> <a id="4538" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

          <a id="4557" href="Tactic.RingSolver.html#4557" class="Function">E⟨^⟩</a> <a id="4562" class="Symbol">:</a> <a id="4564" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="4569" class="Symbol">(</a><a id="4570" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="4574" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="4578" class="Symbol">)</a> <a id="4580" class="Symbol">→</a> <a id="4582" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
          <a id="4597" href="Tactic.RingSolver.html#4557" class="Function">E⟨^⟩</a> <a id="4602" class="Symbol">(</a><a id="4603" href="Tactic.RingSolver.html#4603" class="Bound">x</a> <a id="4605" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4609" href="Tactic.RingSolver.html#4609" class="Bound">y</a> <a id="4611" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4615" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4617" class="Symbol">)</a> <a id="4619" class="Symbol">=</a> <a id="4621" class="Keyword">quote</a> <a id="4627" href="Tactic.RingSolver.Core.Expression.html#757" class="InductiveConstructor Operator">_⊛_</a> <a id="4631" href="Tactic.RingSolver.html#3449" class="Function Operator">$ᵉ</a> <a id="4634" class="Symbol">(</a><a id="4635" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="4637" href="Tactic.RingSolver.html#4603" class="Bound">x</a> <a id="4639" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4643" href="Tactic.RingSolver.html#4609" class="Bound">y</a> <a id="4645" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4649" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4651" class="Symbol">)</a>
          <a id="4663" href="Tactic.RingSolver.html#4557" class="CatchallClause Function">E⟨^⟩</a><a id="4667" class="CatchallClause"> </a><a id="4668" class="CatchallClause Symbol">(</a><a id="4669" href="Tactic.RingSolver.html#4669" class="CatchallClause Bound">x</a><a id="4670" class="CatchallClause"> </a><a id="4671" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4672" class="CatchallClause"> </a><a id="4673" href="Tactic.RingSolver.html#4673" class="CatchallClause Bound">xs</a><a id="4675" class="CatchallClause Symbol">)</a>         <a id="4685" class="Symbol">=</a> <a id="4687" href="Tactic.RingSolver.html#4557" class="Function">E⟨^⟩</a> <a id="4692" href="Tactic.RingSolver.html#4673" class="Bound">xs</a>
          <a id="4705" href="Tactic.RingSolver.html#4557" class="CatchallClause Function">E⟨^⟩</a><a id="4709" class="CatchallClause"> </a><a id="4710" class="CatchallClause Symbol">_</a>                <a id="4727" class="Symbol">=</a> <a id="4729" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

          <a id="4748" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
          <a id="4822" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
          <a id="4893" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
          <a id="4967" class="Comment">-- might look for its constructors: however, we want to deal with</a>
          <a id="5043" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
          <a id="5118" class="Comment">-- Term type contained type information we might be able to</a>
          <a id="5188" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
          <a id="5237" class="Comment">--</a>
          <a id="5250" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
          <a id="5327" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
          <a id="5403" class="Comment">-- will just assume that it has a constant expression.</a>
          <a id="5468" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="5470" class="Symbol">:</a> <a id="5472" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="5477" class="Symbol">→</a> <a id="5479" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
          <a id="5494" class="Comment">-- Recognise the ring&#39;s fields</a>
          <a id="5535" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="5537" class="Symbol">(</a><a id="5538" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="5542" class="Symbol">(</a><a id="5543" class="Keyword">quote</a> <a id="5549" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1476" class="Field Operator">_+_</a><a id="5552" class="Symbol">)</a> <a id="5554" href="Tactic.RingSolver.html#5554" class="Bound">xs</a><a id="5556" class="Symbol">)</a> <a id="5558" class="Symbol">=</a> <a id="5560" href="Tactic.RingSolver.html#4163" class="Function Operator">E⟨</a> <a id="5563" class="Keyword">quote</a> <a id="5569" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a> <a id="5573" href="Tactic.RingSolver.html#4163" class="Function Operator">⟩₂</a> <a id="5576" href="Tactic.RingSolver.html#5554" class="Bound">xs</a>
          <a id="5589" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="5591" class="Symbol">(</a><a id="5592" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="5596" class="Symbol">(</a><a id="5597" class="Keyword">quote</a> <a id="5603" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1518" class="Field Operator">_*_</a><a id="5606" class="Symbol">)</a> <a id="5608" href="Tactic.RingSolver.html#5608" class="Bound">xs</a><a id="5610" class="Symbol">)</a> <a id="5612" class="Symbol">=</a> <a id="5614" href="Tactic.RingSolver.html#4163" class="Function Operator">E⟨</a> <a id="5617" class="Keyword">quote</a> <a id="5623" href="Tactic.RingSolver.Core.Expression.html#700" class="InductiveConstructor Operator">_⊗_</a> <a id="5627" href="Tactic.RingSolver.html#4163" class="Function Operator">⟩₂</a> <a id="5630" href="Tactic.RingSolver.html#5608" class="Bound">xs</a>
          <a id="5643" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="5645" class="Symbol">(</a><a id="5646" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="5650" class="Symbol">(</a><a id="5651" class="Keyword">quote</a> <a id="5657" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2417" class="Function Operator">_^_</a><a id="5660" class="Symbol">)</a> <a id="5662" href="Tactic.RingSolver.html#5662" class="Bound">xs</a><a id="5664" class="Symbol">)</a> <a id="5666" class="Symbol">=</a> <a id="5668" href="Tactic.RingSolver.html#4557" class="Function">E⟨^⟩</a> <a id="5673" href="Tactic.RingSolver.html#5662" class="Bound">xs</a>
          <a id="5686" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="5688" class="Symbol">(</a><a id="5689" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="5693" class="Symbol">(</a><a id="5694" class="Keyword">quote</a> <a id="5700" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1560" class="Field Operator">-_</a><a id="5702" class="Symbol">)</a>  <a id="5705" href="Tactic.RingSolver.html#5705" class="Bound">xs</a><a id="5707" class="Symbol">)</a> <a id="5709" class="Symbol">=</a> <a id="5711" href="Tactic.RingSolver.html#4373" class="Function Operator">E⟨</a> <a id="5714" class="Keyword">quote</a> <a id="5720" href="Tactic.RingSolver.Core.Expression.html#814" class="InductiveConstructor Operator">⊝_</a> <a id="5723" href="Tactic.RingSolver.html#4373" class="Function Operator">⟩₁</a> <a id="5726" href="Tactic.RingSolver.html#5705" class="Bound">xs</a>
          <a id="5739" class="Comment">-- Recognise the underlying implementation of the ring&#39;s fields</a>
          <a id="5813" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="5815" class="Symbol">(</a><a id="5816" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="5820" href="Tactic.RingSolver.html#5820" class="Bound">nm</a>          <a id="5832" href="Tactic.RingSolver.html#5832" class="Bound">xs</a><a id="5834" class="Symbol">)</a> <a id="5836" class="Symbol">=</a> <a id="5838" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="5841" href="Tactic.RingSolver.html#1594" class="Function">+′</a> <a id="5844" href="Tactic.RingSolver.html#3680" class="Function Operator">⇓≟</a> <a id="5847" href="Tactic.RingSolver.html#5820" class="Bound">nm</a> <a id="5850" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="5855" href="Tactic.RingSolver.html#4163" class="Function Operator">E⟨</a> <a id="5858" class="Keyword">quote</a> <a id="5864" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a> <a id="5868" href="Tactic.RingSolver.html#4163" class="Function Operator">⟩₂</a> <a id="5871" href="Tactic.RingSolver.html#5832" class="Bound">xs</a> <a id="5874" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
                                   <a id="5914" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="5917" href="Tactic.RingSolver.html#1597" class="Function">*′</a> <a id="5920" href="Tactic.RingSolver.html#3680" class="Function Operator">⇓≟</a> <a id="5923" href="Tactic.RingSolver.html#5820" class="Bound">nm</a> <a id="5926" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="5931" href="Tactic.RingSolver.html#4163" class="Function Operator">E⟨</a> <a id="5934" class="Keyword">quote</a> <a id="5940" href="Tactic.RingSolver.Core.Expression.html#700" class="InductiveConstructor Operator">_⊗_</a> <a id="5944" href="Tactic.RingSolver.html#4163" class="Function Operator">⟩₂</a> <a id="5947" href="Tactic.RingSolver.html#5832" class="Bound">xs</a> <a id="5950" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
                                   <a id="5990" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="5993" href="Tactic.RingSolver.html#1600" class="Function">^′</a> <a id="5996" href="Tactic.RingSolver.html#3680" class="Function Operator">⇓≟</a> <a id="5999" href="Tactic.RingSolver.html#5820" class="Bound">nm</a> <a id="6002" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="6007" href="Tactic.RingSolver.html#4557" class="Function">E⟨^⟩</a> <a id="6012" href="Tactic.RingSolver.html#5832" class="Bound">xs</a> <a id="6015" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
                                   <a id="6055" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="6058" href="Tactic.RingSolver.html#1603" class="Function">-′</a> <a id="6061" href="Tactic.RingSolver.html#3680" class="Function Operator">⇓≟</a> <a id="6064" href="Tactic.RingSolver.html#5820" class="Bound">nm</a> <a id="6067" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="6072" href="Tactic.RingSolver.html#4373" class="Function Operator">E⟨</a> <a id="6075" class="Keyword">quote</a> <a id="6081" href="Tactic.RingSolver.Core.Expression.html#814" class="InductiveConstructor Operator">⊝_</a> <a id="6084" href="Tactic.RingSolver.html#4373" class="Function Operator">⟩₁</a> <a id="6087" href="Tactic.RingSolver.html#5832" class="Bound">xs</a> <a id="6090" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
                                   <a id="6130" href="Tactic.RingSolver.html#3602" class="Function">Κ′</a> <a id="6133" class="Symbol">(</a><a id="6134" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6138" href="Tactic.RingSolver.html#5820" class="Bound">nm</a> <a id="6141" href="Tactic.RingSolver.html#5832" class="Bound">xs</a><a id="6143" class="Symbol">)</a>
          <a id="6155" class="Comment">-- Variables</a>
          <a id="6178" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="6180" href="Tactic.RingSolver.html#6180" class="Bound">v</a><a id="6181" class="Symbol">@(</a><a id="6183" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="6187" href="Tactic.RingSolver.html#6187" class="Bound">x</a> <a id="6189" class="Symbol">_)</a>          <a id="6201" class="Symbol">=</a> <a id="6203" href="Data.Maybe.Base.html#1641" class="Function">fromMaybe</a> <a id="6213" class="Symbol">(</a><a id="6214" href="Tactic.RingSolver.html#3602" class="Function">Κ′</a> <a id="6217" href="Tactic.RingSolver.html#6180" class="Bound">v</a><a id="6218" class="Symbol">)</a> <a id="6220" class="Symbol">(</a><a id="6221" href="Tactic.RingSolver.html#3830" class="Bound">Ι′</a> <a id="6224" href="Tactic.RingSolver.html#6187" class="Bound">x</a><a id="6225" class="Symbol">)</a>
          <a id="6237" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
          <a id="6295" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="6297" class="Symbol">(</a><a id="6298" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="6302" class="Symbol">(</a><a id="6303" class="Keyword">quote</a> <a id="6309" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">ℕ.suc</a><a id="6314" class="Symbol">)</a> <a id="6316" class="Symbol">(</a><a id="6317" href="Tactic.RingSolver.html#6317" class="Bound">x</a> <a id="6319" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6323" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6325" class="Symbol">))</a> <a id="6328" class="Symbol">=</a> <a id="6330" class="Keyword">quote</a> <a id="6336" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a> <a id="6340" href="Tactic.RingSolver.html#3449" class="Function Operator">$ᵉ</a> <a id="6343" class="Symbol">(</a><a id="6344" href="Tactic.RingSolver.html#3602" class="Function">Κ′</a> <a id="6347" class="Symbol">(</a><a id="6348" href="Data.Nat.Reflection.html#534" class="Function">toTerm</a> <a id="6355" class="Number">1</a><a id="6356" class="Symbol">)</a> <a id="6358" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6362" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="6364" href="Tactic.RingSolver.html#6317" class="Bound">x</a> <a id="6366" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6370" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6372" class="Symbol">)</a>
          <a id="6384" href="Tactic.RingSolver.html#5468" class="CatchallClause Function">E</a><a id="6385" class="CatchallClause"> </a><a id="6386" href="Tactic.RingSolver.html#6386" class="CatchallClause Bound">t</a>                    <a id="6407" class="Symbol">=</a> <a id="6409" href="Tactic.RingSolver.html#3602" class="Function">Κ′</a> <a id="6412" href="Tactic.RingSolver.html#6386" class="Bound">t</a>

      <a id="6421" href="Tactic.RingSolver.html#6421" class="Function">callSolver</a> <a id="6432" class="Symbol">:</a> <a id="6434" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="6438" href="Agda.Builtin.String.html#335" class="Postulate">String</a> <a id="6445" href="Tactic.RingSolver.html#3013" class="Bound">numVars</a> <a id="6453" class="Symbol">→</a> <a id="6455" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6460" class="Symbol">→</a> <a id="6462" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6467" class="Symbol">→</a> <a id="6469" href="Reflection.Argument.html#1493" class="Function">Args</a> <a id="6474" href="Agda.Builtin.Reflection.html#5064" class="Function">Type</a>
      <a id="6485" href="Tactic.RingSolver.html#6421" class="Function">callSolver</a> <a id="6496" href="Tactic.RingSolver.html#6496" class="Bound">nms</a> <a id="6500" href="Tactic.RingSolver.html#6500" class="Bound">lhs</a> <a id="6504" href="Tactic.RingSolver.html#6504" class="Bound">rhs</a> <a id="6508" class="Symbol">=</a>
          <a id="6520" class="Number">2</a> <a id="6522" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a> <a id="6527" href="Tactic.RingSolver.html#2100" class="Bound">ring</a> <a id="6532" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6536" href="Data.Nat.Reflection.html#534" class="Function">toTerm</a> <a id="6543" href="Tactic.RingSolver.html#3013" class="Bound">numVars</a> <a id="6551" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6565" href="Tactic.RingSolver.Core.ReflectionHelp.html#1151" class="Function">vlams</a> <a id="6571" href="Tactic.RingSolver.html#6496" class="Bound">nms</a> <a id="6575" class="Symbol">(</a><a id="6576" class="Keyword">quote</a> <a id="6582" href="Tactic.RingSolver.NonReflective.html#3324" class="Function Operator">_⊜_</a>  <a id="6587" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="6590" class="Symbol">(</a><a id="6591" href="Data.Nat.Reflection.html#534" class="Function">toTerm</a> <a id="6598" href="Tactic.RingSolver.html#3013" class="Bound">numVars</a> <a id="6606" href="Reflection.Argument.html#1617" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="6610" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="6612" href="Tactic.RingSolver.html#6500" class="Bound">lhs</a> <a id="6616" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6620" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="6622" href="Tactic.RingSolver.html#6504" class="Bound">rhs</a> <a id="6626" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6630" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6632" class="Symbol">))</a> <a id="6635" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6649" href="Tactic.RingSolver.Core.ReflectionHelp.html#1031" class="Function">hlams</a> <a id="6655" href="Tactic.RingSolver.html#6496" class="Bound">nms</a> <a id="6659" class="Symbol">(</a><a id="6660" class="Keyword">quote</a> <a id="6666" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2500" class="Function">refl</a> <a id="6671" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="6674" class="Symbol">(</a><a id="6675" class="Number">1</a> <a id="6677" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a> <a id="6682" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6684" class="Symbol">))</a> <a id="6687" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6701" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
        <a id="6712" class="Keyword">where</a>
        <a id="6726" href="Tactic.RingSolver.html#6726" class="Function">Ι′</a> <a id="6729" class="Symbol">:</a> <a id="6731" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="6733" class="Symbol">→</a> <a id="6735" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="6741" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
        <a id="6754" href="Tactic.RingSolver.html#6726" class="Function">Ι′</a> <a id="6757" href="Tactic.RingSolver.html#6757" class="Bound">i</a> <a id="6759" class="Symbol">=</a> <a id="6761" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="6764" href="Tactic.RingSolver.html#6757" class="Bound">i</a> <a id="6766" href="Data.Nat.Base.html#1310" class="Primitive Operator">&lt;ᵇ</a> <a id="6769" href="Tactic.RingSolver.html#3013" class="Bound">numVars</a> <a id="6777" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="6782" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6787" class="Symbol">(</a><a id="6788" href="Agda.Builtin.Reflection.html#5138" class="InductiveConstructor">var</a> <a id="6792" href="Tactic.RingSolver.html#6757" class="Bound">i</a> <a id="6794" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6796" class="Symbol">)</a> <a id="6798" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="6803" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
        <a id="6819" class="Keyword">open</a> <a id="6824" href="Tactic.RingSolver.html#3822" class="Module">ToExpr</a> <a id="6831" href="Tactic.RingSolver.html#6726" class="Function">Ι′</a>

      <a id="6841" href="Tactic.RingSolver.html#6841" class="Function">constructSoln</a> <a id="6855" class="Symbol">:</a> <a id="6857" href="Tactic.RingSolver.Core.NatSet.html#2125" class="Function">NatSet</a> <a id="6864" class="Symbol">→</a> <a id="6866" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6871" class="Symbol">→</a> <a id="6873" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6878" class="Symbol">→</a> <a id="6880" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
      <a id="6891" href="Tactic.RingSolver.html#6841" class="Function">constructSoln</a> <a id="6905" href="Tactic.RingSolver.html#6905" class="Bound">t</a> <a id="6907" href="Tactic.RingSolver.html#6907" class="Bound">lhs</a> <a id="6911" href="Tactic.RingSolver.html#6911" class="Bound">rhs</a> <a id="6915" class="Symbol">=</a>
          <a id="6927" class="Keyword">quote</a> <a id="6933" href="Relation.Binary.Structures.html#1629" class="Function">trans</a> <a id="6939" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="6942" class="Symbol">(</a><a id="6943" class="Number">3</a> <a id="6945" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a>
            <a id="6962" class="Keyword">quote</a> <a id="6968" href="Relation.Binary.Structures.html#1603" class="Function">sym</a> <a id="6972" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="6975" class="Symbol">(</a><a id="6976" class="Number">2</a> <a id="6978" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a>
              <a id="6997" class="Keyword">quote</a> <a id="7003" href="Tactic.RingSolver.NonReflective.html#2298" class="Function">Ops.correct</a> <a id="7015" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="7018" class="Symbol">(</a><a id="7019" class="Number">1</a> <a id="7021" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a> <a id="7026" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="7028" href="Tactic.RingSolver.html#6907" class="Bound">lhs</a> <a id="7032" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7036" href="Tactic.RingSolver.html#7305" class="Function">ρ</a> <a id="7038" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7042" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7044" class="Symbol">)</a> <a id="7046" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7050" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7052" class="Symbol">)</a>
            <a id="7066" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a>
            <a id="7082" class="Symbol">(</a><a id="7083" class="Keyword">quote</a> <a id="7089" href="Tactic.RingSolver.NonReflective.html#2298" class="Function">Ops.correct</a> <a id="7101" href="Tactic.RingSolver.html#2367" class="Function Operator">$ʳ</a> <a id="7104" class="Symbol">(</a><a id="7105" class="Number">1</a> <a id="7107" href="Reflection.Term.html#2764" class="Function Operator">⋯⟅∷⟆</a> <a id="7112" href="Tactic.RingSolver.html#5468" class="Function">E</a> <a id="7114" href="Tactic.RingSolver.html#6911" class="Bound">rhs</a> <a id="7118" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7122" href="Tactic.RingSolver.html#7305" class="Function">ρ</a> <a id="7124" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7128" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7130" class="Symbol">))</a> <a id="7133" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a>
            <a id="7149" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7151" class="Symbol">)</a>
        <a id="7161" class="Keyword">where</a>
        <a id="7175" href="Tactic.RingSolver.html#7175" class="Function">Ι′</a> <a id="7178" class="Symbol">:</a> <a id="7180" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="7182" class="Symbol">→</a> <a id="7184" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="7190" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
        <a id="7203" href="Tactic.RingSolver.html#7175" class="Function">Ι′</a> <a id="7206" href="Tactic.RingSolver.html#7206" class="Bound">i</a> <a id="7208" class="Symbol">=</a> <a id="7210" href="Data.Maybe.Base.html#2029" class="Function">Maybe.map</a> <a id="7220" class="Symbol">(λ</a> <a id="7223" href="Tactic.RingSolver.html#7223" class="Bound">x</a> <a id="7225" class="Symbol">→</a> <a id="7227" class="Keyword">quote</a> <a id="7233" href="Tactic.RingSolver.Core.Expression.html#598" class="InductiveConstructor">Ι</a> <a id="7235" href="Tactic.RingSolver.html#3449" class="Function Operator">$ᵉ</a> <a id="7238" class="Symbol">(</a><a id="7239" href="Data.Nat.Reflection.html#646" class="Function">toFinTerm</a> <a id="7249" href="Tactic.RingSolver.html#7223" class="Bound">x</a> <a id="7251" href="Reflection.Argument.html#1584" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7255" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7257" class="Symbol">))</a> <a id="7260" class="Symbol">(</a><a id="7261" href="Tactic.RingSolver.Core.NatSet.html#2890" class="Function">lookup</a> <a id="7268" href="Tactic.RingSolver.html#7206" class="Bound">i</a> <a id="7270" href="Tactic.RingSolver.html#6905" class="Bound">t</a><a id="7271" class="Symbol">)</a>

        <a id="7282" class="Keyword">open</a> <a id="7287" href="Tactic.RingSolver.html#3822" class="Module">ToExpr</a> <a id="7294" href="Tactic.RingSolver.html#7175" class="Function">Ι′</a>
        <a id="7305" href="Tactic.RingSolver.html#7305" class="Function">ρ</a> <a id="7307" class="Symbol">:</a> <a id="7309" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
        <a id="7322" href="Tactic.RingSolver.html#7305" class="Function">ρ</a> <a id="7324" class="Symbol">=</a> <a id="7326" href="Tactic.RingSolver.Core.ReflectionHelp.html#2008" class="Function">curriedTerm</a> <a id="7338" href="Tactic.RingSolver.html#6905" class="Bound">t</a>

<a id="7341" class="Comment">------------------------------------------------------------------------</a>
<a id="7414" class="Comment">-- Macros</a>
<a id="7424" class="Comment">------------------------------------------------------------------------</a>

<a id="7498" class="Comment">-- This is the main macro which solves for equations in which the variables</a>
<a id="7574" class="Comment">-- are universally quantified over:</a>
<a id="7610" class="Comment">--</a>
<a id="7613" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="7648" class="Comment">--   lemma = solve-∀ TypeRing</a>
<a id="7678" class="Comment">--</a>
<a id="7681" class="Comment">-- where TypRing is your implementation of AlmostCommutativeRing. (Find some</a>
<a id="7758" class="Comment">-- example implementations in Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>

<a id="solve-∀-macro"></a><a id="7846" href="Tactic.RingSolver.html#7846" class="Function">solve-∀-macro</a> <a id="7860" class="Symbol">:</a> <a id="7862" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="7867" class="Symbol">→</a> <a id="7869" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7874" class="Symbol">→</a> <a id="7876" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7879" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="7881" href="Tactic.RingSolver.html#7846" class="Function">solve-∀-macro</a> <a id="7895" href="Tactic.RingSolver.html#7895" class="Bound">ring</a> <a id="7900" href="Tactic.RingSolver.html#7900" class="Bound">hole</a> <a id="7905" class="Symbol">=</a> <a id="7907" class="Keyword">do</a>
  <a id="7912" href="Tactic.RingSolver.html#7912" class="Bound">ring′</a> <a id="7918" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="7920" href="Tactic.RingSolver.html#1622" class="Function">checkIsRing</a> <a id="7932" class="Symbol">(</a><a id="7933" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="7937" href="Tactic.RingSolver.html#7895" class="Bound">ring</a> <a id="7942" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7944" class="Symbol">)</a>
  <a id="7948" href="Agda.Builtin.Reflection.html#9830" class="Postulate">commitTC</a>
  <a id="7959" class="Keyword">let</a> <a id="7963" class="Keyword">open</a> <a id="7968" href="Tactic.RingSolver.html#2090" class="Module">OverRing</a> <a id="7977" href="Tactic.RingSolver.html#7912" class="Bound">ring′</a>
  <a id="7985" href="Tactic.RingSolver.html#7985" class="Bound">operatorNames</a> <a id="7999" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="8001" href="Tactic.RingSolver.html#2772" class="Function">getRingOperatorNames</a>
  <a id="8024" href="Tactic.RingSolver.html#8024" class="Bound">hole′</a> <a id="8030" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="8032" href="Agda.Builtin.Reflection.html#8878" class="Postulate">inferType</a> <a id="8042" href="Tactic.RingSolver.html#7900" class="Bound">hole</a> <a id="8047" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">&gt;&gt;=</a> <a id="8051" href="Agda.Builtin.Reflection.html#8993" class="Postulate">reduce</a>
  <a id="8060" class="Keyword">let</a> <a id="8064" href="Tactic.RingSolver.html#8064" class="Bound">variables</a> <a id="8074" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8076" href="Tactic.RingSolver.html#8076" class="Bound">k</a> <a id="8078" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8080" href="Tactic.RingSolver.html#8080" class="Bound">equation</a> <a id="8089" class="Symbol">=</a> <a id="8091" href="Tactic.RingSolver.Core.ReflectionHelp.html#1789" class="Function">underPi</a> <a id="8099" href="Tactic.RingSolver.html#8024" class="Bound">hole′</a>
  <a id="8107" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="8112" class="Symbol">(</a><a id="8113" href="Tactic.RingSolver.html#8113" class="Bound">lhs</a> <a id="8117" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="8119" href="Tactic.RingSolver.html#8119" class="Bound">rhs</a> <a id="8123" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="8125" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a><a id="8127" class="Symbol">)</a> <a id="8129" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="8131" href="Reflection.TypeChecking.Monad.Syntax.html#532" class="Function">pure</a> <a id="8136" class="Symbol">(</a><a id="8137" href="Tactic.RingSolver.Core.ReflectionHelp.html#1407" class="Function">getArgs</a> <a id="8145" class="Number">2</a> <a id="8147" href="Tactic.RingSolver.html#8080" class="Bound">equation</a><a id="8155" class="Symbol">)</a>
    <a id="8161" class="Keyword">where</a> <a id="8167" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="8175" class="Symbol">→</a> <a id="8177" href="Agda.Builtin.Reflection.html#8815" class="Postulate">typeError</a> <a id="8187" class="Symbol">(</a><a id="8188" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="8195" class="String">&quot;Malformed call to solve.&quot;</a> <a id="8222" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="8255" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="8262" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a> <a id="8320" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="8353" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="8360" class="String">&quot;Instead: &quot;</a> <a id="8372" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="8405" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="8413" href="Tactic.RingSolver.html#8024" class="Bound">hole′</a> <a id="8419" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="8452" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8454" class="Symbol">)</a>
  <a id="8458" href="Agda.Builtin.Reflection.html#8775" class="Postulate">unify</a> <a id="8464" href="Tactic.RingSolver.html#7900" class="Bound">hole</a> <a id="8469" class="Symbol">(</a><a id="8470" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8474" class="Symbol">(</a><a id="8475" class="Keyword">quote</a> <a id="8481" href="Tactic.RingSolver.html#1151" class="Function">solve-fn</a><a id="8489" class="Symbol">)</a> <a id="8491" class="Symbol">(</a><a id="8492" href="Tactic.RingSolver.html#6421" class="Function">callSolver</a> <a id="8503" href="Tactic.RingSolver.html#7985" class="Bound">operatorNames</a> <a id="8517" href="Tactic.RingSolver.html#8064" class="Bound">variables</a> <a id="8527" href="Tactic.RingSolver.html#8076" class="Bound">k</a> <a id="8529" href="Tactic.RingSolver.html#8113" class="Bound">lhs</a> <a id="8533" href="Tactic.RingSolver.html#8119" class="Bound">rhs</a><a id="8536" class="Symbol">))</a>

<a id="8540" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="8548" href="Tactic.RingSolver.html#8548" class="Function">solve-∀</a> <a id="8556" class="Symbol">:</a> <a id="8558" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="8563" class="Symbol">→</a> <a id="8565" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8570" class="Symbol">→</a> <a id="8572" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="8575" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="8579" href="Tactic.RingSolver.html#8548" class="Function">solve-∀</a> <a id="8587" class="Symbol">=</a> <a id="8589" href="Tactic.RingSolver.html#7846" class="Function">solve-∀-macro</a>

<a id="8604" class="Comment">-- Use this macro when you want to solve something *under* a lambda. For example:</a>
<a id="8686" class="Comment">-- say you have a long proof, and you just want the solver to deal with an</a>
<a id="8761" class="Comment">-- intermediate step. Call it like so:</a>
<a id="8800" class="Comment">--</a>
<a id="8803" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="8855" class="Comment">--   lemma₃ x y = begin</a>
<a id="8879" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="8938" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="8992" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="9023" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="9046" class="Comment">--</a>
<a id="9049" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="9116" class="Comment">-- ring implementation (as before).</a>
<a id="9152" class="Comment">--</a>
<a id="9155" class="Comment">-- One thing to note here is that we need to be able to infer *both* sides of</a>
<a id="9233" class="Comment">-- the equality, which the normal equaltional reasoning combinators don&#39;t let you</a>
<a id="9315" class="Comment">-- do. You&#39;ll need the combinators defined in Relation.Binary.Reasoning.Inference.</a>
<a id="9398" class="Comment">-- These are just as powerful as the others, but have slightly better inference properties.</a>

<a id="solve-macro"></a><a id="9491" href="Tactic.RingSolver.html#9491" class="Function">solve-macro</a> <a id="9503" class="Symbol">:</a> <a id="9505" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9510" class="Symbol">→</a> <a id="9512" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="9517" class="Symbol">→</a> <a id="9519" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9524" class="Symbol">→</a> <a id="9526" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="9529" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
<a id="9531" href="Tactic.RingSolver.html#9491" class="Function">solve-macro</a> <a id="9543" href="Tactic.RingSolver.html#9543" class="Bound">i</a> <a id="9545" href="Tactic.RingSolver.html#9545" class="Bound">ring</a> <a id="9550" href="Tactic.RingSolver.html#9550" class="Bound">hole</a> <a id="9555" class="Symbol">=</a> <a id="9557" class="Keyword">do</a>
  <a id="9562" href="Tactic.RingSolver.html#9562" class="Bound">ring′</a> <a id="9568" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="9570" href="Tactic.RingSolver.html#1622" class="Function">checkIsRing</a> <a id="9582" class="Symbol">(</a><a id="9583" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="9587" href="Tactic.RingSolver.html#9545" class="Bound">ring</a> <a id="9592" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9594" class="Symbol">)</a>
  <a id="9598" href="Agda.Builtin.Reflection.html#9830" class="Postulate">commitTC</a>
  <a id="9609" class="Keyword">let</a> <a id="9613" class="Keyword">open</a> <a id="9618" href="Tactic.RingSolver.html#2090" class="Module">OverRing</a> <a id="9627" href="Tactic.RingSolver.html#9562" class="Bound">ring′</a>
  <a id="9635" href="Tactic.RingSolver.html#9635" class="Bound">operatorNames</a> <a id="9649" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="9651" href="Tactic.RingSolver.html#2772" class="Function">getRingOperatorNames</a>
  <a id="9674" href="Tactic.RingSolver.html#9674" class="Bound">listOfVariables′</a> <a id="9691" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="9693" href="Tactic.RingSolver.html#2450" class="Function">checkIsListOfVariables</a> <a id="9716" href="Tactic.RingSolver.html#9543" class="Bound">i</a>
  <a id="9720" href="Agda.Builtin.Reflection.html#9830" class="Postulate">commitTC</a>
  <a id="9731" href="Tactic.RingSolver.html#9731" class="Bound">hole′</a> <a id="9737" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="9739" href="Agda.Builtin.Reflection.html#8878" class="Postulate">inferType</a> <a id="9749" href="Tactic.RingSolver.html#9550" class="Bound">hole</a> <a id="9754" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">&gt;&gt;=</a> <a id="9758" href="Agda.Builtin.Reflection.html#8993" class="Postulate">reduce</a>
  <a id="9767" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="9772" href="Tactic.RingSolver.html#9772" class="Bound">vars′</a> <a id="9778" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="9780" href="Reflection.TypeChecking.Monad.Syntax.html#532" class="Function">pure</a> <a id="9785" class="Symbol">(</a><a id="9786" href="Tactic.RingSolver.html#1738" class="Function">getVariableIDs</a> <a id="9801" href="Tactic.RingSolver.html#9674" class="Bound">listOfVariables′</a><a id="9817" class="Symbol">)</a>
    <a id="9823" class="Keyword">where</a> <a id="9829" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="9837" class="Symbol">→</a> <a id="9839" href="Agda.Builtin.Reflection.html#8815" class="Postulate">typeError</a> <a id="9849" class="Symbol">(</a><a id="9850" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="9857" class="String">&quot;Malformed call to solve.&quot;</a> <a id="9884" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="9917" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="9924" class="String">&quot;First argument should be a list of free variables.&quot;</a> <a id="9977" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="10010" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="10017" class="String">&quot;Instead: &quot;</a> <a id="10029" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="10062" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="10070" href="Tactic.RingSolver.html#9674" class="Bound">listOfVariables′</a> <a id="10087" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="10120" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10122" class="Symbol">)</a>
  <a id="10126" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="10131" class="Symbol">(</a><a id="10132" href="Tactic.RingSolver.html#10132" class="Bound">lhs</a> <a id="10136" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="10138" href="Tactic.RingSolver.html#10138" class="Bound">rhs</a> <a id="10142" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="10144" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a><a id="10146" class="Symbol">)</a> <a id="10148" href="Reflection.TypeChecking.Monad.Syntax.html#691" class="Function Operator">←</a> <a id="10150" href="Reflection.TypeChecking.Monad.Syntax.html#532" class="Function">pure</a> <a id="10155" class="Symbol">(</a><a id="10156" href="Tactic.RingSolver.Core.ReflectionHelp.html#1407" class="Function">getArgs</a> <a id="10164" class="Number">2</a> <a id="10166" href="Tactic.RingSolver.html#9731" class="Bound">hole′</a><a id="10171" class="Symbol">)</a>
    <a id="10177" class="Keyword">where</a> <a id="10183" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="10191" class="Symbol">→</a> <a id="10193" href="Agda.Builtin.Reflection.html#8815" class="Postulate">typeError</a> <a id="10203" class="Symbol">(</a><a id="10204" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="10211" class="String">&quot;Malformed call to solve.&quot;</a> <a id="10238" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="10271" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="10278" class="String">&quot;First argument should be a list of free variables.&quot;</a> <a id="10331" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="10364" href="Agda.Builtin.Reflection.html#8223" class="InductiveConstructor">strErr</a> <a id="10371" class="String">&quot;Instead: &quot;</a> <a id="10383" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="10416" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="10424" href="Tactic.RingSolver.html#9731" class="Bound">hole′</a> <a id="10430" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a>
                               <a id="10463" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="10465" class="Symbol">)</a>
  <a id="10469" href="Agda.Builtin.Reflection.html#8775" class="Postulate">unify</a> <a id="10475" href="Tactic.RingSolver.html#9550" class="Bound">hole</a> <a id="10480" class="Symbol">(</a><a id="10481" href="Tactic.RingSolver.html#6841" class="Function">constructSoln</a> <a id="10495" href="Tactic.RingSolver.html#9635" class="Bound">operatorNames</a> <a id="10509" class="Symbol">(</a><a id="10510" href="Data.List.Base.html#4873" class="Function">List.length</a> <a id="10522" href="Tactic.RingSolver.html#9772" class="Bound">vars′</a><a id="10527" class="Symbol">)</a> <a id="10529" href="Tactic.RingSolver.html#9772" class="Bound">vars′</a> <a id="10535" href="Tactic.RingSolver.html#10132" class="Bound">lhs</a> <a id="10539" href="Tactic.RingSolver.html#10138" class="Bound">rhs</a><a id="10542" class="Symbol">)</a>

<a id="10545" class="Keyword">macro</a>
  <a id="solve"></a><a id="10553" href="Tactic.RingSolver.html#10553" class="Function">solve</a> <a id="10559" class="Symbol">:</a> <a id="10561" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="10566" class="Symbol">→</a> <a id="10568" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="10573" class="Symbol">→</a> <a id="10575" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="10580" class="Symbol">→</a> <a id="10582" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="10585" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a>
  <a id="10589" href="Tactic.RingSolver.html#10553" class="Function">solve</a> <a id="10595" class="Symbol">=</a> <a id="10597" href="Tactic.RingSolver.html#9491" class="Function">solve-macro</a>
</pre></body></html>