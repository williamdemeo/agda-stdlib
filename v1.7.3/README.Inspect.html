<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Inspect</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Explaining how to use the inspect idiom and elaborating on the way</a>
<a id="176" class="Comment">-- it is implemented in the standard library.</a>
<a id="222" class="Comment">------------------------------------------------------------------------</a>

<a id="296" class="Symbol">{-#</a> <a id="300" class="Keyword">OPTIONS</a> <a id="308" class="Pragma">--cubical-compatible</a> <a id="329" class="Pragma">--safe</a> <a id="336" class="Symbol">#-}</a>

<a id="341" class="Keyword">module</a> <a id="348" href="README.Inspect.html" class="Module">README.Inspect</a> <a id="363" class="Keyword">where</a>

<a id="370" class="Keyword">open</a> <a id="375" class="Keyword">import</a> <a id="382" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>
<a id="396" class="Keyword">open</a> <a id="401" class="Keyword">import</a> <a id="408" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="428" class="Keyword">open</a> <a id="433" class="Keyword">import</a> <a id="440" href="Data.Product.html" class="Module">Data.Product</a>
<a id="453" class="Keyword">open</a> <a id="458" class="Keyword">import</a> <a id="465" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="504" class="Comment">------------------------------------------------------------------------</a>
<a id="577" class="Comment">-- Using inspect</a>

<a id="595" class="Comment">-- We start with the definition of a (silly) predicate: `Plus m n p` states</a>
<a id="671" class="Comment">-- that `m + n` is equal to `p` in a rather convoluted way. Crucially, it</a>
<a id="745" class="Comment">-- distinguishes two cases: whether `p` is 0 or not.</a>

<a id="Plus-eq"></a><a id="799" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="807" class="Symbol">:</a> <a id="809" class="Symbol">(</a><a id="810" href="README.Inspect.html#810" class="Bound">m</a> <a id="812" href="README.Inspect.html#812" class="Bound">n</a> <a id="814" href="README.Inspect.html#814" class="Bound">p</a> <a id="816" class="Symbol">:</a> <a id="818" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="819" class="Symbol">)</a> <a id="821" class="Symbol">→</a> <a id="823" href="Agda.Primitive.html#388" class="Primitive">Set</a>
<a id="827" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="835" href="README.Inspect.html#835" class="Bound">m</a> <a id="837" href="README.Inspect.html#837" class="Bound">n</a> <a id="839" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>      <a id="849" class="Symbol">=</a> <a id="851" href="README.Inspect.html#835" class="Bound">m</a> <a id="853" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="855" class="Number">0</a> <a id="857" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="859" href="README.Inspect.html#837" class="Bound">n</a> <a id="861" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="863" class="Number">0</a>
<a id="865" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="873" href="README.Inspect.html#873" class="Bound">m</a> <a id="875" href="README.Inspect.html#875" class="Bound">n</a> <a id="877" href="README.Inspect.html#877" class="Bound">p</a><a id="878" class="Symbol">@(</a><a id="880" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="884" class="Symbol">_)</a> <a id="887" class="Symbol">=</a> <a id="889" href="README.Inspect.html#873" class="Bound">m</a> <a id="891" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="893" href="README.Inspect.html#875" class="Bound">n</a> <a id="895" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="897" href="README.Inspect.html#877" class="Bound">p</a>

<a id="900" class="Comment">-- A sensible lemma to prove of this predicate is that whenever `p` is literally</a>
<a id="981" class="Comment">-- `m + n` then `Plus m n p` holds. That is to say `∀ m n → Plus m n (m + n)`.</a>
<a id="1060" class="Comment">-- To be able to prove `Plus-eq m n (m + n)`, we need `m + n` to have either</a>
<a id="1137" class="Comment">-- the shape `zero` or `suc _` so that `Plus-eq` may reduce.</a>

<a id="1199" class="Comment">-- We could follow the way `_+_` computes by mimicking the same splitting</a>
<a id="1273" class="Comment">-- strategy, thus forcing `m + n` to reduce:</a>

<a id="plus-eq-+"></a><a id="1319" href="README.Inspect.html#1319" class="Function">plus-eq-+</a> <a id="1329" class="Symbol">:</a> <a id="1331" class="Symbol">∀</a> <a id="1333" href="README.Inspect.html#1333" class="Bound">m</a> <a id="1335" href="README.Inspect.html#1335" class="Bound">n</a> <a id="1337" class="Symbol">→</a> <a id="1339" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="1347" href="README.Inspect.html#1333" class="Bound">m</a> <a id="1349" href="README.Inspect.html#1335" class="Bound">n</a> <a id="1351" class="Symbol">(</a><a id="1352" href="README.Inspect.html#1333" class="Bound">m</a> <a id="1354" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="1356" href="README.Inspect.html#1335" class="Bound">n</a><a id="1357" class="Symbol">)</a>
<a id="1359" href="README.Inspect.html#1319" class="Function">plus-eq-+</a> <a id="1369" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>   <a id="1376" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="1384" class="Symbol">=</a> <a id="1386" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="1391" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1393" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="1398" href="README.Inspect.html#1319" class="Function">plus-eq-+</a> <a id="1408" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>   <a id="1415" class="Symbol">(</a><a id="1416" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1420" href="README.Inspect.html#1420" class="Bound">n</a><a id="1421" class="Symbol">)</a> <a id="1423" class="Symbol">=</a> <a id="1425" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>
<a id="1430" href="README.Inspect.html#1319" class="Function">plus-eq-+</a> <a id="1440" class="Symbol">(</a><a id="1441" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="1445" href="README.Inspect.html#1445" class="Bound">m</a><a id="1446" class="Symbol">)</a> <a id="1448" href="README.Inspect.html#1448" class="Bound">n</a>      <a id="1455" class="Symbol">=</a> <a id="1457" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a>

<a id="1463" class="Comment">-- Or we could attempt to compute `m + n` first and check whether the result</a>
<a id="1540" class="Comment">-- is `zero` or `suc p`. By using `with m + n` and naming the result `p`,</a>
<a id="1614" class="Comment">-- the goal will become `Plus-eq m n p`. We can further refine this definition</a>
<a id="1693" class="Comment">-- by distinguishing two cases like so:</a>

<a id="1734" class="Comment">-- plus-eq-with : ∀ m n → Plus-eq m n (m + n)</a>
<a id="1780" class="Comment">-- plus-eq-with m n with m + n</a>
<a id="1811" class="Comment">-- ... | zero  = {!!}</a>
<a id="1833" class="Comment">-- ... | suc p = {!!}</a>

<a id="1856" class="Comment">-- The problem however is that we have abolutely lost the connection between the</a>
<a id="1937" class="Comment">-- computation `m + n` and its result `p`. Which makes the two goals unprovable:</a>

<a id="2019" class="Comment">-- 1. `m ≡ 0 × n ≡ 0`, with no assumption whatsoever</a>
<a id="2072" class="Comment">-- 2. `m + n ≡ suc p`, with no assumption either</a>

<a id="2122" class="Comment">-- By using the `with` construct, we have generated an auxiliary function that</a>
<a id="2201" class="Comment">-- looks like this:</a>
<a id="2221" class="Comment">-- `plus-eq-with-aux : ∀ m n p → Plus-eq m n p`</a>
<a id="2269" class="Comment">-- when we would have wanted a more precise type of the form:</a>
<a id="2331" class="Comment">-- `plus-eq-aux : ∀ m n p → m + n ≡ p → Plus-eq m n p`.</a>

<a id="2388" class="Comment">-- This is where we can use `inspect`. By using `with f x | inspect f x`,</a>
<a id="2462" class="Comment">-- we get both a `y` which is the result of `f x` and a proof that `f x ≡ y`.</a>
<a id="2540" class="Comment">-- Splitting on the result of `m + n`, we get two cases:</a>

<a id="2598" class="Comment">-- 1. `m ≡ 0 × n ≡ 0` under the assumption that `m + n ≡ zero`</a>
<a id="2661" class="Comment">-- 2. `m + n ≡ suc p` under the assumption that `m + n ≡ suc p`</a>

<a id="2726" class="Comment">-- The first one can be discharged using lemmas from Data.Nat.Properties and</a>
<a id="2803" class="Comment">-- the second one is trivial.</a>

<a id="plus-eq-with"></a><a id="2834" href="README.Inspect.html#2834" class="Function">plus-eq-with</a> <a id="2847" class="Symbol">:</a> <a id="2849" class="Symbol">∀</a> <a id="2851" href="README.Inspect.html#2851" class="Bound">m</a> <a id="2853" href="README.Inspect.html#2853" class="Bound">n</a> <a id="2855" class="Symbol">→</a> <a id="2857" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="2865" href="README.Inspect.html#2851" class="Bound">m</a> <a id="2867" href="README.Inspect.html#2853" class="Bound">n</a> <a id="2869" class="Symbol">(</a><a id="2870" href="README.Inspect.html#2851" class="Bound">m</a> <a id="2872" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2874" href="README.Inspect.html#2853" class="Bound">n</a><a id="2875" class="Symbol">)</a>
<a id="2877" href="README.Inspect.html#2834" class="Function">plus-eq-with</a> <a id="2890" href="README.Inspect.html#2890" class="Bound">m</a> <a id="2892" href="README.Inspect.html#2892" class="Bound">n</a> <a id="2894" class="Keyword">with</a> <a id="2899" href="README.Inspect.html#2890" class="Bound">m</a> <a id="2901" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="2903" href="README.Inspect.html#2892" class="Bound">n</a> <a id="2905" class="Symbol">|</a> <a id="2907" href="Relation.Binary.PropositionalEquality.html#2391" class="Function">inspect</a> <a id="2915" class="Symbol">(</a><a id="2916" href="README.Inspect.html#2890" class="Bound">m</a> <a id="2918" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+_</a><a id="2920" class="Symbol">)</a> <a id="2922" href="README.Inspect.html#2892" class="Bound">n</a>
<a id="2924" class="Symbol">...</a> <a id="2928" class="Symbol">|</a> <a id="2930" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>  <a id="2936" class="Symbol">|</a> <a id="2938" href="Relation.Binary.PropositionalEquality.html#2365" class="InductiveConstructor Operator">[</a> <a id="2940" href="README.Inspect.html#2940" class="Bound">m+n≡0</a>   <a id="2948" href="Relation.Binary.PropositionalEquality.html#2365" class="InductiveConstructor Operator">]</a> <a id="2950" class="Symbol">=</a> <a id="2952" href="Data.Nat.Properties.html#15982" class="Function">m+n≡0⇒m≡0</a> <a id="2962" class="Bound">m</a> <a id="2964" href="README.Inspect.html#2940" class="Bound">m+n≡0</a> <a id="2970" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2972" href="Data.Nat.Properties.html#16048" class="Function">m+n≡0⇒n≡0</a> <a id="2982" class="Bound">m</a> <a id="2984" href="README.Inspect.html#2940" class="Bound">m+n≡0</a>
<a id="2990" class="Symbol">...</a> <a id="2994" class="Symbol">|</a> <a id="2996" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3000" href="README.Inspect.html#3000" class="Bound">p</a> <a id="3002" class="Symbol">|</a> <a id="3004" href="Relation.Binary.PropositionalEquality.html#2365" class="InductiveConstructor Operator">[</a> <a id="3006" href="README.Inspect.html#3006" class="Bound">m+n≡1+p</a> <a id="3014" href="Relation.Binary.PropositionalEquality.html#2365" class="InductiveConstructor Operator">]</a> <a id="3016" class="Symbol">=</a> <a id="3018" href="README.Inspect.html#3006" class="Bound">m+n≡1+p</a>


<a id="3028" class="Comment">------------------------------------------------------------------------</a>
<a id="3101" class="Comment">-- Understanding the implementation of inspect</a>

<a id="3149" class="Comment">-- So why is it that we have to go through the record type `Reveal_·_is_`</a>
<a id="3223" class="Comment">-- and the ̀inspect` function? The fact is: we don&#39;t have to if we write</a>
<a id="3296" class="Comment">-- our own auxiliary lemma:</a>

<a id="plus-eq-aux"></a><a id="3325" href="README.Inspect.html#3325" class="Function">plus-eq-aux</a> <a id="3337" class="Symbol">:</a> <a id="3339" class="Symbol">∀</a> <a id="3341" href="README.Inspect.html#3341" class="Bound">m</a> <a id="3343" href="README.Inspect.html#3343" class="Bound">n</a> <a id="3345" class="Symbol">→</a> <a id="3347" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="3355" href="README.Inspect.html#3341" class="Bound">m</a> <a id="3357" href="README.Inspect.html#3343" class="Bound">n</a> <a id="3359" class="Symbol">(</a><a id="3360" href="README.Inspect.html#3341" class="Bound">m</a> <a id="3362" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3364" href="README.Inspect.html#3343" class="Bound">n</a><a id="3365" class="Symbol">)</a>
<a id="3367" href="README.Inspect.html#3325" class="Function">plus-eq-aux</a> <a id="3379" href="README.Inspect.html#3379" class="Bound">m</a> <a id="3381" href="README.Inspect.html#3381" class="Bound">n</a> <a id="3383" class="Symbol">=</a> <a id="3385" href="README.Inspect.html#3415" class="Function">aux</a> <a id="3389" href="README.Inspect.html#3379" class="Bound">m</a> <a id="3391" href="README.Inspect.html#3381" class="Bound">n</a> <a id="3393" class="Symbol">(</a><a id="3394" href="README.Inspect.html#3379" class="Bound">m</a> <a id="3396" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3398" href="README.Inspect.html#3381" class="Bound">n</a><a id="3399" class="Symbol">)</a> <a id="3401" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="3406" class="Keyword">where</a>

  <a id="3415" href="README.Inspect.html#3415" class="Function">aux</a> <a id="3419" class="Symbol">:</a> <a id="3421" class="Symbol">∀</a> <a id="3423" href="README.Inspect.html#3423" class="Bound">m</a> <a id="3425" href="README.Inspect.html#3425" class="Bound">n</a> <a id="3427" href="README.Inspect.html#3427" class="Bound">p</a> <a id="3429" class="Symbol">→</a> <a id="3431" href="README.Inspect.html#3423" class="Bound">m</a> <a id="3433" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="3435" href="README.Inspect.html#3425" class="Bound">n</a> <a id="3437" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3439" href="README.Inspect.html#3427" class="Bound">p</a> <a id="3441" class="Symbol">→</a> <a id="3443" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="3451" href="README.Inspect.html#3423" class="Bound">m</a> <a id="3453" href="README.Inspect.html#3425" class="Bound">n</a> <a id="3455" href="README.Inspect.html#3427" class="Bound">p</a>
  <a id="3459" href="README.Inspect.html#3415" class="Function">aux</a> <a id="3463" href="README.Inspect.html#3463" class="Bound">m</a> <a id="3465" href="README.Inspect.html#3465" class="Bound">n</a> <a id="3467" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="3475" href="README.Inspect.html#3475" class="Bound">m+n≡0</a>   <a id="3483" class="Symbol">=</a> <a id="3485" href="Data.Nat.Properties.html#15982" class="Function">m+n≡0⇒m≡0</a> <a id="3495" href="README.Inspect.html#3463" class="Bound">m</a> <a id="3497" href="README.Inspect.html#3475" class="Bound">m+n≡0</a> <a id="3503" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3505" href="Data.Nat.Properties.html#16048" class="Function">m+n≡0⇒n≡0</a> <a id="3515" href="README.Inspect.html#3463" class="Bound">m</a> <a id="3517" href="README.Inspect.html#3475" class="Bound">m+n≡0</a>
  <a id="3525" href="README.Inspect.html#3415" class="Function">aux</a> <a id="3529" href="README.Inspect.html#3529" class="Bound">m</a> <a id="3531" href="README.Inspect.html#3531" class="Bound">n</a> <a id="3533" class="Symbol">(</a><a id="3534" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="3538" href="README.Inspect.html#3538" class="Bound">p</a><a id="3539" class="Symbol">)</a> <a id="3541" href="README.Inspect.html#3541" class="Bound">m+n≡1+p</a> <a id="3549" class="Symbol">=</a> <a id="3551" href="README.Inspect.html#3541" class="Bound">m+n≡1+p</a>

<a id="3560" class="Comment">-- The problem is that when we write ̀with f x | pr`, `with` decides to call `y`</a>
<a id="3641" class="Comment">-- the result `f x` and to replace *all* of the occurences of `f x` in the type</a>
<a id="3721" class="Comment">-- of `pr` with `y`. That is to say that if we were to write:</a>

<a id="3784" class="Comment">-- plus-eq-naïve : ∀ m n → Plus-eq m n (m + n)</a>
<a id="3831" class="Comment">-- plus-eq-naïve m n with m + n | refl {x = m + n}</a>
<a id="3882" class="Comment">-- ... | p | eq = {!!}</a>

<a id="3906" class="Comment">-- then `with` would abstract `m + n` as `p` on *both* sides of the equality</a>
<a id="3983" class="Comment">-- proven by `refl` thus giving us the following goal with an extra, useless,</a>
<a id="4061" class="Comment">-- assumption:</a>

<a id="4077" class="Comment">-- 1. `Plus-eq m n p` under the assumption that `p ≡ p`</a>

<a id="4134" class="Comment">-- So how does `inspect` work? The standard library uses a more general version</a>
<a id="4214" class="Comment">-- of the following type and function:</a>

<a id="4254" class="Keyword">record</a> <a id="MyReveal_·_is_"></a><a id="4261" href="README.Inspect.html#4261" class="Record Operator">MyReveal_·_is_</a> <a id="4276" class="Symbol">(</a><a id="4277" href="README.Inspect.html#4277" class="Bound">f</a> <a id="4279" class="Symbol">:</a> <a id="4281" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="4283" class="Symbol">→</a> <a id="4285" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="4286" class="Symbol">)</a> <a id="4288" class="Symbol">(</a><a id="4289" href="README.Inspect.html#4289" class="Bound">x</a> <a id="4291" href="README.Inspect.html#4291" class="Bound">y</a> <a id="4293" class="Symbol">:</a> <a id="4295" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="4296" class="Symbol">)</a> <a id="4298" class="Symbol">:</a> <a id="4300" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="4304" class="Keyword">where</a>
  <a id="4312" class="Keyword">constructor</a> <a id="[_]"></a><a id="4324" href="README.Inspect.html#4324" class="InductiveConstructor Operator">[_]</a>
  <a id="4330" class="Keyword">field</a> <a id="MyReveal_·_is_.eq"></a><a id="4336" href="README.Inspect.html#4336" class="Field">eq</a> <a id="4339" class="Symbol">:</a> <a id="4341" href="README.Inspect.html#4277" class="Bound">f</a> <a id="4343" href="README.Inspect.html#4289" class="Bound">x</a> <a id="4345" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4347" href="README.Inspect.html#4291" class="Bound">y</a>

<a id="my-inspect"></a><a id="4350" href="README.Inspect.html#4350" class="Function">my-inspect</a> <a id="4361" class="Symbol">:</a> <a id="4363" class="Symbol">∀</a> <a id="4365" href="README.Inspect.html#4365" class="Bound">f</a> <a id="4367" href="README.Inspect.html#4367" class="Bound">n</a> <a id="4369" class="Symbol">→</a> <a id="4371" href="README.Inspect.html#4261" class="Record Operator">MyReveal</a> <a id="4380" href="README.Inspect.html#4365" class="Bound">f</a> <a id="4382" href="README.Inspect.html#4261" class="Record Operator">·</a> <a id="4384" href="README.Inspect.html#4367" class="Bound">n</a> <a id="4386" href="README.Inspect.html#4261" class="Record Operator">is</a> <a id="4389" class="Symbol">(</a><a id="4390" href="README.Inspect.html#4365" class="Bound">f</a> <a id="4392" href="README.Inspect.html#4367" class="Bound">n</a><a id="4393" class="Symbol">)</a>
<a id="4395" href="README.Inspect.html#4350" class="Function">my-inspect</a> <a id="4406" href="README.Inspect.html#4406" class="Bound">f</a> <a id="4408" href="README.Inspect.html#4408" class="Bound">n</a> <a id="4410" class="Symbol">=</a> <a id="4412" href="README.Inspect.html#4324" class="InductiveConstructor Operator">[</a> <a id="4414" href="Agda.Builtin.Equality.html#207" class="InductiveConstructor">refl</a> <a id="4419" href="README.Inspect.html#4324" class="InductiveConstructor Operator">]</a>

<a id="4422" class="Comment">-- Given that `inspect` has the type `∀ f n → Reveal f · n is (f n)`, when we</a>
<a id="4500" class="Comment">-- write `with f n | inspect f n`, the only `f n` that can be abstracted in the</a>
<a id="4580" class="Comment">-- type of `inspect f n` is the third argument to `Reveal_·_is_`.</a>

<a id="4647" class="Comment">-- That is to say that the auxiliary definition generated looks like this:</a>

<a id="plus-eq-reveal"></a><a id="4723" href="README.Inspect.html#4723" class="Function">plus-eq-reveal</a> <a id="4738" class="Symbol">:</a> <a id="4740" class="Symbol">∀</a> <a id="4742" href="README.Inspect.html#4742" class="Bound">m</a> <a id="4744" href="README.Inspect.html#4744" class="Bound">n</a> <a id="4746" class="Symbol">→</a> <a id="4748" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="4756" href="README.Inspect.html#4742" class="Bound">m</a> <a id="4758" href="README.Inspect.html#4744" class="Bound">n</a> <a id="4760" class="Symbol">(</a><a id="4761" href="README.Inspect.html#4742" class="Bound">m</a> <a id="4763" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4765" href="README.Inspect.html#4744" class="Bound">n</a><a id="4766" class="Symbol">)</a>
<a id="4768" href="README.Inspect.html#4723" class="Function">plus-eq-reveal</a> <a id="4783" href="README.Inspect.html#4783" class="Bound">m</a> <a id="4785" href="README.Inspect.html#4785" class="Bound">n</a> <a id="4787" class="Symbol">=</a> <a id="4789" href="README.Inspect.html#4836" class="Function">aux</a> <a id="4793" href="README.Inspect.html#4783" class="Bound">m</a> <a id="4795" href="README.Inspect.html#4785" class="Bound">n</a> <a id="4797" class="Symbol">(</a><a id="4798" href="README.Inspect.html#4783" class="Bound">m</a> <a id="4800" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+</a> <a id="4802" href="README.Inspect.html#4785" class="Bound">n</a><a id="4803" class="Symbol">)</a> <a id="4805" class="Symbol">(</a><a id="4806" href="README.Inspect.html#4350" class="Function">my-inspect</a> <a id="4817" class="Symbol">(</a><a id="4818" href="README.Inspect.html#4783" class="Bound">m</a> <a id="4820" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+_</a><a id="4822" class="Symbol">)</a> <a id="4824" href="README.Inspect.html#4785" class="Bound">n</a><a id="4825" class="Symbol">)</a> <a id="4827" class="Keyword">where</a>

  <a id="4836" href="README.Inspect.html#4836" class="Function">aux</a> <a id="4840" class="Symbol">:</a> <a id="4842" class="Symbol">∀</a> <a id="4844" href="README.Inspect.html#4844" class="Bound">m</a> <a id="4846" href="README.Inspect.html#4846" class="Bound">n</a> <a id="4848" href="README.Inspect.html#4848" class="Bound">p</a> <a id="4850" class="Symbol">→</a> <a id="4852" href="README.Inspect.html#4261" class="Record Operator">MyReveal</a> <a id="4861" class="Symbol">(</a><a id="4862" href="README.Inspect.html#4844" class="Bound">m</a> <a id="4864" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">+_</a><a id="4866" class="Symbol">)</a> <a id="4868" href="README.Inspect.html#4261" class="Record Operator">·</a> <a id="4870" href="README.Inspect.html#4846" class="Bound">n</a> <a id="4872" href="README.Inspect.html#4261" class="Record Operator">is</a> <a id="4875" href="README.Inspect.html#4848" class="Bound">p</a> <a id="4877" class="Symbol">→</a> <a id="4879" href="README.Inspect.html#799" class="Function">Plus-eq</a> <a id="4887" href="README.Inspect.html#4844" class="Bound">m</a> <a id="4889" href="README.Inspect.html#4846" class="Bound">n</a> <a id="4891" href="README.Inspect.html#4848" class="Bound">p</a>
  <a id="4895" href="README.Inspect.html#4836" class="Function">aux</a> <a id="4899" href="README.Inspect.html#4899" class="Bound">m</a> <a id="4901" href="README.Inspect.html#4901" class="Bound">n</a> <a id="4903" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a>    <a id="4911" href="README.Inspect.html#4324" class="InductiveConstructor Operator">[</a> <a id="4913" href="README.Inspect.html#4913" class="Bound">m+n≡0</a>   <a id="4921" href="README.Inspect.html#4324" class="InductiveConstructor Operator">]</a> <a id="4923" class="Symbol">=</a> <a id="4925" href="Data.Nat.Properties.html#15982" class="Function">m+n≡0⇒m≡0</a> <a id="4935" href="README.Inspect.html#4899" class="Bound">m</a> <a id="4937" href="README.Inspect.html#4913" class="Bound">m+n≡0</a> <a id="4943" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4945" href="Data.Nat.Properties.html#16048" class="Function">m+n≡0⇒n≡0</a> <a id="4955" href="README.Inspect.html#4899" class="Bound">m</a> <a id="4957" href="README.Inspect.html#4913" class="Bound">m+n≡0</a>
  <a id="4965" href="README.Inspect.html#4836" class="Function">aux</a> <a id="4969" href="README.Inspect.html#4969" class="Bound">m</a> <a id="4971" href="README.Inspect.html#4971" class="Bound">n</a> <a id="4973" class="Symbol">(</a><a id="4974" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="4978" href="README.Inspect.html#4978" class="Bound">p</a><a id="4979" class="Symbol">)</a> <a id="4981" href="README.Inspect.html#4324" class="InductiveConstructor Operator">[</a> <a id="4983" href="README.Inspect.html#4983" class="Bound">m+n≡1+p</a> <a id="4991" href="README.Inspect.html#4324" class="InductiveConstructor Operator">]</a> <a id="4993" class="Symbol">=</a> <a id="4995" href="README.Inspect.html#4983" class="Bound">m+n≡1+p</a>

<a id="5004" class="Comment">-- At the cost of having to unwrap the constructor `[_]` around the equality</a>
<a id="5081" class="Comment">-- we care about, we can keep relying on `with` and avoid having to roll out</a>
<a id="5158" class="Comment">-- handwritten auxiliary definitions.</a>
</pre></body></html>