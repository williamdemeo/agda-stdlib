<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Decidability</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples of decision procedures and how to use them</a>
<a id="161" class="Comment">------------------------------------------------------------------------</a>

<a id="235" class="Symbol">{-#</a> <a id="239" class="Keyword">OPTIONS</a> <a id="247" class="Pragma">--without-K</a> <a id="259" class="Pragma">--safe</a> <a id="266" class="Symbol">#-}</a>

<a id="271" class="Keyword">module</a> <a id="278" href="README.Decidability.html" class="Module">README.Decidability</a> <a id="298" class="Keyword">where</a>

<a id="305" class="Comment">-- Reflects and Dec are defined in Relation.Nullary, and operations on them can</a>
<a id="385" class="Comment">-- be found in Relation.Nullary.Reflects and Relation.Nullary.Decidable.</a>

<a id="459" class="Keyword">open</a> <a id="464" class="Keyword">import</a> <a id="471" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="488" class="Symbol">as</a> <a id="491" class="Module">Nullary</a>
<a id="499" class="Keyword">open</a> <a id="504" class="Keyword">import</a> <a id="511" href="Relation.Nullary.Reflects.html" class="Module">Relation.Nullary.Reflects</a>
<a id="537" class="Keyword">open</a> <a id="542" class="Keyword">import</a> <a id="549" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="577" class="Keyword">open</a> <a id="582" class="Keyword">import</a> <a id="589" href="Data.Bool.html" class="Module">Data.Bool</a>
<a id="599" class="Keyword">open</a> <a id="604" class="Keyword">import</a> <a id="611" href="Data.List.html" class="Module">Data.List</a>
<a id="621" class="Keyword">open</a> <a id="626" class="Keyword">import</a> <a id="633" href="Data.List.Properties.html" class="Module">Data.List.Properties</a> <a id="654" class="Keyword">using</a> <a id="660" class="Symbol">(</a><a id="661" href="Data.List.Properties.html#2067" class="Function">∷-injective</a><a id="672" class="Symbol">)</a>
<a id="674" class="Keyword">open</a> <a id="679" class="Keyword">import</a> <a id="686" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="695" class="Keyword">open</a> <a id="700" class="Keyword">import</a> <a id="707" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="727" class="Keyword">using</a> <a id="733" class="Symbol">(</a><a id="734" href="Data.Nat.Properties.html#1607" class="Function">suc-injective</a><a id="747" class="Symbol">)</a>
<a id="749" class="Keyword">open</a> <a id="754" class="Keyword">import</a> <a id="761" href="Data.Product.html" class="Module">Data.Product</a>
<a id="774" class="Keyword">open</a> <a id="779" class="Keyword">import</a> <a id="786" href="Data.Unit.html" class="Module">Data.Unit</a>
<a id="796" class="Keyword">open</a> <a id="801" class="Keyword">import</a> <a id="808" href="Function.html" class="Module">Function</a>
<a id="817" class="Keyword">open</a> <a id="822" class="Keyword">import</a> <a id="829" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
<a id="867" class="Keyword">open</a> <a id="872" class="Keyword">import</a> <a id="879" href="Relation.Nary.html" class="Module">Relation.Nary</a>
<a id="893" class="Keyword">open</a> <a id="898" class="Keyword">import</a> <a id="905" href="Relation.Nullary.Product.html" class="Module">Relation.Nullary.Product</a>

<a id="931" class="Keyword">infix</a> <a id="937" class="Number">4</a> <a id="939" href="README.Decidability.html#1953" class="Function Operator">_≟₀_</a> <a id="944" href="README.Decidability.html#2581" class="Function Operator">_≟₁_</a> <a id="949" href="README.Decidability.html#3170" class="Function Operator">_≟₂_</a>

<a id="955" class="Comment">-- A proof of `Reflects P b` shows that a proposition `P` has the truth value of</a>
<a id="1036" class="Comment">-- the boolean `b`. A proof of `Reflects P true` amounts to a proof of `P`, and</a>
<a id="1116" class="Comment">-- a proof of `Reflects P false` amounts to a refutation of `P`.</a>

<a id="ex₀"></a><a id="1182" href="README.Decidability.html#1182" class="Function">ex₀</a> <a id="1186" class="Symbol">:</a> <a id="1188" class="Symbol">(</a><a id="1189" href="README.Decidability.html#1189" class="Bound">n</a> <a id="1191" class="Symbol">:</a> <a id="1193" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1194" class="Symbol">)</a> <a id="1196" class="Symbol">→</a> <a id="1198" href="Relation.Nullary.html#851" class="Datatype">Reflects</a> <a id="1207" class="Symbol">(</a><a id="1208" href="README.Decidability.html#1189" class="Bound">n</a> <a id="1210" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1212" href="README.Decidability.html#1189" class="Bound">n</a><a id="1213" class="Symbol">)</a> <a id="1215" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
<a id="1220" href="README.Decidability.html#1182" class="Function">ex₀</a> <a id="1224" href="README.Decidability.html#1224" class="Bound">n</a> <a id="1226" class="Symbol">=</a> <a id="1228" href="Relation.Nullary.html#899" class="InductiveConstructor">ofʸ</a> <a id="1232" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="ex₁"></a><a id="1238" href="README.Decidability.html#1238" class="Function">ex₁</a> <a id="1242" class="Symbol">:</a> <a id="1244" class="Symbol">(</a><a id="1245" href="README.Decidability.html#1245" class="Bound">n</a> <a id="1247" class="Symbol">:</a> <a id="1249" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1250" class="Symbol">)</a> <a id="1252" class="Symbol">→</a> <a id="1254" href="Relation.Nullary.html#851" class="Datatype">Reflects</a> <a id="1263" class="Symbol">(</a><a id="1264" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="1269" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1271" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1275" href="README.Decidability.html#1245" class="Bound">n</a><a id="1276" class="Symbol">)</a> <a id="1278" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
<a id="1284" href="README.Decidability.html#1238" class="Function">ex₁</a> <a id="1288" href="README.Decidability.html#1288" class="Bound">n</a> <a id="1290" class="Symbol">=</a> <a id="1292" href="Relation.Nullary.html#936" class="InductiveConstructor">ofⁿ</a> <a id="1296" class="Symbol">λ</a> <a id="1298" class="Symbol">()</a>

<a id="ex₂"></a><a id="1302" href="README.Decidability.html#1302" class="Function">ex₂</a> <a id="1306" class="Symbol">:</a> <a id="1308" class="Symbol">(</a><a id="1309" href="README.Decidability.html#1309" class="Bound">b</a> <a id="1311" class="Symbol">:</a> <a id="1313" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="1317" class="Symbol">)</a> <a id="1319" class="Symbol">→</a> <a id="1321" href="Relation.Nullary.html#851" class="Datatype">Reflects</a> <a id="1330" class="Symbol">(</a><a id="1331" href="Data.Bool.Base.html#1451" class="Function">T</a> <a id="1333" href="README.Decidability.html#1309" class="Bound">b</a><a id="1334" class="Symbol">)</a> <a id="1336" href="README.Decidability.html#1309" class="Bound">b</a>
<a id="1338" href="README.Decidability.html#1302" class="Function">ex₂</a> <a id="1342" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="1348" class="Symbol">=</a> <a id="1350" href="Relation.Nullary.html#936" class="InductiveConstructor">ofⁿ</a> <a id="1354" href="Function.Base.html#615" class="Function">id</a>
<a id="1357" href="README.Decidability.html#1302" class="Function">ex₂</a> <a id="1361" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="1367" class="Symbol">=</a> <a id="1369" href="Relation.Nullary.html#899" class="InductiveConstructor">ofʸ</a> <a id="1373" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>

<a id="1377" class="Comment">-- A proof of `Dec P` is a proof of `Reflects P b` for some `b`.</a>
<a id="1442" class="Comment">-- `Dec P` is declared as a record, with fields:</a>
<a id="1491" class="Comment">--   does : Bool</a>
<a id="1508" class="Comment">--   proof : Reflects P does</a>

<a id="ex₃"></a><a id="1538" href="README.Decidability.html#1538" class="Function">ex₃</a> <a id="1542" class="Symbol">:</a> <a id="1544" class="Symbol">(</a><a id="1545" href="README.Decidability.html#1545" class="Bound">b</a> <a id="1547" class="Symbol">:</a> <a id="1549" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="1553" class="Symbol">)</a> <a id="1555" class="Symbol">→</a> <a id="1557" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="1561" class="Symbol">(</a><a id="1562" href="Data.Bool.Base.html#1451" class="Function">T</a> <a id="1564" href="README.Decidability.html#1545" class="Bound">b</a><a id="1565" class="Symbol">)</a>
<a id="1567" href="Relation.Nullary.html#1578" class="Field">does</a>  <a id="1573" class="Symbol">(</a><a id="1574" href="README.Decidability.html#1538" class="Function">ex₃</a> <a id="1578" href="README.Decidability.html#1578" class="Bound">b</a><a id="1579" class="Symbol">)</a> <a id="1581" class="Symbol">=</a> <a id="1583" href="README.Decidability.html#1578" class="Bound">b</a>
<a id="1585" href="Relation.Nullary.html#1595" class="Field">proof</a> <a id="1591" class="Symbol">(</a><a id="1592" href="README.Decidability.html#1538" class="Function">ex₃</a> <a id="1596" href="README.Decidability.html#1596" class="Bound">b</a><a id="1597" class="Symbol">)</a> <a id="1599" class="Symbol">=</a> <a id="1601" href="README.Decidability.html#1302" class="Function">ex₂</a> <a id="1605" href="README.Decidability.html#1596" class="Bound">b</a>

<a id="1608" class="Comment">-- We also have pattern synonyms `yes` and `no`, allowing both fields to be</a>
<a id="1684" class="Comment">-- given at once.</a>

<a id="ex₄"></a><a id="1703" href="README.Decidability.html#1703" class="Function">ex₄</a> <a id="1707" class="Symbol">:</a> <a id="1709" class="Symbol">(</a><a id="1710" href="README.Decidability.html#1710" class="Bound">n</a> <a id="1712" class="Symbol">:</a> <a id="1714" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1715" class="Symbol">)</a> <a id="1717" class="Symbol">→</a> <a id="1719" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="1723" class="Symbol">(</a><a id="1724" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="1729" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1731" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1735" href="README.Decidability.html#1710" class="Bound">n</a><a id="1736" class="Symbol">)</a>
<a id="1738" href="README.Decidability.html#1703" class="Function">ex₄</a> <a id="1742" href="README.Decidability.html#1742" class="Bound">n</a> <a id="1744" class="Symbol">=</a> <a id="1746" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="1749" class="Symbol">λ</a> <a id="1751" class="Symbol">()</a>

<a id="1755" class="Comment">-- It is possible, but not ideal, to define recursive decision procedures using</a>
<a id="1835" class="Comment">-- only the `yes` and `no` patterns. The following procedure decides whether two</a>
<a id="1916" class="Comment">-- given natural numbers are equal.</a>

<a id="_≟₀_"></a><a id="1953" href="README.Decidability.html#1953" class="Function Operator">_≟₀_</a> <a id="1958" class="Symbol">:</a> <a id="1960" class="Symbol">(</a><a id="1961" href="README.Decidability.html#1961" class="Bound">m</a> <a id="1963" href="README.Decidability.html#1963" class="Bound">n</a> <a id="1965" class="Symbol">:</a> <a id="1967" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1968" class="Symbol">)</a> <a id="1970" class="Symbol">→</a> <a id="1972" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="1976" class="Symbol">(</a><a id="1977" href="README.Decidability.html#1961" class="Bound">m</a> <a id="1979" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1981" href="README.Decidability.html#1963" class="Bound">n</a><a id="1982" class="Symbol">)</a>
<a id="1984" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="1990" href="README.Decidability.html#1953" class="Function Operator">≟₀</a> <a id="1993" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="1999" class="Symbol">=</a> <a id="2001" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="2005" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="2010" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="2016" href="README.Decidability.html#1953" class="Function Operator">≟₀</a> <a id="2019" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2023" href="README.Decidability.html#2023" class="Bound">n</a> <a id="2025" class="Symbol">=</a> <a id="2027" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2030" class="Symbol">λ</a> <a id="2032" class="Symbol">()</a>
<a id="2035" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2039" href="README.Decidability.html#2039" class="Bound">m</a> <a id="2041" href="README.Decidability.html#1953" class="Function Operator">≟₀</a> <a id="2044" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="2050" class="Symbol">=</a> <a id="2052" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2055" class="Symbol">λ</a> <a id="2057" class="Symbol">()</a>
<a id="2060" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2064" href="README.Decidability.html#2064" class="Bound">m</a> <a id="2066" href="README.Decidability.html#1953" class="Function Operator">≟₀</a> <a id="2069" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2073" href="README.Decidability.html#2073" class="Bound">n</a> <a id="2075" class="Keyword">with</a> <a id="2080" href="README.Decidability.html#2064" class="Bound">m</a> <a id="2082" href="README.Decidability.html#1953" class="Function Operator">≟₀</a> <a id="2085" href="README.Decidability.html#2073" class="Bound">n</a>
<a id="2087" class="Symbol">...</a> <a id="2091" class="Symbol">|</a> <a id="2093" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="2097" href="README.Decidability.html#2097" class="Bound">p</a> <a id="2099" class="Symbol">=</a> <a id="2101" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="2105" class="Symbol">(</a><a id="2106" href="Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="2111" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2115" href="README.Decidability.html#2097" class="Bound">p</a><a id="2116" class="Symbol">)</a>
<a id="2118" class="Symbol">...</a> <a id="2122" class="Symbol">|</a> <a id="2124" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2127" href="README.Decidability.html#2127" class="Bound">¬p</a> <a id="2130" class="Symbol">=</a> <a id="2132" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2135" class="Symbol">(</a><a id="2136" href="README.Decidability.html#2127" class="Bound">¬p</a> <a id="2139" href="Function.Base.html#992" class="Function Operator">∘</a> <a id="2141" href="Data.Nat.Properties.html#1607" class="Function">suc-injective</a><a id="2154" class="Symbol">)</a>

<a id="2157" class="Comment">-- In this case, we can see that `does (suc m ≟ suc n)` should be equal to</a>
<a id="2232" class="Comment">-- `does (m ≟ n)`, because a `yes` from `m ≟ n` gives rise to a `yes` from the</a>
<a id="2311" class="Comment">-- result, and similarly for `no`. However, in the above definition, this</a>
<a id="2385" class="Comment">-- equality does not hold definitionally, because we always do a case split</a>
<a id="2461" class="Comment">-- before returning a result. To avoid this, we can return the `does` part</a>
<a id="2536" class="Comment">-- separately, before any pattern matching.</a>

<a id="_≟₁_"></a><a id="2581" href="README.Decidability.html#2581" class="Function Operator">_≟₁_</a> <a id="2586" class="Symbol">:</a> <a id="2588" class="Symbol">(</a><a id="2589" href="README.Decidability.html#2589" class="Bound">m</a> <a id="2591" href="README.Decidability.html#2591" class="Bound">n</a> <a id="2593" class="Symbol">:</a> <a id="2595" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2596" class="Symbol">)</a> <a id="2598" class="Symbol">→</a> <a id="2600" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="2604" class="Symbol">(</a><a id="2605" href="README.Decidability.html#2589" class="Bound">m</a> <a id="2607" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2609" href="README.Decidability.html#2591" class="Bound">n</a><a id="2610" class="Symbol">)</a>
<a id="2612" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="2618" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2621" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="2627" class="Symbol">=</a> <a id="2629" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="2633" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="2638" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="2644" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2647" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2651" href="README.Decidability.html#2651" class="Bound">n</a> <a id="2653" class="Symbol">=</a> <a id="2655" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2658" class="Symbol">λ</a> <a id="2660" class="Symbol">()</a>
<a id="2663" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2667" href="README.Decidability.html#2667" class="Bound">m</a> <a id="2669" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2672" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="2678" class="Symbol">=</a> <a id="2680" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2683" class="Symbol">λ</a> <a id="2685" class="Symbol">()</a>
<a id="2688" href="Relation.Nullary.html#1578" class="Field">does</a>  <a id="2694" class="Symbol">(</a><a id="2695" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2699" href="README.Decidability.html#2699" class="Bound">m</a> <a id="2701" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2704" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2708" href="README.Decidability.html#2708" class="Bound">n</a><a id="2709" class="Symbol">)</a> <a id="2711" class="Symbol">=</a> <a id="2713" href="Relation.Nullary.html#1578" class="Field">does</a> <a id="2718" class="Symbol">(</a><a id="2719" href="README.Decidability.html#2699" class="Bound">m</a> <a id="2721" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2724" href="README.Decidability.html#2708" class="Bound">n</a><a id="2725" class="Symbol">)</a>
<a id="2727" href="Relation.Nullary.html#1595" class="Field">proof</a> <a id="2733" class="Symbol">(</a><a id="2734" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2738" href="README.Decidability.html#2738" class="Bound">m</a> <a id="2740" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2743" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2747" href="README.Decidability.html#2747" class="Bound">n</a><a id="2748" class="Symbol">)</a> <a id="2750" class="Keyword">with</a> <a id="2755" href="README.Decidability.html#2738" class="Bound">m</a> <a id="2757" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2760" href="README.Decidability.html#2747" class="Bound">n</a>
<a id="2762" class="Symbol">...</a> <a id="2766" class="Symbol">|</a> <a id="2768" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="2772" href="README.Decidability.html#2772" class="Bound">p</a> <a id="2774" class="Symbol">=</a> <a id="2776" href="Relation.Nullary.html#899" class="InductiveConstructor">ofʸ</a> <a id="2780" class="Symbol">(</a><a id="2781" href="Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="2786" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2790" href="README.Decidability.html#2772" class="Bound">p</a><a id="2791" class="Symbol">)</a>
<a id="2793" class="Symbol">...</a> <a id="2797" class="Symbol">|</a> <a id="2799" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2802" href="README.Decidability.html#2802" class="Bound">¬p</a> <a id="2805" class="Symbol">=</a> <a id="2807" href="Relation.Nullary.html#936" class="InductiveConstructor">ofⁿ</a> <a id="2811" class="Symbol">(</a><a id="2812" href="README.Decidability.html#2802" class="Bound">¬p</a> <a id="2815" href="Function.Base.html#992" class="Function Operator">∘</a> <a id="2817" href="Data.Nat.Properties.html#1607" class="Function">suc-injective</a><a id="2830" class="Symbol">)</a>

<a id="2833" class="Comment">-- We now get definitional equalities such as the following.</a>

<a id="2895" href="README.Decidability.html#2895" class="Function">_</a> <a id="2897" class="Symbol">:</a> <a id="2899" class="Symbol">(</a><a id="2900" href="README.Decidability.html#2900" class="Bound">m</a> <a id="2902" href="README.Decidability.html#2902" class="Bound">n</a> <a id="2904" class="Symbol">:</a> <a id="2906" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2907" class="Symbol">)</a> <a id="2909" class="Symbol">→</a> <a id="2911" href="Relation.Nullary.html#1578" class="Field">does</a> <a id="2916" class="Symbol">(</a><a id="2917" class="Number">5</a> <a id="2919" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2921" href="README.Decidability.html#2900" class="Bound">m</a> <a id="2923" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2926" class="Number">3</a> <a id="2928" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2930" href="README.Decidability.html#2902" class="Bound">n</a><a id="2931" class="Symbol">)</a> <a id="2933" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2935" href="Relation.Nullary.html#1578" class="Field">does</a> <a id="2940" class="Symbol">(</a><a id="2941" class="Number">2</a> <a id="2943" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2945" href="README.Decidability.html#2900" class="Bound">m</a> <a id="2947" href="README.Decidability.html#2581" class="Function Operator">≟₁</a> <a id="2950" href="README.Decidability.html#2902" class="Bound">n</a><a id="2951" class="Symbol">)</a>
<a id="2953" class="Symbol">_</a> <a id="2955" class="Symbol">=</a> <a id="2957" class="Symbol">λ</a> <a id="2959" href="README.Decidability.html#2959" class="Bound">m</a> <a id="2961" href="README.Decidability.html#2961" class="Bound">n</a> <a id="2963" class="Symbol">→</a> <a id="2965" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="2971" class="Comment">-- Even better, from a maintainability point of view, is to use `map` or `map′`,</a>
<a id="3052" class="Comment">-- both of which capture the pattern of the `does` field remaining the same, but</a>
<a id="3133" class="Comment">-- the `proof` field being updated.</a>

<a id="_≟₂_"></a><a id="3170" href="README.Decidability.html#3170" class="Function Operator">_≟₂_</a> <a id="3175" class="Symbol">:</a> <a id="3177" class="Symbol">(</a><a id="3178" href="README.Decidability.html#3178" class="Bound">m</a> <a id="3180" href="README.Decidability.html#3180" class="Bound">n</a> <a id="3182" class="Symbol">:</a> <a id="3184" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3185" class="Symbol">)</a> <a id="3187" class="Symbol">→</a> <a id="3189" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="3193" class="Symbol">(</a><a id="3194" href="README.Decidability.html#3178" class="Bound">m</a> <a id="3196" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3198" href="README.Decidability.html#3180" class="Bound">n</a><a id="3199" class="Symbol">)</a>
<a id="3201" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="3207" href="README.Decidability.html#3170" class="Function Operator">≟₂</a> <a id="3210" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="3216" class="Symbol">=</a> <a id="3218" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="3222" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="3227" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="3233" href="README.Decidability.html#3170" class="Function Operator">≟₂</a> <a id="3236" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3240" href="README.Decidability.html#3240" class="Bound">n</a> <a id="3242" class="Symbol">=</a> <a id="3244" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="3247" class="Symbol">λ</a> <a id="3249" class="Symbol">()</a>
<a id="3252" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3256" href="README.Decidability.html#3256" class="Bound">m</a> <a id="3258" href="README.Decidability.html#3170" class="Function Operator">≟₂</a> <a id="3261" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>  <a id="3267" class="Symbol">=</a> <a id="3269" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="3272" class="Symbol">λ</a> <a id="3274" class="Symbol">()</a>
<a id="3277" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3281" href="README.Decidability.html#3281" class="Bound">m</a> <a id="3283" href="README.Decidability.html#3170" class="Function Operator">≟₂</a> <a id="3286" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3290" href="README.Decidability.html#3290" class="Bound">n</a> <a id="3292" class="Symbol">=</a> <a id="3294" href="Relation.Nullary.Decidable.Core.html#3636" class="Function">map′</a> <a id="3299" class="Symbol">(</a><a id="3300" href="Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="3305" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="3308" class="Symbol">)</a> <a id="3310" href="Data.Nat.Properties.html#1607" class="Function">suc-injective</a> <a id="3324" class="Symbol">(</a><a id="3325" href="README.Decidability.html#3281" class="Bound">m</a> <a id="3327" href="README.Decidability.html#3170" class="Function Operator">≟₂</a> <a id="3330" href="README.Decidability.html#3290" class="Bound">n</a><a id="3331" class="Symbol">)</a>

<a id="3334" href="README.Decidability.html#3334" class="Function">_</a> <a id="3336" class="Symbol">:</a> <a id="3338" class="Symbol">(</a><a id="3339" href="README.Decidability.html#3339" class="Bound">m</a> <a id="3341" href="README.Decidability.html#3341" class="Bound">n</a> <a id="3343" class="Symbol">:</a> <a id="3345" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3346" class="Symbol">)</a> <a id="3348" class="Symbol">→</a> <a id="3350" href="Relation.Nullary.html#1578" class="Field">does</a> <a id="3355" class="Symbol">(</a><a id="3356" class="Number">5</a> <a id="3358" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="3360" href="README.Decidability.html#3339" class="Bound">m</a> <a id="3362" href="README.Decidability.html#3170" class="Function Operator">≟₂</a> <a id="3365" class="Number">3</a> <a id="3367" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="3369" href="README.Decidability.html#3341" class="Bound">n</a><a id="3370" class="Symbol">)</a> <a id="3372" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3374" href="Relation.Nullary.html#1578" class="Field">does</a> <a id="3379" class="Symbol">(</a><a id="3380" class="Number">2</a> <a id="3382" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="3384" href="README.Decidability.html#3339" class="Bound">m</a> <a id="3386" href="README.Decidability.html#3170" class="Function Operator">≟₂</a> <a id="3389" href="README.Decidability.html#3341" class="Bound">n</a><a id="3390" class="Symbol">)</a>
<a id="3392" class="Symbol">_</a> <a id="3394" class="Symbol">=</a> <a id="3396" class="Symbol">λ</a> <a id="3398" href="README.Decidability.html#3398" class="Bound">m</a> <a id="3400" href="README.Decidability.html#3400" class="Bound">n</a> <a id="3402" class="Symbol">→</a> <a id="3404" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="3410" class="Comment">-- `map′` can be used in conjunction with combinators such as `_⊎-dec_` and</a>
<a id="3486" class="Comment">-- `_×-dec_` to build complex (simply typed) decision procedures.</a>

<a id="3553" class="Keyword">module</a> <a id="ListDecEq₀"></a><a id="3560" href="README.Decidability.html#3560" class="Module">ListDecEq₀</a> <a id="3571" class="Symbol">{</a><a id="3572" href="README.Decidability.html#3572" class="Bound">a</a><a id="3573" class="Symbol">}</a> <a id="3575" class="Symbol">{</a><a id="3576" href="README.Decidability.html#3576" class="Bound">A</a> <a id="3578" class="Symbol">:</a> <a id="3580" class="PrimitiveType">Set</a> <a id="3584" href="README.Decidability.html#3572" class="Bound">a</a><a id="3585" class="Symbol">}</a> <a id="3587" class="Symbol">(</a><a id="3588" href="README.Decidability.html#3588" class="Bound Operator">_≟ᴬ_</a> <a id="3593" class="Symbol">:</a> <a id="3595" class="Symbol">(</a><a id="3596" href="README.Decidability.html#3596" class="Bound">x</a> <a id="3598" href="README.Decidability.html#3598" class="Bound">y</a> <a id="3600" class="Symbol">:</a> <a id="3602" href="README.Decidability.html#3576" class="Bound">A</a><a id="3603" class="Symbol">)</a> <a id="3605" class="Symbol">→</a> <a id="3607" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="3611" class="Symbol">(</a><a id="3612" href="README.Decidability.html#3596" class="Bound">x</a> <a id="3614" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3616" href="README.Decidability.html#3598" class="Bound">y</a><a id="3617" class="Symbol">))</a> <a id="3620" class="Keyword">where</a>

  <a id="ListDecEq₀._≟ᴸᴬ_"></a><a id="3629" href="README.Decidability.html#3629" class="Function Operator">_≟ᴸᴬ_</a> <a id="3635" class="Symbol">:</a> <a id="3637" class="Symbol">(</a><a id="3638" href="README.Decidability.html#3638" class="Bound">xs</a> <a id="3641" href="README.Decidability.html#3641" class="Bound">ys</a> <a id="3644" class="Symbol">:</a> <a id="3646" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="3651" href="README.Decidability.html#3576" class="Bound">A</a><a id="3652" class="Symbol">)</a> <a id="3654" class="Symbol">→</a> <a id="3656" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="3660" class="Symbol">(</a><a id="3661" href="README.Decidability.html#3638" class="Bound">xs</a> <a id="3664" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3666" href="README.Decidability.html#3641" class="Bound">ys</a><a id="3668" class="Symbol">)</a>
  <a id="3672" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="3681" href="README.Decidability.html#3629" class="Function Operator">≟ᴸᴬ</a> <a id="3685" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="3694" class="Symbol">=</a> <a id="3696" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="3700" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="3707" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="3716" href="README.Decidability.html#3629" class="Function Operator">≟ᴸᴬ</a> <a id="3720" class="Symbol">(</a><a id="3721" href="README.Decidability.html#3721" class="Bound">y</a> <a id="3723" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3725" href="README.Decidability.html#3725" class="Bound">ys</a><a id="3727" class="Symbol">)</a> <a id="3729" class="Symbol">=</a> <a id="3731" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="3734" class="Symbol">λ</a> <a id="3736" class="Symbol">()</a>
  <a id="3741" class="Symbol">(</a><a id="3742" href="README.Decidability.html#3742" class="Bound">x</a> <a id="3744" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3746" href="README.Decidability.html#3746" class="Bound">xs</a><a id="3748" class="Symbol">)</a> <a id="3750" href="README.Decidability.html#3629" class="Function Operator">≟ᴸᴬ</a> <a id="3754" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="3763" class="Symbol">=</a> <a id="3765" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="3768" class="Symbol">λ</a> <a id="3770" class="Symbol">()</a>
  <a id="3775" class="Symbol">(</a><a id="3776" href="README.Decidability.html#3776" class="Bound">x</a> <a id="3778" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3780" href="README.Decidability.html#3780" class="Bound">xs</a><a id="3782" class="Symbol">)</a> <a id="3784" href="README.Decidability.html#3629" class="Function Operator">≟ᴸᴬ</a> <a id="3788" class="Symbol">(</a><a id="3789" href="README.Decidability.html#3789" class="Bound">y</a> <a id="3791" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3793" href="README.Decidability.html#3793" class="Bound">ys</a><a id="3795" class="Symbol">)</a> <a id="3797" class="Symbol">=</a>
    <a id="3803" href="Relation.Nullary.Decidable.Core.html#3636" class="Function">map′</a> <a id="3808" class="Symbol">(</a><a id="3809" href="Data.Product.html#3103" class="Function">uncurry</a> <a id="3817" class="Symbol">(</a><a id="3818" href="Relation.Binary.PropositionalEquality.html#1524" class="Function">cong₂</a> <a id="3824" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="3827" class="Symbol">))</a> <a id="3830" href="Data.List.Properties.html#2067" class="Function">∷-injective</a> <a id="3842" class="Symbol">(</a><a id="3843" href="README.Decidability.html#3776" class="Bound">x</a> <a id="3845" href="README.Decidability.html#3588" class="Bound Operator">≟ᴬ</a> <a id="3848" href="README.Decidability.html#3789" class="Bound">y</a> <a id="3850" href="Relation.Nullary.Product.html#904" class="Function Operator">×-dec</a> <a id="3856" href="README.Decidability.html#3780" class="Bound">xs</a> <a id="3859" href="README.Decidability.html#3629" class="Function Operator">≟ᴸᴬ</a> <a id="3863" href="README.Decidability.html#3793" class="Bound">ys</a><a id="3865" class="Symbol">)</a>

<a id="3868" class="Comment">-- The final case says that `x ∷ xs ≡ y ∷ ys` exactly when `x ≡ y` *and*</a>
<a id="3941" class="Comment">-- `xs ≡ ys`. The proofs are updated by the first two arguments to `map′`.</a>

<a id="4017" class="Comment">-- In the case of ≡-equality tests, the pattern</a>
<a id="4065" class="Comment">-- `map′ (congₙ c) c-injective (x₀ ≟ y₀ ×-dec ... ×-dec xₙ₋₁ ≟ yₙ₋₁)`</a>
<a id="4135" class="Comment">-- is captured by `≟-mapₙ n c c-injective (x₀ ≟ y₀) ... (xₙ₋₁ ≟ yₙ₋₁)`.</a>

<a id="4208" class="Keyword">module</a> <a id="ListDecEq₁"></a><a id="4215" href="README.Decidability.html#4215" class="Module">ListDecEq₁</a> <a id="4226" class="Symbol">{</a><a id="4227" href="README.Decidability.html#4227" class="Bound">a</a><a id="4228" class="Symbol">}</a> <a id="4230" class="Symbol">{</a><a id="4231" href="README.Decidability.html#4231" class="Bound">A</a> <a id="4233" class="Symbol">:</a> <a id="4235" class="PrimitiveType">Set</a> <a id="4239" href="README.Decidability.html#4227" class="Bound">a</a><a id="4240" class="Symbol">}</a> <a id="4242" class="Symbol">(</a><a id="4243" href="README.Decidability.html#4243" class="Bound Operator">_≟ᴬ_</a> <a id="4248" class="Symbol">:</a> <a id="4250" class="Symbol">(</a><a id="4251" href="README.Decidability.html#4251" class="Bound">x</a> <a id="4253" href="README.Decidability.html#4253" class="Bound">y</a> <a id="4255" class="Symbol">:</a> <a id="4257" href="README.Decidability.html#4231" class="Bound">A</a><a id="4258" class="Symbol">)</a> <a id="4260" class="Symbol">→</a> <a id="4262" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="4266" class="Symbol">(</a><a id="4267" href="README.Decidability.html#4251" class="Bound">x</a> <a id="4269" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4271" href="README.Decidability.html#4253" class="Bound">y</a><a id="4272" class="Symbol">))</a> <a id="4275" class="Keyword">where</a>

  <a id="ListDecEq₁._≟ᴸᴬ_"></a><a id="4284" href="README.Decidability.html#4284" class="Function Operator">_≟ᴸᴬ_</a> <a id="4290" class="Symbol">:</a> <a id="4292" class="Symbol">(</a><a id="4293" href="README.Decidability.html#4293" class="Bound">xs</a> <a id="4296" href="README.Decidability.html#4296" class="Bound">ys</a> <a id="4299" class="Symbol">:</a> <a id="4301" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4306" href="README.Decidability.html#4231" class="Bound">A</a><a id="4307" class="Symbol">)</a> <a id="4309" class="Symbol">→</a> <a id="4311" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="4315" class="Symbol">(</a><a id="4316" href="README.Decidability.html#4293" class="Bound">xs</a> <a id="4319" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="4321" href="README.Decidability.html#4296" class="Bound">ys</a><a id="4323" class="Symbol">)</a>
  <a id="4327" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="4336" href="README.Decidability.html#4284" class="Function Operator">≟ᴸᴬ</a> <a id="4340" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="4349" class="Symbol">=</a> <a id="4351" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="4355" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="4362" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="4371" href="README.Decidability.html#4284" class="Function Operator">≟ᴸᴬ</a> <a id="4375" class="Symbol">(</a><a id="4376" href="README.Decidability.html#4376" class="Bound">y</a> <a id="4378" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4380" href="README.Decidability.html#4380" class="Bound">ys</a><a id="4382" class="Symbol">)</a> <a id="4384" class="Symbol">=</a> <a id="4386" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="4389" class="Symbol">λ</a> <a id="4391" class="Symbol">()</a>
  <a id="4396" class="Symbol">(</a><a id="4397" href="README.Decidability.html#4397" class="Bound">x</a> <a id="4399" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4401" href="README.Decidability.html#4401" class="Bound">xs</a><a id="4403" class="Symbol">)</a> <a id="4405" href="README.Decidability.html#4284" class="Function Operator">≟ᴸᴬ</a> <a id="4409" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="4418" class="Symbol">=</a> <a id="4420" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="4423" class="Symbol">λ</a> <a id="4425" class="Symbol">()</a>
  <a id="4430" class="Symbol">(</a><a id="4431" href="README.Decidability.html#4431" class="Bound">x</a> <a id="4433" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4435" href="README.Decidability.html#4435" class="Bound">xs</a><a id="4437" class="Symbol">)</a> <a id="4439" href="README.Decidability.html#4284" class="Function Operator">≟ᴸᴬ</a> <a id="4443" class="Symbol">(</a><a id="4444" href="README.Decidability.html#4444" class="Bound">y</a> <a id="4446" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4448" href="README.Decidability.html#4448" class="Bound">ys</a><a id="4450" class="Symbol">)</a> <a id="4452" class="Symbol">=</a> <a id="4454" href="Relation.Nary.html#2987" class="Function">≟-mapₙ</a> <a id="4461" class="Number">2</a> <a id="4463" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a> <a id="4467" href="Data.List.Properties.html#2067" class="Function">∷-injective</a> <a id="4479" class="Symbol">(</a><a id="4480" href="README.Decidability.html#4431" class="Bound">x</a> <a id="4482" href="README.Decidability.html#4243" class="Bound Operator">≟ᴬ</a> <a id="4485" href="README.Decidability.html#4444" class="Bound">y</a><a id="4486" class="Symbol">)</a> <a id="4488" class="Symbol">(</a><a id="4489" href="README.Decidability.html#4435" class="Bound">xs</a> <a id="4492" href="README.Decidability.html#4284" class="Function Operator">≟ᴸᴬ</a> <a id="4496" href="README.Decidability.html#4448" class="Bound">ys</a><a id="4498" class="Symbol">)</a>
</pre></body></html>