<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Text.Regex</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples of regular expressions and matching</a>
<a id="154" class="Comment">------------------------------------------------------------------------</a>

<a id="228" class="Symbol">{-#</a> <a id="232" class="Keyword">OPTIONS</a> <a id="240" class="Pragma">--with-K</a> <a id="249" class="Symbol">#-}</a>

<a id="254" class="Keyword">module</a> <a id="261" href="README.Text.Regex.html" class="Module">README.Text.Regex</a> <a id="279" class="Keyword">where</a>

<a id="286" class="Keyword">open</a> <a id="291" class="Keyword">import</a> <a id="298" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="308" class="Keyword">using</a> <a id="314" class="Symbol">(</a><a id="315" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="319" class="Symbol">;</a> <a id="321" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="326" class="Symbol">)</a>
<a id="328" class="Keyword">open</a> <a id="333" class="Keyword">import</a> <a id="340" href="Data.List.html" class="Module">Data.List</a> <a id="350" class="Keyword">using</a> <a id="356" class="Symbol">(</a><a id="357" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="360" class="Symbol">;</a> <a id="362" href="Data.List.Base.html#7361" class="InductiveConstructor">[]</a><a id="364" class="Symbol">)</a>
<a id="366" class="Keyword">open</a> <a id="371" class="Keyword">import</a> <a id="378" href="Data.String.html" class="Module">Data.String</a>
<a id="390" class="Keyword">open</a> <a id="395" class="Keyword">import</a> <a id="402" href="Function.Base.html" class="Module">Function.Base</a> <a id="416" class="Keyword">using</a> <a id="422" class="Symbol">()</a> <a id="425" class="Keyword">renaming</a> <a id="434" class="Symbol">(</a><a id="435" href="Function.Base.html#3850" class="Function Operator">_$′_</a> <a id="440" class="Symbol">to</a> <a id="443" class="Function Operator">_$_</a><a id="446" class="Symbol">)</a>
<a id="448" class="Keyword">open</a> <a id="453" class="Keyword">import</a> <a id="460" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="487" class="Keyword">using</a> <a id="493" class="Symbol">(</a><a id="494" href="Relation.Nullary.Decidable.Core.html#1613" class="InductiveConstructor">yes</a><a id="497" class="Symbol">)</a>
<a id="499" class="Keyword">open</a> <a id="504" class="Keyword">import</a> <a id="511" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="538" class="Keyword">using</a> <a id="544" class="Symbol">(</a><a id="545" href="Relation.Nullary.Decidable.Core.html#3111" class="Function">True</a><a id="549" class="Symbol">;</a> <a id="551" href="Relation.Nullary.Decidable.Core.html#3152" class="Function">False</a><a id="556" class="Symbol">;</a> <a id="558" href="Relation.Nullary.Decidable.Core.html#4275" class="Function">from-yes</a><a id="566" class="Symbol">)</a>

<a id="569" class="Comment">-- Our library available via the Text.Regex module is safe but it works on</a>
<a id="644" class="Comment">-- lists of characters.</a>

<a id="669" class="Comment">-- To use it on strings we have to rely on unsafe theorems about the</a>
<a id="738" class="Comment">-- conversions between strings and lists of characters being inverses.</a>
<a id="809" class="Comment">-- For convenience we use the following unsafe module for this README.</a>
<a id="880" class="Keyword">open</a> <a id="885" class="Keyword">import</a> <a id="892" href="Text.Regex.String.Unsafe.html" class="Module">Text.Regex.String.Unsafe</a>

<a id="918" class="Comment">------------------------------------------------------------------------</a>
<a id="991" class="Comment">-- Defining regular expressions</a>

<a id="1024" class="Comment">-- The type of regular expressions is Exp.</a>

<a id="1068" class="Comment">-- Some examples of regular expressions using:</a>

<a id="1116" class="Comment">-- [_]        for the union of ranges it contains</a>
<a id="1166" class="Comment">-- _─_        for a range</a>
<a id="1192" class="Comment">-- singleton  for an exact character</a>
<a id="1229" class="Comment">-- _∙_        for the concatenation of two regular expressions</a>
<a id="1292" class="Comment">-- _∣_        for the sum of two regular expressions</a>
<a id="1345" class="Comment">-- _⋆         for the Kleene star (zero or more matches of the regular expression)</a>
<a id="1428" class="Comment">-- _⁇         for an optional regular expression</a>

<a id="ℕ*"></a><a id="1478" href="README.Text.Regex.html#1478" class="Function">ℕ*</a> <a id="1481" class="Symbol">:</a> <a id="1483" href="Text.Regex.Base.html#1261" class="Datatype">Exp</a>
<a id="1487" href="README.Text.Regex.html#1478" class="Function">ℕ*</a> <a id="1490" class="Symbol">=</a> <a id="1492" href="Text.Regex.Base.html#1294" class="InductiveConstructor Operator">[</a> <a id="1494" class="String">&#39;1&#39;</a> <a id="1498" href="Text.Regex.Base.html#1176" class="InductiveConstructor Operator">─</a> <a id="1500" class="String">&#39;9&#39;</a> <a id="1504" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1506" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="1509" href="Text.Regex.Base.html#1294" class="InductiveConstructor Operator">]</a>   <a id="1513" class="Comment">-- a non-zero digit</a>
   <a id="1536" href="Text.Regex.SmartConstructors.html#1762" class="Function Operator">∙</a> <a id="1538" href="Text.Regex.Base.html#1294" class="InductiveConstructor Operator">[</a> <a id="1540" class="String">&#39;0&#39;</a> <a id="1544" href="Text.Regex.Base.html#1176" class="InductiveConstructor Operator">─</a> <a id="1546" class="String">&#39;9&#39;</a> <a id="1550" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1552" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="1555" href="Text.Regex.Base.html#1294" class="InductiveConstructor Operator">]</a> <a id="1557" href="Text.Regex.SmartConstructors.html#2951" class="Function Operator">⋆</a> <a id="1559" class="Comment">-- followed by zero or more digits</a>

<a id="ℕ"></a><a id="1595" href="README.Text.Regex.html#1595" class="Function">ℕ</a> <a id="1597" class="Symbol">:</a> <a id="1599" href="Text.Regex.Base.html#1261" class="Datatype">Exp</a>
<a id="1603" href="README.Text.Regex.html#1595" class="Function">ℕ</a> <a id="1605" class="Symbol">=</a> <a id="1607" href="README.Text.Regex.html#1478" class="Function">ℕ*</a> <a id="1610" href="Text.Regex.SmartConstructors.html#1101" class="Function Operator">∣</a> <a id="1612" href="Text.Regex.Base.html#1982" class="InductiveConstructor">singleton</a> <a id="1622" class="String">&#39;0&#39;</a> <a id="1626" class="Comment">-- ℕ* or exactly 0</a>

<a id="ℤ"></a><a id="1646" href="README.Text.Regex.html#1646" class="Function">ℤ</a> <a id="1648" class="Symbol">:</a> <a id="1650" href="Text.Regex.Base.html#1261" class="Datatype">Exp</a>
<a id="1654" href="README.Text.Regex.html#1646" class="Function">ℤ</a> <a id="1656" class="Symbol">=</a> <a id="1658" class="Symbol">((</a><a id="1660" href="Text.Regex.Base.html#1982" class="InductiveConstructor">singleton</a> <a id="1670" class="String">&#39;-&#39;</a><a id="1673" class="Symbol">)</a> <a id="1675" href="Text.Regex.SmartConstructors.html#3620" class="Function Operator">⁇</a> <a id="1677" href="Text.Regex.SmartConstructors.html#1762" class="Function Operator">∙</a> <a id="1679" href="README.Text.Regex.html#1478" class="Function">ℕ*</a><a id="1681" class="Symbol">)</a> <a id="1683" class="Comment">-- an optional minus sign followed by a ℕ*</a>
  <a id="1728" href="Text.Regex.SmartConstructors.html#1101" class="Function Operator">∣</a> <a id="1730" href="Text.Regex.Base.html#1982" class="InductiveConstructor">singleton</a> <a id="1740" class="String">&#39;0&#39;</a>            <a id="1755" class="Comment">-- or exactly 0</a>

<a id="1772" class="Comment">------------------------------------------------------------------------</a>
<a id="1845" class="Comment">-- An expression&#39;s semantics</a>

<a id="1875" class="Comment">-- The semantics of these regular expression is defined in terms of the</a>
<a id="1947" class="Comment">-- lists of characters they match. The type (str ∈ e) states that the</a>
<a id="2017" class="Comment">-- string str matches the expression e.</a>

<a id="2058" class="Comment">-- It is decidable, and the proof is called _∈?_.</a>
<a id="2108" class="Comment">-- We can run it on a few examples to check that it matches our intuition:</a>

<a id="2184" class="Comment">-- Valid: starts with a non-zero digit, followed by 3 digits</a>
<a id="2245" href="README.Text.Regex.html#2245" class="Function">_</a> <a id="2247" class="Symbol">:</a> <a id="2249" href="Relation.Nullary.Decidable.Core.html#3111" class="Function">True</a> <a id="2254" class="Symbol">(</a><a id="2255" class="String">&quot;1848&quot;</a> <a id="2262" href="Text.Regex.String.Unsafe.html#1080" class="Function Operator">∈?</a> <a id="2265" href="README.Text.Regex.html#1478" class="Function">ℕ*</a><a id="2267" class="Symbol">)</a>
<a id="2269" class="Symbol">_</a> <a id="2271" class="Symbol">=</a> <a id="2273" class="Symbol">_</a>

<a id="2276" class="Comment">-- Valid: exactly 0</a>
<a id="2296" href="README.Text.Regex.html#2296" class="Function">_</a> <a id="2298" class="Symbol">:</a> <a id="2300" href="Relation.Nullary.Decidable.Core.html#3111" class="Function">True</a> <a id="2305" class="Symbol">(</a><a id="2306" class="String">&quot;0&quot;</a> <a id="2310" href="Text.Regex.String.Unsafe.html#1080" class="Function Operator">∈?</a> <a id="2313" href="README.Text.Regex.html#1595" class="Function">ℕ</a><a id="2314" class="Symbol">)</a>
<a id="2316" class="Symbol">_</a> <a id="2318" class="Symbol">=</a> <a id="2320" class="Symbol">_</a>

<a id="2323" class="Comment">-- Invalid: starts with a leading 0</a>
<a id="2359" href="README.Text.Regex.html#2359" class="Function">_</a> <a id="2361" class="Symbol">:</a> <a id="2363" href="Relation.Nullary.Decidable.Core.html#3152" class="Function">False</a> <a id="2369" class="Symbol">(</a><a id="2370" class="String">&quot;007&quot;</a> <a id="2376" href="Text.Regex.String.Unsafe.html#1080" class="Function Operator">∈?</a> <a id="2379" href="README.Text.Regex.html#1595" class="Function">ℕ</a><a id="2380" class="Symbol">)</a>
<a id="2382" class="Symbol">_</a> <a id="2384" class="Symbol">=</a> <a id="2386" class="Symbol">_</a>

<a id="2389" class="Comment">-- Invalid: no negative ℕ number</a>
<a id="2422" href="README.Text.Regex.html#2422" class="Function">_</a> <a id="2424" class="Symbol">:</a> <a id="2426" href="Relation.Nullary.Decidable.Core.html#3152" class="Function">False</a> <a id="2432" class="Symbol">(</a><a id="2433" class="String">&quot;-666&quot;</a> <a id="2440" href="Text.Regex.String.Unsafe.html#1080" class="Function Operator">∈?</a> <a id="2443" href="README.Text.Regex.html#1595" class="Function">ℕ</a><a id="2444" class="Symbol">)</a>
<a id="2446" class="Symbol">_</a> <a id="2448" class="Symbol">=</a> <a id="2450" class="Symbol">_</a>

<a id="2453" class="Comment">-- Valid: a negative integer</a>
<a id="2482" href="README.Text.Regex.html#2482" class="Function">_</a> <a id="2484" class="Symbol">:</a> <a id="2486" href="Relation.Nullary.Decidable.Core.html#3111" class="Function">True</a> <a id="2491" class="Symbol">(</a><a id="2492" class="String">&quot;-666&quot;</a> <a id="2499" href="Text.Regex.String.Unsafe.html#1080" class="Function Operator">∈?</a> <a id="2502" href="README.Text.Regex.html#1646" class="Function">ℤ</a><a id="2503" class="Symbol">)</a>
<a id="2505" class="Symbol">_</a> <a id="2507" class="Symbol">=</a> <a id="2509" class="Symbol">_</a>

<a id="2512" class="Comment">-- Invalid: no negative 0</a>
<a id="2538" href="README.Text.Regex.html#2538" class="Function">_</a> <a id="2540" class="Symbol">:</a> <a id="2542" href="Relation.Nullary.Decidable.Core.html#3152" class="Function">False</a> <a id="2548" class="Symbol">(</a><a id="2549" class="String">&quot;-0&quot;</a> <a id="2554" href="Text.Regex.String.Unsafe.html#1080" class="Function Operator">∈?</a> <a id="2557" href="README.Text.Regex.html#1646" class="Function">ℤ</a><a id="2558" class="Symbol">)</a>
<a id="2560" class="Symbol">_</a> <a id="2562" class="Symbol">=</a> <a id="2564" class="Symbol">_</a>

<a id="2567" class="Comment">------------------------------------------------------------------------</a>
<a id="2640" class="Comment">-- Matching algorithms</a>

<a id="2664" class="Comment">-- The proof that _∈_ is decidable gives us the ability to check whether</a>
<a id="2737" class="Comment">-- a whole string matches a regular expression. But we may want to use</a>
<a id="2808" class="Comment">-- other matching algorithms detecting a prefix, infix, or suffix of the</a>
<a id="2881" class="Comment">-- input string that matches the regular expression.</a>

<a id="2935" class="Comment">-- This is what the Regex type gives us.</a>

<a id="2977" class="Comment">-- For instance, the following value corresponds to finding an infix</a>
<a id="3046" class="Comment">-- substring matching the string &quot;agda&quot; or &quot;agdai&quot;</a>

<a id="agda"></a><a id="3098" href="README.Text.Regex.html#3098" class="Function">agda</a> <a id="3103" class="Symbol">:</a> <a id="3105" href="Text.Regex.Base.html#1261" class="Datatype">Exp</a>
<a id="3109" href="README.Text.Regex.html#3098" class="Function">agda</a> <a id="3114" class="Symbol">=</a> <a id="3116" href="Text.Regex.Base.html#1982" class="InductiveConstructor">singleton</a> <a id="3126" class="String">&#39;a&#39;</a>
     <a id="3135" href="Text.Regex.SmartConstructors.html#1762" class="Function Operator">∙</a> <a id="3137" href="Text.Regex.Base.html#1982" class="InductiveConstructor">singleton</a> <a id="3147" class="String">&#39;g&#39;</a>
     <a id="3156" href="Text.Regex.SmartConstructors.html#1762" class="Function Operator">∙</a> <a id="3158" href="Text.Regex.Base.html#1982" class="InductiveConstructor">singleton</a> <a id="3168" class="String">&#39;d&#39;</a>
     <a id="3177" href="Text.Regex.SmartConstructors.html#1762" class="Function Operator">∙</a> <a id="3179" href="Text.Regex.Base.html#1982" class="InductiveConstructor">singleton</a> <a id="3189" class="String">&#39;a&#39;</a>
     <a id="3198" href="Text.Regex.SmartConstructors.html#1762" class="Function Operator">∙</a> <a id="3200" class="Symbol">(</a><a id="3201" href="Text.Regex.Base.html#1982" class="InductiveConstructor">singleton</a> <a id="3211" class="String">&#39;i&#39;</a> <a id="3215" href="Text.Regex.SmartConstructors.html#3620" class="Function Operator">⁇</a><a id="3216" class="Symbol">)</a>

<a id="infixAgda"></a><a id="3219" href="README.Text.Regex.html#3219" class="Function">infixAgda</a> <a id="3229" class="Symbol">:</a> <a id="3231" href="Text.Regex.Base.html#1597" class="Record">Regex</a>
<a id="3237" href="README.Text.Regex.html#3219" class="Function">infixAgda</a> <a id="3247" class="Symbol">=</a> <a id="3249" class="Keyword">record</a>
  <a id="3258" class="Symbol">{</a> <a id="3260" href="Text.Regex.Base.html#1629" class="Field">fromStart</a>  <a id="3271" class="Symbol">=</a> <a id="3273" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="3281" class="Symbol">;</a> <a id="3283" href="Text.Regex.Base.html#1651" class="Field">tillEnd</a>    <a id="3294" class="Symbol">=</a> <a id="3296" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="3304" class="Symbol">;</a> <a id="3306" href="Text.Regex.Base.html#1673" class="Field">expression</a> <a id="3317" class="Symbol">=</a> <a id="3319" href="README.Text.Regex.html#3098" class="Function">agda</a>
  <a id="3326" class="Symbol">}</a>

<a id="3329" class="Comment">-- The search function gives us the ability to look for matches</a>

<a id="3394" class="Comment">-- Valid: agda in the middle</a>
<a id="3423" href="README.Text.Regex.html#3423" class="Function">_</a> <a id="3425" class="Symbol">:</a> <a id="3427" href="Relation.Nullary.Decidable.Core.html#3111" class="Function">True</a> <a id="3432" class="Symbol">(</a><a id="3433" href="Text.Regex.String.Unsafe.html#1577" class="Function">search</a> <a id="3440" class="String">&quot;Maria Magdalena&quot;</a> <a id="3458" href="README.Text.Regex.html#3219" class="Function">infixAgda</a><a id="3467" class="Symbol">)</a>
<a id="3469" class="Symbol">_</a> <a id="3471" class="Symbol">=</a> <a id="3473" class="Symbol">_</a>

<a id="3476" class="Comment">-- By changing the value of fromStart and tillEnd we can control where the</a>
<a id="3551" class="Comment">-- substring should be. We can insist on the match being at the end of the</a>
<a id="3626" class="Comment">-- input for instance:</a>

<a id="suffixAgda"></a><a id="3650" href="README.Text.Regex.html#3650" class="Function">suffixAgda</a> <a id="3661" class="Symbol">:</a> <a id="3663" href="Text.Regex.Base.html#1597" class="Record">Regex</a>
<a id="3669" href="README.Text.Regex.html#3650" class="Function">suffixAgda</a> <a id="3680" class="Symbol">=</a> <a id="3682" class="Keyword">record</a>
  <a id="3691" class="Symbol">{</a> <a id="3693" href="Text.Regex.Base.html#1629" class="Field">fromStart</a>  <a id="3704" class="Symbol">=</a> <a id="3706" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="3714" class="Symbol">;</a> <a id="3716" href="Text.Regex.Base.html#1651" class="Field">tillEnd</a>    <a id="3727" class="Symbol">=</a> <a id="3729" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="3736" class="Symbol">;</a> <a id="3738" href="Text.Regex.Base.html#1673" class="Field">expression</a> <a id="3749" class="Symbol">=</a> <a id="3751" href="README.Text.Regex.html#3098" class="Function">agda</a>
  <a id="3758" class="Symbol">}</a>

<a id="3761" class="Comment">-- Invalid: agda is in the middle</a>
<a id="3795" href="README.Text.Regex.html#3795" class="Function">_</a> <a id="3797" class="Symbol">:</a> <a id="3799" href="Relation.Nullary.Decidable.Core.html#3152" class="Function">False</a> <a id="3805" class="Symbol">(</a><a id="3806" href="Text.Regex.String.Unsafe.html#1577" class="Function">search</a> <a id="3813" class="String">&quot;Maria Magdalena&quot;</a> <a id="3831" href="README.Text.Regex.html#3650" class="Function">suffixAgda</a><a id="3841" class="Symbol">)</a>
<a id="3843" class="Symbol">_</a> <a id="3845" class="Symbol">=</a> <a id="3847" class="Symbol">_</a>

<a id="3850" class="Comment">-- Valid: agda as a suffix</a>
<a id="3877" href="README.Text.Regex.html#3877" class="Function">_</a> <a id="3879" class="Symbol">:</a> <a id="3881" href="Relation.Nullary.Decidable.Core.html#3111" class="Function">True</a> <a id="3886" class="Symbol">(</a><a id="3887" href="Text.Regex.String.Unsafe.html#1577" class="Function">search</a> <a id="3894" class="String">&quot;README.agda&quot;</a> <a id="3908" href="README.Text.Regex.html#3650" class="Function">suffixAgda</a><a id="3918" class="Symbol">)</a>
<a id="3920" class="Symbol">_</a> <a id="3922" class="Symbol">=</a> <a id="3924" class="Symbol">_</a>

<a id="3927" class="Comment">-- Valid: agdai as a suffix</a>
<a id="3955" href="README.Text.Regex.html#3955" class="Function">_</a> <a id="3957" class="Symbol">:</a> <a id="3959" href="Relation.Nullary.Decidable.Core.html#3111" class="Function">True</a> <a id="3964" class="Symbol">(</a><a id="3965" href="Text.Regex.String.Unsafe.html#1577" class="Function">search</a> <a id="3972" class="String">&quot;README.agdai&quot;</a> <a id="3987" href="README.Text.Regex.html#3650" class="Function">suffixAgda</a><a id="3997" class="Symbol">)</a>
<a id="3999" class="Symbol">_</a> <a id="4001" class="Symbol">=</a> <a id="4003" class="Symbol">_</a>


<a id="4007" class="Comment">------------------------------------------------------------------------</a>
<a id="4080" class="Comment">-- Advanced uses</a>

<a id="4098" class="Comment">-- Search does not just return a boolean, it returns an informative answer.</a>
<a id="4174" class="Comment">-- Infix matches are for instance represented using the `Infix` relation on</a>
<a id="4250" class="Comment">-- list. Such a proof pinpoints the exact position of the match:</a>

<a id="4316" class="Keyword">open</a> <a id="4321" class="Keyword">import</a> <a id="4328" href="Data.List.Relation.Binary.Infix.Heterogeneous.html" class="Module">Data.List.Relation.Binary.Infix.Heterogeneous</a>
<a id="4374" class="Keyword">open</a> <a id="4379" class="Keyword">import</a> <a id="4386" href="Data.List.Relation.Binary.Infix.Heterogeneous.Properties.html" class="Module">Data.List.Relation.Binary.Infix.Heterogeneous.Properties</a>
<a id="4443" class="Keyword">open</a> <a id="4448" class="Keyword">import</a> <a id="4455" href="Data.List.Relation.Binary.Pointwise.html" class="Module">Data.List.Relation.Binary.Pointwise</a> <a id="4491" class="Keyword">using</a> <a id="4497" class="Symbol">(</a><a id="4498" href="Data.List.Relation.Binary.Pointwise.html#9894" class="Function">≡⇒Pointwise-≡</a><a id="4511" class="Symbol">)</a>
<a id="4513" class="Keyword">open</a> <a id="4518" class="Keyword">import</a> <a id="4525" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="4564" class="Comment">-- Here is an example of a match: it gives back the substring, the inductive</a>
<a id="4641" class="Comment">-- proof that it is accepted by the regular expression and its precise location</a>
<a id="4721" class="Comment">-- inside the input string</a>
<a id="mariamAGDAlena"></a><a id="4748" href="README.Text.Regex.html#4748" class="Function">mariamAGDAlena</a> <a id="4763" class="Symbol">:</a> <a id="4765" href="Text.Regex.String.Unsafe.html#1388" class="Record">Match</a> <a id="4771" class="String">&quot;Maria Magdalena&quot;</a> <a id="4789" href="README.Text.Regex.html#3219" class="Function">infixAgda</a>
<a id="4799" href="README.Text.Regex.html#4748" class="Function">mariamAGDAlena</a> <a id="4814" class="Symbol">=</a> <a id="4816" class="Keyword">record</a>
  <a id="4825" class="Symbol">{</a> <a id="4827" href="Text.Regex.String.Unsafe.html#1467" class="Field">string</a>  <a id="4835" class="Symbol">=</a> <a id="4837" class="String">&quot;agda&quot;</a>                     <a id="4864" class="Comment">-- we have found &quot;agda&quot;</a>
  <a id="4890" class="Symbol">;</a> <a id="4892" href="Text.Regex.String.Unsafe.html#1488" class="Field">match</a>   <a id="4900" class="Symbol">=</a> <a id="4902" href="Relation.Nullary.Decidable.Core.html#4275" class="Function">from-yes</a> <a id="4911" class="Symbol">(</a><a id="4912" class="String">&quot;agda&quot;</a> <a id="4919" href="Text.Regex.String.Unsafe.html#1080" class="Function Operator">∈?</a> <a id="4922" href="README.Text.Regex.html#3098" class="Function">agda</a><a id="4926" class="Symbol">)</a>  <a id="4929" class="Comment">-- a proof of the match</a>
  <a id="4955" class="Symbol">;</a> <a id="4957" href="Text.Regex.String.Unsafe.html#1530" class="Field">related</a> <a id="4965" class="Symbol">=</a> <a id="4967" href="README.Text.Regex.html#5032" class="Function">proof</a>                      <a id="4994" class="Comment">-- and its location</a>
  <a id="5016" class="Symbol">}</a>

  <a id="5021" class="Keyword">where</a>

    <a id="5032" href="README.Text.Regex.html#5032" class="Function">proof</a> <a id="5038" class="Symbol">:</a> <a id="5040" href="Data.List.Relation.Binary.Infix.Heterogeneous.html#803" class="Datatype">Infix</a> <a id="5046" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a> <a id="5050" class="Symbol">(</a><a id="5051" href="Data.String.Base.html#1541" class="Primitive">toList</a> <a id="5058" class="String">&quot;agda&quot;</a><a id="5064" class="Symbol">)</a> <a id="5066" class="Symbol">(</a><a id="5067" href="Data.String.Base.html#1541" class="Primitive">toList</a> <a id="5074" class="String">&quot;Maria Magdalena&quot;</a><a id="5091" class="Symbol">)</a>
    <a id="5097" href="README.Text.Regex.html#5032" class="Function">proof</a> <a id="5103" class="Symbol">=</a> <a id="5105" href="Data.String.Base.html#1541" class="Primitive">toList</a> <a id="5112" class="String">&quot;Maria M&quot;</a>
        <a id="5130" href="Data.List.Relation.Binary.Infix.Heterogeneous.html#1157" class="Function Operator">++ⁱ</a> <a id="5134" href="Data.List.Relation.Binary.Infix.Heterogeneous.Properties.html#1661" class="Function">fromPointwise</a> <a id="5148" class="Symbol">(</a><a id="5149" href="Data.List.Relation.Binary.Pointwise.html#9894" class="Function">≡⇒Pointwise-≡</a> <a id="5163" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="5167" class="Symbol">)</a>
        <a id="5177" href="Data.List.Relation.Binary.Infix.Heterogeneous.html#1276" class="Function Operator">ⁱ++</a> <a id="5181" href="Data.String.Base.html#1541" class="Primitive">toList</a> <a id="5188" class="String">&quot;lena&quot;</a>


<a id="5197" class="Comment">-- And here is the proof that search returns such an object</a>
<a id="5257" href="README.Text.Regex.html#5257" class="Function">_</a> <a id="5259" class="Symbol">:</a> <a id="5261" href="Text.Regex.String.Unsafe.html#1577" class="Function">search</a> <a id="5268" class="String">&quot;Maria Magdalena&quot;</a> <a id="5286" href="README.Text.Regex.html#3219" class="Function">infixAgda</a> <a id="5296" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5298" href="Relation.Nullary.Decidable.Core.html#1613" class="InductiveConstructor">yes</a> <a id="5302" href="README.Text.Regex.html#4748" class="Function">mariamAGDAlena</a>
<a id="5317" class="Symbol">_</a> <a id="5319" class="Symbol">=</a> <a id="5321" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre></body></html>