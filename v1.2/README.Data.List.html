<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.List</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Documentation for the List type</a>
<a id="141" class="Comment">------------------------------------------------------------------------</a>

<a id="215" class="Symbol">{-#</a> <a id="219" class="Keyword">OPTIONS</a> <a id="227" class="Pragma">--warning</a> <a id="237" class="Pragma">noMissingDefinitions</a> <a id="258" class="Symbol">#-}</a>

<a id="263" class="Keyword">module</a> <a id="270" href="README.Data.List.html" class="Module">README.Data.List</a> <a id="287" class="Keyword">where</a>

<a id="294" class="Keyword">open</a> <a id="299" class="Keyword">import</a> <a id="306" href="Algebra.Structures.html" class="Module">Algebra.Structures</a>
<a id="325" class="Keyword">open</a> <a id="330" class="Keyword">import</a> <a id="337" href="Data.Char.Base.html" class="Module">Data.Char.Base</a> <a id="352" class="Keyword">using</a> <a id="358" class="Symbol">(</a><a id="359" href="Agda.Builtin.Char.html#200" class="Postulate">Char</a><a id="363" class="Symbol">;</a> <a id="365" href="Agda.Builtin.Char.html#439" class="Primitive">fromℕ</a><a id="370" class="Symbol">)</a>
<a id="372" class="Keyword">open</a> <a id="377" class="Keyword">import</a> <a id="384" href="Data.Char.Properties.html" class="Module">Data.Char.Properties</a> <a id="405" class="Symbol">as</a> <a id="408" class="Module">CharProp</a> <a id="417" class="Keyword">hiding</a> <a id="424" class="Symbol">(</a><a id="425" href="Data.Char.Properties.html#3908" class="Function">setoid</a><a id="431" class="Symbol">)</a>
<a id="433" class="Keyword">open</a> <a id="438" class="Keyword">import</a> <a id="445" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="454" class="Keyword">open</a> <a id="459" class="Keyword">import</a> <a id="466" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="486" class="Symbol">as</a> <a id="489" class="Module">NatProp</a>
<a id="497" class="Keyword">open</a> <a id="502" class="Keyword">import</a> <a id="509" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="549" class="Keyword">using</a> <a id="555" class="Symbol">(</a><a id="556" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="559" class="Symbol">;</a> <a id="561" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="565" class="Symbol">;</a> <a id="567" href="Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a><a id="570" class="Symbol">;</a> <a id="572" href="Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a><a id="576" class="Symbol">;</a> <a id="578" href="Relation.Binary.PropositionalEquality.html#2290" class="Function">setoid</a><a id="584" class="Symbol">)</a>

<a id="587" class="Comment">------------------------------------------------------------------------</a>
<a id="660" class="Comment">-- 1. Basics</a>
<a id="673" class="Comment">------------------------------------------------------------------------</a>
<a id="746" class="Comment">-- The `List` datatype is exported by the following file:</a>

<a id="805" class="Keyword">open</a> <a id="810" class="Keyword">import</a> <a id="817" href="Data.List.html" class="Module">Data.List</a>

<a id="828" class="Keyword">module</a> <a id="Basics"></a><a id="835" href="README.Data.List.html#835" class="Module">Basics</a> <a id="842" class="Keyword">where</a>

  <a id="851" class="Comment">-- Lists are built using the &quot;[]&quot; and &quot;_∷_&quot; constructors.</a>

  <a id="Basics.list₁"></a><a id="912" href="README.Data.List.html#912" class="Function">list₁</a> <a id="918" class="Symbol">:</a> <a id="920" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="925" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
  <a id="929" href="README.Data.List.html#912" class="Function">list₁</a> <a id="935" class="Symbol">=</a> <a id="937" class="Number">3</a> <a id="939" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="941" class="Number">1</a> <a id="943" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="945" class="Number">2</a> <a id="947" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="949" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>

  <a id="955" class="Comment">-- Basic operations over lists are also exported by the same file.</a>

  <a id="Basics.lem₁"></a><a id="1025" href="README.Data.List.html#1025" class="Function">lem₁</a> <a id="1030" class="Symbol">:</a> <a id="1032" href="Data.List.Base.html#4103" class="Function">sum</a> <a id="1036" href="README.Data.List.html#912" class="Function">list₁</a> <a id="1042" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1044" class="Number">6</a>
  <a id="1048" href="README.Data.List.html#1025" class="Function">lem₁</a> <a id="1053" class="Symbol">=</a> <a id="1055" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₂"></a><a id="1063" href="README.Data.List.html#1063" class="Function">lem₂</a> <a id="1068" class="Symbol">:</a> <a id="1070" href="Data.List.Base.html#1383" class="Function">map</a> <a id="1074" class="Symbol">(</a><a id="1075" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+</a> <a id="1078" class="Number">2</a><a id="1079" class="Symbol">)</a> <a id="1081" href="README.Data.List.html#912" class="Function">list₁</a> <a id="1087" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1089" class="Number">5</a> <a id="1091" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1093" class="Number">3</a> <a id="1095" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1097" class="Number">4</a> <a id="1099" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1101" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1106" href="README.Data.List.html#1063" class="Function">lem₂</a> <a id="1111" class="Symbol">=</a> <a id="1113" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₃"></a><a id="1121" href="README.Data.List.html#1121" class="Function">lem₃</a> <a id="1126" class="Symbol">:</a> <a id="1128" href="Data.List.Base.html#6537" class="Function">take</a> <a id="1133" class="Number">2</a> <a id="1135" href="README.Data.List.html#912" class="Function">list₁</a> <a id="1141" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1143" class="Number">3</a> <a id="1145" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1147" class="Number">1</a> <a id="1149" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1151" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1156" href="README.Data.List.html#1121" class="Function">lem₃</a> <a id="1161" class="Symbol">=</a> <a id="1163" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₄"></a><a id="1171" href="README.Data.List.html#1171" class="Function">lem₄</a> <a id="1176" class="Symbol">:</a> <a id="1178" href="Data.List.Base.html#8643" class="Function">reverse</a> <a id="1186" href="README.Data.List.html#912" class="Function">list₁</a> <a id="1192" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1194" class="Number">2</a> <a id="1196" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1198" class="Number">1</a> <a id="1200" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1202" class="Number">3</a> <a id="1204" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1206" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1211" href="README.Data.List.html#1171" class="Function">lem₄</a> <a id="1216" class="Symbol">=</a> <a id="1218" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₅"></a><a id="1226" href="README.Data.List.html#1226" class="Function">lem₅</a> <a id="1231" class="Symbol">:</a> <a id="1233" href="README.Data.List.html#912" class="Function">list₁</a> <a id="1239" href="Data.List.Base.html#1649" class="Function Operator">++</a> <a id="1242" href="README.Data.List.html#912" class="Function">list₁</a> <a id="1248" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1250" class="Number">3</a> <a id="1252" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1254" class="Number">1</a> <a id="1256" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1258" class="Number">2</a> <a id="1260" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1262" class="Number">3</a> <a id="1264" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1266" class="Number">1</a> <a id="1268" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1270" class="Number">2</a> <a id="1272" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1274" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1279" href="README.Data.List.html#1226" class="Function">lem₅</a> <a id="1284" class="Symbol">=</a> <a id="1286" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="1294" class="Comment">-- Various properties of these operations can be found in:</a>

  <a id="1356" class="Keyword">open</a> <a id="1361" class="Keyword">import</a> <a id="1368" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>

  <a id="Basics.lem₆"></a><a id="1392" href="README.Data.List.html#1392" class="Function">lem₆</a> <a id="1397" class="Symbol">:</a> <a id="1399" class="Symbol">∀</a> <a id="1401" href="README.Data.List.html#1401" class="Bound">n</a> <a id="1403" class="Symbol">(</a><a id="1404" href="README.Data.List.html#1404" class="Bound">xs</a> <a id="1407" class="Symbol">:</a> <a id="1409" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1414" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1415" class="Symbol">)</a> <a id="1417" class="Symbol">→</a> <a id="1419" href="Data.List.Base.html#6537" class="Function">take</a> <a id="1424" href="README.Data.List.html#1401" class="Bound">n</a> <a id="1426" href="README.Data.List.html#1404" class="Bound">xs</a> <a id="1429" href="Data.List.Base.html#1649" class="Function Operator">++</a> <a id="1432" href="Data.List.Base.html#6657" class="Function">drop</a> <a id="1437" href="README.Data.List.html#1401" class="Bound">n</a> <a id="1439" href="README.Data.List.html#1404" class="Bound">xs</a> <a id="1442" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1444" href="README.Data.List.html#1404" class="Bound">xs</a>
  <a id="1449" href="README.Data.List.html#1392" class="Function">lem₆</a> <a id="1454" class="Symbol">=</a> <a id="1456" href="Data.List.Properties.html#24321" class="Function">take++drop</a>

  <a id="Basics.lem₇"></a><a id="1470" href="README.Data.List.html#1470" class="Function">lem₇</a> <a id="1475" class="Symbol">:</a> <a id="1477" class="Symbol">∀</a> <a id="1479" class="Symbol">(</a><a id="1480" href="README.Data.List.html#1480" class="Bound">xs</a> <a id="1483" class="Symbol">:</a> <a id="1485" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1490" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1491" class="Symbol">)</a> <a id="1493" class="Symbol">→</a> <a id="1495" href="Data.List.Base.html#8643" class="Function">reverse</a> <a id="1503" class="Symbol">(</a><a id="1504" href="Data.List.Base.html#8643" class="Function">reverse</a> <a id="1512" href="README.Data.List.html#1480" class="Bound">xs</a><a id="1514" class="Symbol">)</a> <a id="1516" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1518" href="README.Data.List.html#1480" class="Bound">xs</a>
  <a id="1523" href="README.Data.List.html#1470" class="Function">lem₇</a> <a id="1528" class="Symbol">=</a> <a id="1530" href="Data.List.Properties.html#31924" class="Function">reverse-involutive</a>

  <a id="Basics.lem₈"></a><a id="1552" href="README.Data.List.html#1552" class="Function">lem₈</a> <a id="1557" class="Symbol">:</a> <a id="1559" class="Symbol">∀</a> <a id="1561" class="Symbol">(</a><a id="1562" href="README.Data.List.html#1562" class="Bound">xs</a> <a id="1565" href="README.Data.List.html#1565" class="Bound">ys</a> <a id="1568" href="README.Data.List.html#1568" class="Bound">zs</a> <a id="1571" class="Symbol">:</a> <a id="1573" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1578" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1579" class="Symbol">)</a> <a id="1581" class="Symbol">→</a> <a id="1583" class="Symbol">(</a><a id="1584" href="README.Data.List.html#1562" class="Bound">xs</a> <a id="1587" href="Data.List.Base.html#1649" class="Function Operator">++</a> <a id="1590" href="README.Data.List.html#1565" class="Bound">ys</a><a id="1592" class="Symbol">)</a> <a id="1594" href="Data.List.Base.html#1649" class="Function Operator">++</a> <a id="1597" href="README.Data.List.html#1568" class="Bound">zs</a> <a id="1600" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1602" href="README.Data.List.html#1562" class="Bound">xs</a> <a id="1605" href="Data.List.Base.html#1649" class="Function Operator">++</a> <a id="1608" class="Symbol">(</a><a id="1609" href="README.Data.List.html#1565" class="Bound">ys</a> <a id="1612" href="Data.List.Base.html#1649" class="Function Operator">++</a> <a id="1615" href="README.Data.List.html#1568" class="Bound">zs</a><a id="1617" class="Symbol">)</a>
  <a id="1621" href="README.Data.List.html#1552" class="Function">lem₈</a> <a id="1626" class="Symbol">=</a> <a id="1628" href="Data.List.Properties.html#4805" class="Function">++-assoc</a>

<a id="1638" class="Comment">------------------------------------------------------------------------</a>
<a id="1711" class="Comment">-- 2. Binary relations over lists</a>
<a id="1745" class="Comment">------------------------------------------------------------------------</a>

<a id="1819" class="Comment">-- All binary relations over lists are found in the folder</a>
<a id="1878" class="Comment">-- `Data.List.Relation.Binary`.</a>

<a id="1911" class="Comment">------------------------------------------------------------------------</a>
<a id="1984" class="Comment">-- Pointwise</a>

<a id="1998" class="Keyword">module</a> <a id="PointwiseExplanation"></a><a id="2005" href="README.Data.List.html#2005" class="Module">PointwiseExplanation</a> <a id="2026" class="Keyword">where</a>

  <a id="2035" class="Comment">-- One of the most basic ways to form a binary relation between two</a>
  <a id="2105" class="Comment">-- lists of type `List A`, given a binary relation over `A`, is to say</a>
  <a id="2178" class="Comment">-- that two lists are related if:</a>
  <a id="2214" class="Comment">--   i) the first elements in the lists are related</a>
  <a id="2268" class="Comment">--   ii) the second elements in the lists are related</a>
  <a id="2324" class="Comment">--   iii) the third elements in the lists are related etc.</a>
  <a id="2385" class="Comment">--</a>
  <a id="2390" class="Comment">-- A formalisation of this &quot;pointwise&quot; lifting of a relation to lists</a>
  <a id="2462" class="Comment">-- is found in:</a>

  <a id="2481" class="Keyword">open</a> <a id="2486" class="Keyword">import</a> <a id="2493" href="Data.List.Relation.Binary.Pointwise.html" class="Module">Data.List.Relation.Binary.Pointwise</a>

  <a id="2532" class="Comment">-- The same syntax to construct a list (`[]` &amp; `_∷_`) is used to</a>
  <a id="2599" class="Comment">-- construct proofs for the `Pointwise` relation. For example if you</a>
  <a id="2670" class="Comment">-- want to prove that one list is strictly less than another list:</a>

  <a id="PointwiseExplanation.lem₁"></a><a id="2740" href="README.Data.List.html#2740" class="Function">lem₁</a> <a id="2745" class="Symbol">:</a> <a id="2747" href="Data.List.Relation.Binary.Pointwise.html#1305" class="Datatype">Pointwise</a> <a id="2757" href="Data.Nat.Base.html#1047" class="Function Operator">_&lt;_</a> <a id="2761" class="Symbol">(</a><a id="2762" class="Number">0</a> <a id="2764" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2766" class="Number">2</a> <a id="2768" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2770" class="Number">1</a> <a id="2772" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2774" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2776" class="Symbol">)</a> <a id="2778" class="Symbol">(</a><a id="2779" class="Number">1</a> <a id="2781" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2783" class="Number">4</a> <a id="2785" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2787" class="Number">2</a> <a id="2789" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2791" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2793" class="Symbol">)</a>
  <a id="2797" href="README.Data.List.html#2740" class="Function">lem₁</a> <a id="2802" class="Symbol">=</a> <a id="2804" href="README.Data.List.html#2839" class="Function">0&lt;1</a> <a id="2808" href="Data.List.Relation.Binary.Pointwise.html#1444" class="InductiveConstructor Operator">∷</a> <a id="2810" href="README.Data.List.html#2857" class="Function">2&lt;4</a> <a id="2814" href="Data.List.Relation.Binary.Pointwise.html#1444" class="InductiveConstructor Operator">∷</a> <a id="2816" href="README.Data.List.html#2887" class="Function">1&lt;2</a> <a id="2820" href="Data.List.Relation.Binary.Pointwise.html#1444" class="InductiveConstructor Operator">∷</a> <a id="2822" href="Data.List.Relation.Binary.Pointwise.html#1416" class="InductiveConstructor">[]</a>
    <a id="2829" class="Keyword">where</a>
    <a id="2839" href="README.Data.List.html#2839" class="Function">0&lt;1</a> <a id="2843" class="Symbol">=</a> <a id="2845" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="2849" href="Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a>
    <a id="2857" href="README.Data.List.html#2857" class="Function">2&lt;4</a> <a id="2861" class="Symbol">=</a> <a id="2863" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="2867" class="Symbol">(</a><a id="2868" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="2872" class="Symbol">(</a><a id="2873" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="2877" href="Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a><a id="2880" class="Symbol">))</a>
    <a id="2887" href="README.Data.List.html#2887" class="Function">1&lt;2</a> <a id="2891" class="Symbol">=</a> <a id="2893" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="2897" href="README.Data.List.html#2839" class="Function">0&lt;1</a>

  <a id="2904" class="Comment">-- Lists that are related by `Pointwise` must be of the same length.</a>
  <a id="2975" class="Comment">-- For example:</a>

  <a id="2994" class="Keyword">open</a> <a id="2999" class="Keyword">import</a> <a id="3006" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="3023" class="Keyword">using</a> <a id="3029" class="Symbol">(</a><a id="3030" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="3032" class="Symbol">)</a>

  <a id="PointwiseExplanation.lem₂"></a><a id="3037" href="README.Data.List.html#3037" class="Function">lem₂</a> <a id="3042" class="Symbol">:</a> <a id="3044" href="Relation.Nullary.html#653" class="Function Operator">¬</a> <a id="3046" href="Data.List.Relation.Binary.Pointwise.html#1305" class="Datatype">Pointwise</a> <a id="3056" href="Data.Nat.Base.html#1047" class="Function Operator">_&lt;_</a> <a id="3060" class="Symbol">(</a><a id="3061" class="Number">0</a> <a id="3063" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3065" class="Number">2</a> <a id="3067" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3069" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="3071" class="Symbol">)</a> <a id="3073" class="Symbol">(</a><a id="3074" class="Number">1</a> <a id="3076" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3078" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="3080" class="Symbol">)</a>
  <a id="3084" href="README.Data.List.html#3037" class="Function">lem₂</a> <a id="3089" class="Symbol">(</a><a id="3090" href="README.Data.List.html#3090" class="Bound">0&lt;1</a> <a id="3094" href="Data.List.Relation.Binary.Pointwise.html#1444" class="InductiveConstructor Operator">∷</a> <a id="3096" class="Symbol">())</a>

<a id="3101" class="Comment">------------------------------------------------------------------------</a>
<a id="3174" class="Comment">-- Equality</a>

<a id="3187" class="Keyword">module</a> <a id="EqualityExplanation"></a><a id="3194" href="README.Data.List.html#3194" class="Module">EqualityExplanation</a> <a id="3214" class="Keyword">where</a>

  <a id="3223" class="Comment">-- There are many different options for what it means for two</a>
  <a id="3287" class="Comment">-- different lists of type `List A` to be &quot;equal&quot;. We will initially</a>
  <a id="3358" class="Comment">-- consider notions of equality that require the list elements to be</a>
  <a id="3429" class="Comment">-- in the same order and later discuss other types of equality.</a>

  <a id="3496" class="Comment">-- The most basic option in the former case is simply to use</a>
  <a id="3559" class="Comment">-- propositional equality `_≡_` over lists:</a>

  <a id="3606" class="Keyword">open</a> <a id="3611" class="Keyword">import</a> <a id="3618" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
    <a id="3660" class="Keyword">using</a> <a id="3666" class="Symbol">(</a><a id="3667" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="3670" class="Symbol">;</a> <a id="3672" href="Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a><a id="3675" class="Symbol">;</a> <a id="3677" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="3681" class="Symbol">)</a>

  <a id="EqualityExplanation.lem₁"></a><a id="3686" href="README.Data.List.html#3686" class="Function">lem₁</a> <a id="3691" class="Symbol">:</a> <a id="3693" class="Number">1</a> <a id="3695" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3697" class="Number">2</a> <a id="3699" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3701" class="Number">3</a> <a id="3703" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3705" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="3708" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3710" class="Number">1</a> <a id="3712" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3714" class="Number">2</a> <a id="3716" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3718" class="Number">3</a> <a id="3720" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3722" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="3727" href="README.Data.List.html#3686" class="Function">lem₁</a> <a id="3732" class="Symbol">=</a> <a id="3734" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="3742" class="Comment">-- However propositional equality is only suitable when we want to</a>
  <a id="3811" class="Comment">-- use propositional equality to compare the individual elements.</a>
  <a id="3879" class="Comment">-- Although a contrived example, consider trying to prove the</a>
  <a id="3943" class="Comment">-- equality of two lists of the type `List (ℕ → ℕ)`:</a>

  <a id="EqualityExplanation.lem₂"></a><a id="3999" href="README.Data.List.html#3999" class="Postulate">lem₂</a> <a id="4004" class="Symbol">:</a> <a id="4006" class="Symbol">(λ</a> <a id="4009" href="README.Data.List.html#4009" class="Bound">x</a> <a id="4011" class="Symbol">→</a> <a id="4013" class="Number">2</a> <a id="4015" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="4017" href="README.Data.List.html#4009" class="Bound">x</a> <a id="4019" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4021" class="Number">2</a><a id="4022" class="Symbol">)</a> <a id="4024" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4026" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="4029" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4031" class="Symbol">(λ</a> <a id="4034" href="README.Data.List.html#4034" class="Bound">x</a> <a id="4036" class="Symbol">→</a> <a id="4038" class="Number">2</a> <a id="4040" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="4042" class="Symbol">(</a><a id="4043" href="README.Data.List.html#4034" class="Bound">x</a> <a id="4045" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4047" class="Number">1</a><a id="4048" class="Symbol">))</a> <a id="4051" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4053" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>

  <a id="4059" class="Comment">-- In such a case it is impossible to prove the two lists equal with</a>
  <a id="4130" class="Comment">-- refl as the two functions are not propositionally equal. In the</a>
  <a id="4199" class="Comment">-- absence of postulating function extensionality (see README.Axioms),</a>
  <a id="4272" class="Comment">-- the most common definition of function equality is to say that two</a>
  <a id="4344" class="Comment">-- functions are equal if their outputs are always propositionally</a>
  <a id="4413" class="Comment">-- equal for any input. This notion of function equality `_≗_` is</a>
  <a id="4481" class="Comment">-- found in:</a>

  <a id="4497" class="Keyword">open</a> <a id="4502" class="Keyword">import</a> <a id="4509" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="4547" class="Keyword">using</a> <a id="4553" class="Symbol">(</a><a id="4554" href="Relation.Binary.PropositionalEquality.html#2941" class="Function Operator">_≗_</a><a id="4557" class="Symbol">)</a>

  <a id="4562" class="Comment">-- We now want to use the `Pointwise` relation to say that the two</a>
  <a id="4631" class="Comment">-- lists are equal if their elements are pointwise equal with resepct</a>
  <a id="4703" class="Comment">-- to `_≗_`. However instead of using the pointwise module directly</a>
  <a id="4773" class="Comment">-- to write:</a>

  <a id="4789" class="Keyword">open</a> <a id="4794" class="Keyword">import</a> <a id="4801" href="Data.List.Relation.Binary.Pointwise.html" class="Module">Data.List.Relation.Binary.Pointwise</a> <a id="4837" class="Keyword">using</a> <a id="4843" class="Symbol">(</a><a id="4844" href="Data.List.Relation.Binary.Pointwise.html#1305" class="Datatype">Pointwise</a><a id="4853" class="Symbol">)</a>

  <a id="EqualityExplanation.lem₃"></a><a id="4858" href="README.Data.List.html#4858" class="Postulate">lem₃</a> <a id="4863" class="Symbol">:</a> <a id="4865" href="Data.List.Relation.Binary.Pointwise.html#1305" class="Datatype">Pointwise</a> <a id="4875" href="Relation.Binary.PropositionalEquality.html#2941" class="Function Operator">_≗_</a> <a id="4879" class="Symbol">((λ</a> <a id="4883" href="README.Data.List.html#4883" class="Bound">x</a> <a id="4885" class="Symbol">→</a> <a id="4887" href="README.Data.List.html#4883" class="Bound">x</a> <a id="4889" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4891" class="Number">1</a><a id="4892" class="Symbol">)</a> <a id="4894" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4896" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4898" class="Symbol">)</a> <a id="4900" class="Symbol">((λ</a> <a id="4904" href="README.Data.List.html#4904" class="Bound">x</a> <a id="4906" class="Symbol">→</a> <a id="4908" href="README.Data.List.html#4904" class="Bound">x</a> <a id="4910" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4912" class="Number">2</a> <a id="4914" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="4916" class="Number">1</a><a id="4917" class="Symbol">)</a> <a id="4919" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4921" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4923" class="Symbol">)</a>

  <a id="4928" class="Comment">-- the library provides some nicer wrappers and infix notation in the</a>
  <a id="5000" class="Comment">-- folder &quot;Data.List.Relation.Binary.Equality&quot;.</a>

  <a id="5051" class="Comment">-- Within this folder there are four different modules.</a>

  <a id="5110" class="Keyword">import</a> <a id="5117" href="Data.List.Relation.Binary.Equality.Setoid.html" class="Module">Data.List.Relation.Binary.Equality.Setoid</a>           <a id="5169" class="Symbol">as</a> <a id="5172" class="Module">SetoidEq</a>
  <a id="5183" class="Keyword">import</a> <a id="5190" href="Data.List.Relation.Binary.Equality.DecSetoid.html" class="Module">Data.List.Relation.Binary.Equality.DecSetoid</a>        <a id="5242" class="Symbol">as</a> <a id="5245" class="Module">DecSetoidEq</a>
  <a id="5259" class="Keyword">import</a> <a id="5266" href="Data.List.Relation.Binary.Equality.Propositional.html" class="Module">Data.List.Relation.Binary.Equality.Propositional</a>    <a id="5318" class="Symbol">as</a> <a id="5321" class="Module">PropEq</a>
  <a id="5330" class="Keyword">import</a> <a id="5337" href="Data.List.Relation.Binary.Equality.DecPropositional.html" class="Module">Data.List.Relation.Binary.Equality.DecPropositional</a> <a id="5389" class="Symbol">as</a> <a id="5392" class="Module">DecPropEq</a>

  <a id="5405" class="Comment">-- Which one should be used depends on whether the underlying equality</a>
  <a id="5478" class="Comment">-- over &quot;A&quot; is:</a>
  <a id="5496" class="Comment">--   i)  propositional or setoid-based</a>
  <a id="5537" class="Comment">--   ii) decidable.</a>

  <a id="5560" class="Comment">-- Each of the modules except `PropEq` are designed to be opened with a</a>
  <a id="5634" class="Comment">-- module parameter. This is to avoid having to specify the underlying</a>
  <a id="5707" class="Comment">-- equality relation or the decidability proofs every time you use the</a>
  <a id="5780" class="Comment">-- list equality.</a>

  <a id="5801" class="Comment">-- In our example function equality is not decidable and not propositional</a>
  <a id="5878" class="Comment">-- and so we want to use the `SetoidEq` module. This requires a proof that</a>
  <a id="5955" class="Comment">-- the `_≗_` relation forms a setoid over functions of the type `ℕ → ℕ`.</a>
  <a id="6030" class="Comment">-- This is found in:</a>

  <a id="6054" class="Keyword">open</a> <a id="6059" class="Keyword">import</a> <a id="6066" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="6104" class="Keyword">using</a> <a id="6110" class="Symbol">(</a><a id="6111" href="Relation.Binary.PropositionalEquality.html#2827" class="Function Operator">_→-setoid_</a><a id="6121" class="Symbol">)</a>

  <a id="6126" class="Comment">-- The `SetoidEq` module should therefore be opened as follows:</a>

  <a id="6193" class="Keyword">open</a> <a id="6198" href="Data.List.Relation.Binary.Equality.Setoid.html" class="Module">SetoidEq</a> <a id="6207" class="Symbol">(</a><a id="6208" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="6210" href="Relation.Binary.PropositionalEquality.html#2827" class="Function Operator">→-setoid</a> <a id="6219" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="6220" class="Symbol">)</a>

  <a id="6225" class="Comment">-- All four equality modules provide an infix operator `_≋_` for the</a>
  <a id="6296" class="Comment">-- new equality relation over lists. The type of `lem₃` can therefore</a>
  <a id="6368" class="Comment">-- be rewritten as:</a>

  <a id="EqualityExplanation.lem₄"></a><a id="6391" href="README.Data.List.html#6391" class="Function">lem₄</a> <a id="6396" class="Symbol">:</a> <a id="6398" class="Symbol">(λ</a> <a id="6401" href="README.Data.List.html#6401" class="Bound">x</a> <a id="6403" class="Symbol">→</a> <a id="6405" href="README.Data.List.html#6401" class="Bound">x</a> <a id="6407" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6409" class="Number">1</a><a id="6410" class="Symbol">)</a> <a id="6412" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6414" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="6417" href="Data.List.Relation.Binary.Equality.Setoid.html#994" class="Function Operator">≋</a> <a id="6419" class="Symbol">(λ</a> <a id="6422" href="README.Data.List.html#6422" class="Bound">x</a> <a id="6424" class="Symbol">→</a> <a id="6426" href="README.Data.List.html#6422" class="Bound">x</a> <a id="6428" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6430" class="Number">2</a> <a id="6432" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="6434" class="Number">1</a><a id="6435" class="Symbol">)</a> <a id="6437" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6439" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="6444" href="README.Data.List.html#6391" class="Function">lem₄</a> <a id="6449" class="Symbol">=</a> <a id="6451" href="README.Data.List.html#6482" class="Function">2x+2≗2[x+1]</a> <a id="6463" href="Data.List.Relation.Binary.Pointwise.html#1444" class="InductiveConstructor Operator">∷</a> <a id="6465" href="Data.List.Relation.Binary.Pointwise.html#1416" class="InductiveConstructor">[]</a>
    <a id="6472" class="Keyword">where</a>
    <a id="6482" href="README.Data.List.html#6482" class="Function">2x+2≗2[x+1]</a> <a id="6494" class="Symbol">:</a> <a id="6496" class="Symbol">(λ</a> <a id="6499" href="README.Data.List.html#6499" class="Bound">x</a> <a id="6501" class="Symbol">→</a> <a id="6503" href="README.Data.List.html#6499" class="Bound">x</a> <a id="6505" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6507" class="Number">1</a><a id="6508" class="Symbol">)</a> <a id="6510" href="Relation.Binary.PropositionalEquality.html#2941" class="Function Operator">≗</a> <a id="6512" class="Symbol">(λ</a> <a id="6515" href="README.Data.List.html#6515" class="Bound">x</a> <a id="6517" class="Symbol">→</a> <a id="6519" href="README.Data.List.html#6515" class="Bound">x</a> <a id="6521" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6523" class="Number">2</a> <a id="6525" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="6527" class="Number">1</a><a id="6528" class="Symbol">)</a>
    <a id="6534" href="README.Data.List.html#6482" class="Function">2x+2≗2[x+1]</a> <a id="6546" href="README.Data.List.html#6546" class="Bound">x</a> <a id="6548" class="Symbol">=</a> <a id="6550" href="Relation.Binary.PropositionalEquality.Core.html#980" class="Function">sym</a> <a id="6554" class="Symbol">(</a><a id="6555" href="Data.Nat.Properties.html#43550" class="Function">+-∸-assoc</a> <a id="6565" href="README.Data.List.html#6546" class="Bound">x</a> <a id="6567" class="Symbol">(</a><a id="6568" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="6572" href="Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a><a id="6575" class="Symbol">))</a>

  <a id="6581" class="Comment">-- The modules also provide proofs that the `_≋_` relation is a</a>
  <a id="6647" class="Comment">-- setoid in its own right and therefore is reflexive, symmetric,</a>
  <a id="6715" class="Comment">-- transitive:</a>

  <a id="EqualityExplanation.lem₅"></a><a id="6733" href="README.Data.List.html#6733" class="Function">lem₅</a> <a id="6738" class="Symbol">:</a> <a id="6740" class="Symbol">(λ</a> <a id="6743" href="README.Data.List.html#6743" class="Bound">x</a> <a id="6745" class="Symbol">→</a> <a id="6747" class="Number">2</a> <a id="6749" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="6751" href="README.Data.List.html#6743" class="Bound">x</a> <a id="6753" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6755" class="Number">2</a><a id="6756" class="Symbol">)</a> <a id="6758" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6760" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="6763" href="Data.List.Relation.Binary.Equality.Setoid.html#994" class="Function Operator">≋</a> <a id="6765" class="Symbol">(λ</a> <a id="6768" href="README.Data.List.html#6768" class="Bound">x</a> <a id="6770" class="Symbol">→</a> <a id="6772" class="Number">2</a> <a id="6774" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="6776" href="README.Data.List.html#6768" class="Bound">x</a> <a id="6778" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6780" class="Number">2</a><a id="6781" class="Symbol">)</a> <a id="6783" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6785" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="6790" href="README.Data.List.html#6733" class="Function">lem₅</a> <a id="6795" class="Symbol">=</a> <a id="6797" href="Data.List.Relation.Binary.Equality.Setoid.html#1256" class="Function">≋-refl</a>

  <a id="6807" class="Comment">-- If we could prove that `_≗_` forms a `DecSetoid` then we could use</a>
  <a id="6879" class="Comment">-- the module `DecSetoidEq` instead. This exports everything from</a>
  <a id="6947" class="Comment">-- `SetoidEq` as well as the additional proof `_≋?_` that the list</a>
  <a id="7016" class="Comment">-- equality is decidable.</a>

  <a id="7045" class="Comment">-- This pattern of four modules for each of the four different types</a>
  <a id="7116" class="Comment">-- of equality is repeated throughout the library (e.g. see the</a>
  <a id="7182" class="Comment">-- `Membership` subheading below). Note that in this case the modules</a>
  <a id="7254" class="Comment">-- `PropEq` and `DecPropEq` are not very useful as if two lists are</a>
  <a id="7324" class="Comment">-- pointwise propositionally equal they are necessarily</a>
  <a id="7382" class="Comment">-- propositionally equal (and vice-versa). There are proofs of this</a>
  <a id="7452" class="Comment">-- fact exported by `PropEq` and `DecPropEq`. Although, these two</a>
  <a id="7520" class="Comment">-- types of list equality are not very useful in practice, they are</a>
  <a id="7590" class="Comment">-- included for completeness&#39;s sake.</a>

<a id="7628" class="Comment">------------------------------------------------------------------------</a>
<a id="7701" class="Comment">-- Permutations</a>

<a id="7718" class="Keyword">module</a> <a id="PermutationExplanation"></a><a id="7725" href="README.Data.List.html#7725" class="Module">PermutationExplanation</a> <a id="7748" class="Keyword">where</a>

  <a id="7757" class="Comment">-- Alternatively you might consider two lists to be equal if they</a>
  <a id="7825" class="Comment">-- contain the same elements regardless of the order of the elements.</a>
  <a id="7897" class="Comment">-- This is known as either &quot;set equality&quot; or a &quot;permutation&quot;.</a>

  <a id="7962" class="Comment">-- The easiest-to-use formalisation of this relation is found in the</a>
  <a id="8033" class="Comment">-- module:</a>

  <a id="8047" class="Keyword">open</a> <a id="8052" class="Keyword">import</a> <a id="8059" href="Data.List.Relation.Binary.Permutation.Inductive.html" class="Module">Data.List.Relation.Binary.Permutation.Inductive</a>

  <a id="8110" class="Comment">-- The permutation relation is written as `_↭_` and has four</a>
  <a id="8173" class="Comment">-- constructors. The first `refl` says that a list is always</a>
  <a id="8236" class="Comment">-- a permutation of itself, the second `prep` says that if the</a>
  <a id="8301" class="Comment">-- heads of the lists are the same they can be skipped, the third</a>
  <a id="8369" class="Comment">-- `swap` says that the first two elements of the lists can be</a>
  <a id="8434" class="Comment">-- swapped and the fourth `trans` says that permutation proofs</a>
  <a id="8499" class="Comment">-- can be chained transitively.</a>

  <a id="8534" class="Comment">-- For example a proof that two lists are a permutation of one</a>
  <a id="8599" class="Comment">-- another can be written as follows:</a>

  <a id="PermutationExplanation.lem₁"></a><a id="8640" href="README.Data.List.html#8640" class="Function">lem₁</a> <a id="8645" class="Symbol">:</a> <a id="8647" class="Number">1</a> <a id="8649" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8651" class="Number">2</a> <a id="8653" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8655" class="Number">3</a> <a id="8657" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8659" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="8662" href="Data.List.Relation.Binary.Permutation.Propositional.html#1036" class="Datatype Operator">↭</a> <a id="8664" class="Number">3</a> <a id="8666" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8668" class="Number">1</a> <a id="8670" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8672" class="Number">2</a> <a id="8674" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8676" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="8681" href="README.Data.List.html#8640" class="Function">lem₁</a> <a id="8686" class="Symbol">=</a> <a id="8688" href="Data.List.Relation.Binary.Permutation.Propositional.html#1211" class="InductiveConstructor">trans</a> <a id="8694" class="Symbol">(</a><a id="8695" href="Data.List.Relation.Binary.Permutation.Propositional.html#1099" class="InductiveConstructor">prep</a> <a id="8700" class="Number">1</a> <a id="8702" class="Symbol">(</a><a id="8703" href="Data.List.Relation.Binary.Permutation.Propositional.html#1151" class="InductiveConstructor">swap</a> <a id="8708" class="Number">2</a> <a id="8710" class="Number">3</a> <a id="8712" href="Data.List.Relation.Binary.Permutation.Propositional.html#1065" class="InductiveConstructor">refl</a><a id="8716" class="Symbol">))</a> <a id="8719" class="Symbol">(</a><a id="8720" href="Data.List.Relation.Binary.Permutation.Propositional.html#1151" class="InductiveConstructor">swap</a> <a id="8725" class="Number">1</a> <a id="8727" class="Number">3</a> <a id="8729" href="Data.List.Relation.Binary.Permutation.Propositional.html#1065" class="InductiveConstructor">refl</a><a id="8733" class="Symbol">)</a>

  <a id="8738" class="Comment">-- In practice it is difficult to parse the constructors in the</a>
  <a id="8804" class="Comment">-- proof above and hence understand why it holds. The</a>
  <a id="8860" class="Comment">-- `PermutationReasoning` module can be used to write this proof</a>
  <a id="8927" class="Comment">-- in a much more readable form:</a>

  <a id="8963" class="Keyword">open</a> <a id="8968" href="Data.List.Relation.Binary.Permutation.Propositional.html#2104" class="Module">PermutationReasoning</a>

  <a id="PermutationExplanation.lem₂"></a><a id="8992" href="README.Data.List.html#8992" class="Function">lem₂</a> <a id="8997" class="Symbol">:</a> <a id="8999" class="Number">1</a> <a id="9001" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9003" class="Number">2</a> <a id="9005" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9007" class="Number">3</a> <a id="9009" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9011" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="9014" href="Data.List.Relation.Binary.Permutation.Propositional.html#1036" class="Datatype Operator">↭</a> <a id="9016" class="Number">3</a> <a id="9018" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9020" class="Number">1</a> <a id="9022" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9024" class="Number">2</a> <a id="9026" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9028" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="9033" href="README.Data.List.html#8992" class="Function">lem₂</a> <a id="9038" class="Symbol">=</a> <a id="9040" href="Relation.Binary.Reasoning.Base.Partial.html#846" class="Function Operator">begin</a>
    <a id="9050" class="Number">1</a> <a id="9052" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9054" class="Number">2</a> <a id="9056" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9058" class="Number">3</a> <a id="9060" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9062" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9066" href="Relation.Binary.Reasoning.Base.Partial.html#912" class="Function Operator">↭⟨</a> <a id="9069" href="Data.List.Relation.Binary.Permutation.Propositional.html#1099" class="InductiveConstructor">prep</a> <a id="9074" class="Number">1</a> <a id="9076" class="Symbol">(</a><a id="9077" href="Data.List.Relation.Binary.Permutation.Propositional.html#1151" class="InductiveConstructor">swap</a> <a id="9082" class="Number">2</a> <a id="9084" class="Number">3</a> <a id="9086" href="Data.List.Relation.Binary.Permutation.Propositional.html#1065" class="InductiveConstructor">refl</a><a id="9090" class="Symbol">)</a> <a id="9092" href="Relation.Binary.Reasoning.Base.Partial.html#912" class="Function Operator">⟩</a>
    <a id="9098" class="Number">1</a> <a id="9100" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9102" class="Number">3</a> <a id="9104" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9106" class="Number">2</a> <a id="9108" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9110" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9114" href="Relation.Binary.Reasoning.Base.Partial.html#912" class="Function Operator">↭⟨</a> <a id="9117" href="Data.List.Relation.Binary.Permutation.Propositional.html#1151" class="InductiveConstructor">swap</a> <a id="9122" class="Number">1</a> <a id="9124" class="Number">3</a> <a id="9126" href="Data.List.Relation.Binary.Permutation.Propositional.html#1065" class="InductiveConstructor">refl</a> <a id="9131" href="Relation.Binary.Reasoning.Base.Partial.html#912" class="Function Operator">⟩</a>
    <a id="9137" class="Number">3</a> <a id="9139" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9141" class="Number">1</a> <a id="9143" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9145" class="Number">2</a> <a id="9147" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9149" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9153" href="Relation.Binary.Reasoning.Base.Single.html#533" class="Function Operator">∎</a>

  <a id="9158" class="Comment">-- As might be expected, properties of the permutation relation may be</a>
  <a id="9231" class="Comment">-- found in `Data.List.Relation.Binary.Permutation.Inductive.Properties`.</a>

  <a id="9308" class="Keyword">open</a> <a id="9313" class="Keyword">import</a> <a id="9320" href="Data.List.Relation.Binary.Permutation.Inductive.Properties.html" class="Module">Data.List.Relation.Binary.Permutation.Inductive.Properties</a>

  <a id="PermutationExplanation.lem₃"></a><a id="9382" href="README.Data.List.html#9382" class="Function">lem₃</a> <a id="9387" class="Symbol">:</a> <a id="9389" class="Symbol">∀</a> <a id="9391" class="Symbol">{</a><a id="9392" href="README.Data.List.html#9392" class="Bound">xs</a> <a id="9395" href="README.Data.List.html#9395" class="Bound">ys</a> <a id="9398" class="Symbol">:</a> <a id="9400" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9405" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="9406" class="Symbol">}</a> <a id="9408" class="Symbol">→</a> <a id="9410" href="README.Data.List.html#9392" class="Bound">xs</a> <a id="9413" href="Data.List.Relation.Binary.Permutation.Propositional.html#1036" class="Datatype Operator">↭</a> <a id="9415" href="README.Data.List.html#9395" class="Bound">ys</a> <a id="9418" class="Symbol">→</a> <a id="9420" href="Data.List.Base.html#1383" class="Function">map</a> <a id="9424" href="Agda.Builtin.Char.html#439" class="Primitive">fromℕ</a> <a id="9430" href="README.Data.List.html#9392" class="Bound">xs</a> <a id="9433" href="Data.List.Relation.Binary.Permutation.Propositional.html#1036" class="Datatype Operator">↭</a> <a id="9435" href="Data.List.Base.html#1383" class="Function">map</a> <a id="9439" href="Agda.Builtin.Char.html#439" class="Primitive">fromℕ</a> <a id="9445" href="README.Data.List.html#9395" class="Bound">ys</a>
  <a id="9450" href="README.Data.List.html#9382" class="Function">lem₃</a> <a id="9455" class="Symbol">=</a> <a id="9457" href="Data.List.Relation.Binary.Permutation.Propositional.Properties.html#2953" class="Function">map⁺</a> <a id="9462" href="Agda.Builtin.Char.html#439" class="Primitive">fromℕ</a>

  <a id="PermutationExplanation.lem₄"></a><a id="9471" href="README.Data.List.html#9471" class="Function">lem₄</a> <a id="9476" class="Symbol">:</a> <a id="9478" href="Algebra.Structures.html#2826" class="Record">IsCommutativeMonoid</a> <a id="9498" class="Symbol">{</a><a id="9499" class="Argument">A</a> <a id="9501" class="Symbol">=</a> <a id="9503" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9508" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="9509" class="Symbol">}</a> <a id="9511" href="Data.List.Relation.Binary.Permutation.Propositional.html#1036" class="Datatype Operator">_↭_</a> <a id="9515" href="Data.List.Base.html#1649" class="Function Operator">_++_</a> <a id="9520" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="9525" href="README.Data.List.html#9471" class="Function">lem₄</a> <a id="9530" class="Symbol">=</a> <a id="9532" href="Data.List.Relation.Binary.Permutation.Propositional.Properties.html#8900" class="Function">++-isCommutativeMonoid</a>

  <a id="9558" class="Comment">-- Note: at the moment permutations have only been formalised for</a>
  <a id="9626" class="Comment">-- propositional equality. Permutations for the other three types of</a>
  <a id="9697" class="Comment">-- equality (decidable propositional, setoid and decidable setoid)</a>
  <a id="9766" class="Comment">-- will hopefully be added in later versions of the library.</a>

<a id="9828" class="Comment">------------------------------------------------------------------------</a>
<a id="9901" class="Comment">-- Other relations</a>

<a id="9921" class="Comment">-- There exist many other binary relations in the</a>
<a id="9971" class="Comment">-- `Data.List.Relation.Binary` folder, including:</a>
<a id="10021" class="Comment">--    1. lexicographic orderings</a>
<a id="10054" class="Comment">--    2. bag/multiset equality</a>
<a id="10085" class="Comment">--    3. the subset relations.</a>
<a id="10116" class="Comment">--    4. the sublist relations</a>

<a id="10148" class="Comment">------------------------------------------------------------------------</a>
<a id="10221" class="Comment">-- 3. Properties of lists</a>
<a id="10247" class="Comment">------------------------------------------------------------------------</a>

<a id="10321" class="Comment">-- Whereas binary relations deal with how two lists relate to one</a>
<a id="10387" class="Comment">-- another, the unary relations in `Data.List.Relation.Unary` are used</a>
<a id="10458" class="Comment">-- to reason about the properties of an individual list.</a>

<a id="10516" class="Comment">------------------------------------------------------------------------</a>
<a id="10589" class="Comment">-- Any</a>

<a id="10597" class="Keyword">module</a> <a id="AnyExplanation"></a><a id="10604" href="README.Data.List.html#10604" class="Module">AnyExplanation</a> <a id="10619" class="Keyword">where</a>

  <a id="10628" class="Comment">-- The predicate `Any` encodes the idea of at least one element of a</a>
  <a id="10699" class="Comment">-- given list satisfying a given property (or more formally a</a>
  <a id="10763" class="Comment">-- predicate, see the `Pred` type in `Relation.Unary`).</a>

  <a id="10822" class="Keyword">open</a> <a id="10827" class="Keyword">import</a> <a id="10834" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="10863" class="Symbol">as</a> <a id="10866" class="Module">Any</a>

  <a id="10873" class="Comment">-- A proof of type Any consists of a sequence of the &quot;there&quot;</a>
  <a id="10936" class="Comment">-- constructors, which says that the element lies in the remainder of</a>
  <a id="11008" class="Comment">-- the list, followed by a single &quot;here&quot; constructor which indicates</a>
  <a id="11079" class="Comment">-- that the head of the list satisfies the predicate and takes a proof</a>
  <a id="11152" class="Comment">-- that it does so.</a>

  <a id="11175" class="Comment">-- For example a proof that a given list of natural numbers contains</a>
  <a id="11246" class="Comment">-- at least one number greater than or equal to 4 can be written as</a>
  <a id="11316" class="Comment">-- follows:</a>

  <a id="AnyExplanation.lem₁"></a><a id="11331" href="README.Data.List.html#11331" class="Function">lem₁</a> <a id="11336" class="Symbol">:</a> <a id="11338" href="Data.List.Relation.Unary.Any.html#1101" class="Datatype">Any</a> <a id="11342" class="Symbol">(</a><a id="11343" class="Number">4</a> <a id="11345" href="Data.Nat.Base.html#937" class="Datatype Operator">≤_</a><a id="11347" class="Symbol">)</a> <a id="11349" class="Symbol">(</a><a id="11350" class="Number">3</a> <a id="11352" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11354" class="Number">5</a> <a id="11356" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11358" class="Number">1</a> <a id="11360" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11362" class="Number">6</a> <a id="11364" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11366" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="11368" class="Symbol">)</a>
  <a id="11372" href="README.Data.List.html#11331" class="Function">lem₁</a> <a id="11377" class="Symbol">=</a> <a id="11379" href="Data.List.Relation.Unary.Any.html#1217" class="InductiveConstructor">there</a> <a id="11385" class="Symbol">(</a><a id="11386" href="Data.List.Relation.Unary.Any.html#1164" class="InductiveConstructor">here</a> <a id="11391" href="README.Data.List.html#11410" class="Function">4≤5</a><a id="11394" class="Symbol">)</a>
    <a id="11400" class="Keyword">where</a>
    <a id="11410" href="README.Data.List.html#11410" class="Function">4≤5</a> <a id="11414" class="Symbol">=</a> <a id="11416" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="11420" class="Symbol">(</a><a id="11421" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="11425" class="Symbol">(</a><a id="11426" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="11430" class="Symbol">(</a><a id="11431" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="11435" href="Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a><a id="11438" class="Symbol">)))</a>

  <a id="11445" class="Comment">-- Note that nothing requires that the proof of `Any` points at the</a>
  <a id="11515" class="Comment">-- first such element in the list. There is therefore an alternative</a>
  <a id="11586" class="Comment">-- proof for the above lemma which points to 6 instead of 5.</a>

  <a id="AnyExplanation.lem₂"></a><a id="11650" href="README.Data.List.html#11650" class="Function">lem₂</a> <a id="11655" class="Symbol">:</a> <a id="11657" href="Data.List.Relation.Unary.Any.html#1101" class="Datatype">Any</a> <a id="11661" class="Symbol">(</a><a id="11662" class="Number">4</a> <a id="11664" href="Data.Nat.Base.html#937" class="Datatype Operator">≤_</a><a id="11666" class="Symbol">)</a> <a id="11668" class="Symbol">(</a><a id="11669" class="Number">3</a> <a id="11671" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11673" class="Number">5</a> <a id="11675" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11677" class="Number">1</a> <a id="11679" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11681" class="Number">6</a> <a id="11683" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11685" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="11687" class="Symbol">)</a>
  <a id="11691" href="README.Data.List.html#11650" class="Function">lem₂</a> <a id="11696" class="Symbol">=</a> <a id="11698" href="Data.List.Relation.Unary.Any.html#1217" class="InductiveConstructor">there</a> <a id="11704" class="Symbol">(</a><a id="11705" href="Data.List.Relation.Unary.Any.html#1217" class="InductiveConstructor">there</a> <a id="11711" class="Symbol">(</a><a id="11712" href="Data.List.Relation.Unary.Any.html#1217" class="InductiveConstructor">there</a> <a id="11718" class="Symbol">(</a><a id="11719" href="Data.List.Relation.Unary.Any.html#1164" class="InductiveConstructor">here</a> <a id="11724" href="README.Data.List.html#11745" class="Function">4≤6</a><a id="11727" class="Symbol">)))</a>
    <a id="11735" class="Keyword">where</a>
    <a id="11745" href="README.Data.List.html#11745" class="Function">4≤6</a> <a id="11749" class="Symbol">=</a> <a id="11751" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="11755" class="Symbol">(</a><a id="11756" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="11760" class="Symbol">(</a><a id="11761" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="11765" class="Symbol">(</a><a id="11766" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="11770" href="Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a><a id="11773" class="Symbol">)))</a>

  <a id="11780" class="Comment">-- There also exist various operations over proofs of `Any` whose names</a>
  <a id="11854" class="Comment">-- shadow the corresponding list operation. The standard way of using</a>
  <a id="11926" class="Comment">-- these is to use `as` to name the module:</a>

  <a id="11973" class="Keyword">import</a> <a id="11980" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="12009" class="Symbol">as</a> <a id="12012" class="Module">Any</a>

  <a id="12019" class="Comment">-- and then use the qualified name `Any.map`. For example, map can</a>
  <a id="12088" class="Comment">-- be used to change the predicate of `Any`:</a>

  <a id="12136" class="Keyword">open</a> <a id="12141" class="Keyword">import</a> <a id="12148" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="12168" class="Keyword">using</a> <a id="12174" class="Symbol">(</a><a id="12175" href="Data.Nat.Properties.html#3922" class="Function">≤-trans</a><a id="12182" class="Symbol">;</a> <a id="12184" href="Data.Nat.Properties.html#6236" class="Function">n≤1+n</a><a id="12189" class="Symbol">)</a>

  <a id="AnyExplanation.lem₃"></a><a id="12194" href="README.Data.List.html#12194" class="Function">lem₃</a> <a id="12199" class="Symbol">:</a> <a id="12201" href="Data.List.Relation.Unary.Any.html#1101" class="Datatype">Any</a> <a id="12205" class="Symbol">(</a><a id="12206" class="Number">3</a> <a id="12208" href="Data.Nat.Base.html#937" class="Datatype Operator">≤_</a><a id="12210" class="Symbol">)</a> <a id="12212" class="Symbol">(</a><a id="12213" class="Number">3</a> <a id="12215" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12217" class="Number">5</a> <a id="12219" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12221" class="Number">1</a> <a id="12223" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12225" class="Number">6</a> <a id="12227" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12229" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="12231" class="Symbol">)</a>
  <a id="12235" href="README.Data.List.html#12194" class="Function">lem₃</a> <a id="12240" class="Symbol">=</a> <a id="12242" href="Data.List.Relation.Unary.Any.html#1686" class="Function">Any.map</a> <a id="12250" href="README.Data.List.html#12277" class="Function">4≤x⇒3≤x</a> <a id="12258" href="README.Data.List.html#11650" class="Function">lem₂</a>
    <a id="12267" class="Keyword">where</a>
    <a id="12277" href="README.Data.List.html#12277" class="Function">4≤x⇒3≤x</a> <a id="12285" class="Symbol">:</a> <a id="12287" class="Symbol">∀</a> <a id="12289" class="Symbol">{</a><a id="12290" href="README.Data.List.html#12290" class="Bound">x</a><a id="12291" class="Symbol">}</a> <a id="12293" class="Symbol">→</a> <a id="12295" class="Number">4</a> <a id="12297" href="Data.Nat.Base.html#937" class="Datatype Operator">≤</a> <a id="12299" href="README.Data.List.html#12290" class="Bound">x</a> <a id="12301" class="Symbol">→</a> <a id="12303" class="Number">3</a> <a id="12305" href="Data.Nat.Base.html#937" class="Datatype Operator">≤</a> <a id="12307" href="README.Data.List.html#12290" class="Bound">x</a>
    <a id="12313" href="README.Data.List.html#12277" class="Function">4≤x⇒3≤x</a> <a id="12321" class="Symbol">=</a> <a id="12323" href="Data.Nat.Properties.html#3922" class="Function">≤-trans</a> <a id="12331" class="Symbol">(</a><a id="12332" href="Data.Nat.Properties.html#6236" class="Function">n≤1+n</a> <a id="12338" class="Number">3</a><a id="12339" class="Symbol">)</a>

<a id="12342" class="Comment">------------------------------------------------------------------------</a>
<a id="12415" class="Comment">-- All</a>

<a id="12423" class="Keyword">module</a> <a id="AllExplanation"></a><a id="12430" href="README.Data.List.html#12430" class="Module">AllExplanation</a> <a id="12445" class="Keyword">where</a>

  <a id="12454" class="Comment">-- The dual to `Any` is the predicate `All` which encodes the idea that</a>
  <a id="12528" class="Comment">-- every element in a given list satisfies a given property.</a>

  <a id="12592" class="Keyword">open</a> <a id="12597" class="Keyword">import</a> <a id="12604" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a>

  <a id="12636" class="Comment">-- Proofs for `All` are constructed using exactly the same syntax as</a>
  <a id="12707" class="Comment">-- is used to construct lists (&quot;[]&quot; &amp; &quot;_∷_&quot;). For example to prove</a>
  <a id="12776" class="Comment">-- that every element in a list is less than or equal to one:</a>

  <a id="AllExplanation.lem₁"></a><a id="12841" href="README.Data.List.html#12841" class="Function">lem₁</a> <a id="12846" class="Symbol">:</a> <a id="12848" href="Data.List.Relation.Unary.All.html#1274" class="Datatype">All</a> <a id="12852" class="Symbol">(</a><a id="12853" href="Data.Nat.Base.html#937" class="Datatype Operator">_≤</a> <a id="12856" class="Number">1</a><a id="12857" class="Symbol">)</a> <a id="12859" class="Symbol">(</a><a id="12860" class="Number">1</a> <a id="12862" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12864" class="Number">0</a> <a id="12866" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12868" class="Number">1</a> <a id="12870" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12872" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="12874" class="Symbol">)</a>
  <a id="12878" href="README.Data.List.html#12841" class="Function">lem₁</a> <a id="12883" class="Symbol">=</a> <a id="12885" href="README.Data.List.html#12934" class="Function">1≤1</a> <a id="12889" href="Data.List.Relation.Unary.All.html#1354" class="InductiveConstructor Operator">∷</a> <a id="12891" href="README.Data.List.html#12920" class="Function">0≤1</a> <a id="12895" href="Data.List.Relation.Unary.All.html#1354" class="InductiveConstructor Operator">∷</a> <a id="12897" href="README.Data.List.html#12934" class="Function">1≤1</a> <a id="12901" href="Data.List.Relation.Unary.All.html#1354" class="InductiveConstructor Operator">∷</a> <a id="12903" href="Data.List.Relation.Unary.All.html#1337" class="InductiveConstructor">[]</a>
    <a id="12910" class="Keyword">where</a>
    <a id="12920" href="README.Data.List.html#12920" class="Function">0≤1</a> <a id="12924" class="Symbol">=</a> <a id="12926" href="Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a>
    <a id="12934" href="README.Data.List.html#12934" class="Function">1≤1</a> <a id="12938" class="Symbol">=</a> <a id="12940" href="Data.Nat.Base.html#1002" class="InductiveConstructor">s≤s</a> <a id="12944" href="Data.Nat.Base.html#960" class="InductiveConstructor">z≤n</a>

  <a id="12951" class="Comment">-- As with `Any`, the module also provides the standard operators</a>
  <a id="13019" class="Comment">-- `map`, `zip` etc. to manipulate proofs for `All`.</a>

  <a id="13075" class="Keyword">import</a> <a id="13082" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="13111" class="Symbol">as</a> <a id="13114" class="Module">All</a>
  <a id="13120" class="Keyword">open</a> <a id="13125" class="Keyword">import</a> <a id="13132" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="13152" class="Keyword">using</a> <a id="13158" class="Symbol">(</a><a id="13159" href="Data.Nat.Properties.html#3922" class="Function">≤-trans</a><a id="13166" class="Symbol">;</a> <a id="13168" href="Data.Nat.Properties.html#6236" class="Function">n≤1+n</a><a id="13173" class="Symbol">)</a>

  <a id="AllExplanation.lem₂"></a><a id="13178" href="README.Data.List.html#13178" class="Function">lem₂</a> <a id="13183" class="Symbol">:</a> <a id="13185" href="Data.List.Relation.Unary.All.html#1274" class="Datatype">All</a> <a id="13189" class="Symbol">(</a><a id="13190" href="Data.Nat.Base.html#937" class="Datatype Operator">_≤</a> <a id="13193" class="Number">2</a><a id="13194" class="Symbol">)</a> <a id="13196" class="Symbol">(</a><a id="13197" class="Number">1</a> <a id="13199" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13201" class="Number">0</a> <a id="13203" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13205" class="Number">1</a> <a id="13207" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13209" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="13211" class="Symbol">)</a>
  <a id="13215" href="README.Data.List.html#13178" class="Function">lem₂</a> <a id="13220" class="Symbol">=</a> <a id="13222" href="Data.List.Relation.Unary.All.html#3090" class="Function">All.map</a> <a id="13230" href="README.Data.List.html#13255" class="Function">≤1⇒≤2</a> <a id="13236" href="README.Data.List.html#12841" class="Function">lem₁</a>
    <a id="13245" class="Keyword">where</a>
    <a id="13255" href="README.Data.List.html#13255" class="Function">≤1⇒≤2</a> <a id="13261" class="Symbol">:</a> <a id="13263" class="Symbol">∀</a> <a id="13265" class="Symbol">{</a><a id="13266" href="README.Data.List.html#13266" class="Bound">x</a><a id="13267" class="Symbol">}</a> <a id="13269" class="Symbol">→</a> <a id="13271" href="README.Data.List.html#13266" class="Bound">x</a> <a id="13273" href="Data.Nat.Base.html#937" class="Datatype Operator">≤</a> <a id="13275" class="Number">1</a> <a id="13277" class="Symbol">→</a> <a id="13279" href="README.Data.List.html#13266" class="Bound">x</a> <a id="13281" href="Data.Nat.Base.html#937" class="Datatype Operator">≤</a> <a id="13283" class="Number">2</a>
    <a id="13289" href="README.Data.List.html#13255" class="Function">≤1⇒≤2</a> <a id="13295" href="README.Data.List.html#13295" class="Bound">x≤1</a> <a id="13299" class="Symbol">=</a> <a id="13301" href="Data.Nat.Properties.html#3922" class="Function">≤-trans</a> <a id="13309" href="README.Data.List.html#13295" class="Bound">x≤1</a> <a id="13313" class="Symbol">(</a><a id="13314" href="Data.Nat.Properties.html#6236" class="Function">n≤1+n</a> <a id="13320" class="Number">1</a><a id="13321" class="Symbol">)</a>

<a id="13324" class="Comment">------------------------------------------------------------------------</a>
<a id="13397" class="Comment">-- Membership</a>

<a id="13412" class="Keyword">module</a> <a id="MembershipExplanation"></a><a id="13419" href="README.Data.List.html#13419" class="Module">MembershipExplanation</a> <a id="13441" class="Keyword">where</a>

  <a id="13450" class="Comment">-- Membership of a list is simply a special case of `Any` where</a>
  <a id="13516" class="Comment">-- `x ∈ xs` is defined as `Any (x ≈_) xs`.</a>

  <a id="13562" class="Comment">-- Just like pointwise equality of lists, the exact membership module</a>
  <a id="13634" class="Comment">-- that should be used depends on whether the equality on the</a>
  <a id="13698" class="Comment">-- underlying elements of the list is i) propositional or setoid-based</a>
  <a id="13771" class="Comment">-- and ii) decidable.</a>

  <a id="13796" class="Keyword">import</a> <a id="13803" href="Data.List.Membership.Setoid.html" class="Module">Data.List.Membership.Setoid</a> <a id="13831" class="Symbol">as</a> <a id="13834" class="Module">SetoidMembership</a>
  <a id="13853" class="Keyword">import</a> <a id="13860" href="Data.List.Membership.DecSetoid.html" class="Module">Data.List.Membership.DecSetoid</a> <a id="13891" class="Symbol">as</a> <a id="13894" class="Module">DecSetoidMembership</a>
  <a id="13916" class="Keyword">import</a> <a id="13923" href="Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="13958" class="Symbol">as</a> <a id="13961" class="Module">PropMembership</a>
  <a id="13978" class="Keyword">import</a> <a id="13985" href="Data.List.Membership.DecPropositional.html" class="Module">Data.List.Membership.DecPropositional</a> <a id="14023" class="Symbol">as</a> <a id="14026" class="Module">DecPropMembership</a>

  <a id="14047" class="Comment">-- For example if we want to reason about membership for `List ℕ`</a>
  <a id="14115" class="Comment">-- then you would use the `DecSetoidMembership` as we use</a>
  <a id="14175" class="Comment">-- propositional equality over `ℕ` and it is also decidable. Therefore</a>
  <a id="14248" class="Comment">-- the module `DecPropMembership` should be opened as follows:</a>

  <a id="14314" class="Keyword">open</a> <a id="14319" href="Data.List.Membership.DecPropositional.html" class="Module">DecPropMembership</a> <a id="14337" href="Data.Nat.Properties.html#2239" class="Function Operator">NatProp._≟_</a>

  <a id="14352" class="Comment">-- As membership is just an instance of `Any` we also need to import</a>
  <a id="14423" class="Comment">-- the constructors `here` and `there`. (See issue #553 on Github for</a>
  <a id="14495" class="Comment">-- why we&#39;re struggling to have `here` and `there` automatically</a>
  <a id="14562" class="Comment">-- re-exported by the membership modules).</a>

  <a id="14608" class="Keyword">open</a> <a id="14613" class="Keyword">import</a> <a id="14620" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="14649" class="Keyword">using</a> <a id="14655" class="Symbol">(</a><a id="14656" href="Data.List.Relation.Unary.Any.html#1164" class="InductiveConstructor">here</a><a id="14660" class="Symbol">;</a> <a id="14662" href="Data.List.Relation.Unary.Any.html#1217" class="InductiveConstructor">there</a><a id="14667" class="Symbol">)</a>

  <a id="14672" class="Comment">-- These modules provide the infix notation `_∈_` which can be used</a>
  <a id="14742" class="Comment">-- as follows:</a>

  <a id="MembershipExplanation.lem₁"></a><a id="14760" href="README.Data.List.html#14760" class="Function">lem₁</a> <a id="14765" class="Symbol">:</a> <a id="14767" class="Number">1</a> <a id="14769" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈</a> <a id="14771" class="Number">2</a> <a id="14773" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14775" class="Number">1</a> <a id="14777" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14779" class="Number">3</a> <a id="14781" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14783" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="14788" href="README.Data.List.html#14760" class="Function">lem₁</a> <a id="14793" class="Symbol">=</a> <a id="14795" href="Data.List.Relation.Unary.Any.html#1217" class="InductiveConstructor">there</a> <a id="14801" class="Symbol">(</a><a id="14802" href="Data.List.Relation.Unary.Any.html#1164" class="InductiveConstructor">here</a> <a id="14807" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="14811" class="Symbol">)</a>

  <a id="14816" class="Comment">-- Properties of the membership relation can be found in the following</a>
  <a id="14889" class="Comment">-- two files:</a>

  <a id="14906" class="Keyword">import</a> <a id="14913" href="Data.List.Membership.Setoid.Properties.html" class="Module">Data.List.Membership.Setoid.Properties</a> <a id="14952" class="Symbol">as</a> <a id="14955" class="Module">SetoidProperties</a>
  <a id="14974" class="Keyword">import</a> <a id="14981" href="Data.List.Membership.Propositional.Properties.html" class="Module">Data.List.Membership.Propositional.Properties</a> <a id="15027" class="Symbol">as</a> <a id="15030" class="Module">PropProperties</a>

  <a id="15048" class="Comment">-- As of yet there are no corresponding files for properties of</a>
  <a id="15114" class="Comment">-- membership for decidable versions of setoid and propositional</a>
  <a id="15181" class="Comment">-- equality as we have no properties that only hold when equality is</a>
  <a id="15252" class="Comment">-- decidable.</a>

  <a id="15269" class="Comment">-- These `Properties` modules are NOT parameterised in the same way as</a>
  <a id="15342" class="Comment">-- the main membership modules as some of the properties relate</a>
  <a id="15408" class="Comment">-- membership proofs for lists of different types. For example in the</a>
  <a id="15480" class="Comment">-- following the first `∈` refers to lists of type `List ℕ` whereas</a>
  <a id="15550" class="Comment">-- the second `∈` refers to lists of type `List Char`.</a>

  <a id="15608" class="Keyword">open</a> <a id="15613" href="Data.List.Membership.DecPropositional.html" class="Module">DecPropMembership</a> <a id="15631" href="Data.Char.Properties.html#1958" class="Function Operator">CharProp._≟_</a> <a id="15644" class="Keyword">renaming</a> <a id="15653" class="Symbol">(</a>_∈_ <a id="15658" class="Symbol">to</a> _∈ᶜ_<a id="15665" class="Symbol">)</a>
  <a id="15669" class="Keyword">open</a> <a id="15674" href="Data.List.Membership.Setoid.Properties.html" class="Module">SetoidProperties</a> <a id="15691" class="Keyword">using</a> <a id="15697" class="Symbol">(</a><a id="15698" href="Data.List.Membership.Setoid.Properties.html#4589" class="Function">∈-map⁺</a><a id="15704" class="Symbol">)</a>

  <a id="MembershipExplanation.lem₂"></a><a id="15709" href="README.Data.List.html#15709" class="Function">lem₂</a> <a id="15714" class="Symbol">:</a> <a id="15716" class="Symbol">{</a><a id="15717" href="README.Data.List.html#15717" class="Bound">v</a> <a id="15719" class="Symbol">:</a> <a id="15721" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15722" class="Symbol">}</a> <a id="15724" class="Symbol">{</a><a id="15725" href="README.Data.List.html#15725" class="Bound">xs</a> <a id="15728" class="Symbol">:</a> <a id="15730" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="15735" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15736" class="Symbol">}</a> <a id="15738" class="Symbol">→</a> <a id="15740" href="README.Data.List.html#15717" class="Bound">v</a> <a id="15742" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈</a> <a id="15744" href="README.Data.List.html#15725" class="Bound">xs</a> <a id="15747" class="Symbol">→</a> <a id="15749" href="Agda.Builtin.Char.html#439" class="Primitive">fromℕ</a> <a id="15755" href="README.Data.List.html#15717" class="Bound">v</a> <a id="15757" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈ᶜ</a> <a id="15760" href="Data.List.Base.html#1383" class="Function">map</a> <a id="15764" href="Agda.Builtin.Char.html#439" class="Primitive">fromℕ</a> <a id="15770" href="README.Data.List.html#15725" class="Bound">xs</a>
  <a id="15775" href="README.Data.List.html#15709" class="Function">lem₂</a> <a id="15780" class="Symbol">=</a> <a id="15782" href="Data.List.Membership.Setoid.Properties.html#4589" class="Function">∈-map⁺</a> <a id="15789" class="Symbol">(</a><a id="15790" href="Relation.Binary.PropositionalEquality.html#2290" class="Function">setoid</a> <a id="15797" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15798" class="Symbol">)</a> <a id="15800" class="Symbol">(</a><a id="15801" href="Relation.Binary.PropositionalEquality.html#2290" class="Function">setoid</a> <a id="15808" href="Agda.Builtin.Char.html#200" class="Postulate">Char</a><a id="15812" class="Symbol">)</a> <a id="15814" class="Symbol">(</a><a id="15815" href="Relation.Binary.PropositionalEquality.Core.html#1131" class="Function">cong</a> <a id="15820" href="Agda.Builtin.Char.html#439" class="Primitive">fromℕ</a><a id="15825" class="Symbol">)</a>
</pre></body></html>